---
layout: post
title: 《Redis设计与实现》读书笔记-数据结构与对象
date: 2024-10-27 13:19:58
categories:
  - 读书笔记
tags:
  - 《Redis设计与实现》
  - Redis
  - 数据库
---

## 前言

有点遗憾，梁敬彬和梁敬弘老师关于数据库的第二本佳作《收获，不止SQl优化》短期内可能不会去看了。
正如老师在《收获，不止Oracle》第一章中所写，数据库是个庞大的体系，应该根据自己的需求去学习。
目前看来，时机未到。我需要更多的积累之后，再去阅读关于SQL优化的书。毕竟没有足够的使用经验，很难达到“哦，原来可以这么优化”的顿悟的感觉。
所以暂且搁置。开始 Redis 的学习，知识的广度也很重要。

《Redis设计与实现》第一部分：数据结构与对象包含第2-8章。第一章是引言，介绍书的大概结构和阅读顺序，这里省略。

## 第二章 - 简单动态字符串

Redis 没有直接使用 C 语言传统的字符串（以空字符结尾的字符数组），而是自己实现了一种新的字符串类型，叫做简单动态字符串，简称
SDS（Simple Dynamic String）。并使用 SDS 来作为 Redis 的默认字符串表示。
Redis 中在一些无需对字符串进行修改的地方会使用C字符串作为字符串字面量（string literal），比如打印日志等。
而在需要修改字符串时，会使用 SDS 表示字符串值。比如：

~~~redis
set msg "hello world"
~~~

Redis 会在数据库中创建一个键值对，键是一个 SDS 对象，保存着字符串 "msg"，值也是一个 SDS 对象，保存着字符串 "hello world"。

除了用来保存数据库中的字符串值之外，SDS 还被用作缓冲区(buffer):AOF 模块中的 AOF 缓冲区，以及客户端状态中的输入缓冲区，都是由
SDS 实现的。

### SDS 的定义

每个sds.h/sdshdr结构表示一个SDS值：

~~~c
struct sdshdr {
    // 记录 buf 数组中已使用字节的数量
    // 等于 SDS 所保存字符串的长度
    int len;
    // 记录 buf 数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
};
~~~

![SDS示例.png](https://cooooing.github.io/images/《Redis设计与实现》读书笔记-数据结构与对象/SDS示例.png)

上面是一个 SDS 的示例，其中

* free 属性为 0，表示 SDS 没有分配任何未使用空间
* len 属性为 5，表示 SDS 保存了一个 5 字节长的字符串
* buf 属性是一个**字节数组**，数组中保存着字符串 "hello" 的五个字节和最后一个空字符 '\0'

SDS 遵循 C 字符串以空字符结尾的惯例，保存空字符的 1 字节空间不计算在 SDS 的 len 属性里面。
并且为空字符分配额外的 1 字节空间，以及添加空字符到字符串末尾等操作，都是由 SDS 函数自动完成的，所以这个空字符对于 SDS
的使用者来说是完全透明的。
遵循空字符结尾这一惯例的好处是，SDS 可以直接重用一部分 C 字符串函数库里面的函数。而无需为 SDS 做任何额外的工作。

下面这个 SDS 和之前展示的 SDS 的区别在于，这个 SDS 为 buf 数组分配了五字节未使用空间，所以它的 free 属性的值为 5

![带有未使用空间的SDS示例.png](https://cooooing.github.io/images/《Redis设计与实现》读书笔记-数据结构与对象/带有未使用空间的SDS示例.png)

后面介绍 free 空间在 SDS 中的作用。

### SDS 与 C 字符串的区别

根据传统，C 语言使用长度为 N+1 的字符数组来表示长度为 N 的字符串，并且字符数组的最后一个元素总是空字符'\0'。

**常数复杂度获取字符串长度**
因为 C 字符串并不记录自身的长度信息，所以为了获取一个 C 字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为O（N）。
和 C 字符串不同，因为 SDS 在 len 属性中记录了 SDS 本身的长度，所以获取一个 SDS 长度的复杂度仅为O（1）。
设置和更新 SDS 长度的工作是由 SDS 的 API 在执行时自动完成的，使用 SDS 无须进行任何手动修改长度的工作。

**杜绝缓冲区溢出**
除了获取字符串长度的复杂度高之外，C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）。
举个例子，<string.h>/strcat 函数可以将 src 字符串中的内容拼接到 dest 字符串的末尾。
因为 C 字符串不记录自身的长度，所以 strcat 假定用户在执行这个函数时，已经为 dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而一旦这个假定不成立时，就会产生缓冲区溢出。

而当 SDS API 需要对 SDS 进行修改时，API 会先检查 SDS 的空间是否满足修改所需的要求，如果不满足的话，API 会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出问题。

**减少修改字符串时带来的内存重分配次数**
因为 C 字符串并不记录自身的长度，所以对于一个包含了 N 个字符的 C 字符串来说，这个 C 字符串的底层实现总是一个 N+1 个字符长的数组（额外的一个字符空间用于保存空字符）。
因为 C 字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个 C 字符串，程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作：

* 如果程序执行的是增长字符串的操作，比如拼接操作（append），那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步就会产生缓冲区溢出。
* 如果程序执行的是缩短字符串的操作，比如截断操作（trim），那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生内存泄漏。

因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作。
由于 Redis 对性能的要求非常高，经常被用于数据频繁修改的场合。所以是不能接受每次修改字符串都需要进行内存重分配操作的。

SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联：在 SDS 中，buf 数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由 SDS 的 free 属性记录。
通过未使用空间，SDS 实现了空间预分配和惰性空间释放两种优化策略。

1. 空间预分配
   空间预分配用于优化 SDS 的字符串增长操作：当 SDS 的 API 对一个 SDS 进行修改，并且需要对 SDS 进行空间扩展的时候，程序不仅会为 SDS 分配修改所必须要的空间，还会为 SDS 分配额外的未使用空间。
   额外分配的未使用空间数量由以下公式决定，这样可以减少连续修改字符串所需的内存重分配次数：
	* 如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。举个例子，如果进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1=27字节（额外的一字节用于保存空字符）。
	* 如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。举个例子，如果进行修改之后，SDS的len将变成30MB，那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB+1MB+1byte。
2. 惰性空间释放
   惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。
   通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。
   SDS也提供了相应的API，可以在有需要时，真正地释放SDS的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。

**二进制安全**
C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。

虽然数据库一般用于保存文本数据，但使用数据库来保存二进制数据的场景也不少见。
因此，为了确保Redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的（binary-safe）。
所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样。
这也是SDS的buf属性被称为字节数组的原因——Redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据。

**兼容部分C字符串函数**
虽然SDS的API都是二进制安全的，但它们一样遵循C字符串以空字符结尾的惯例：这些API总会将SDS保存的数据的末尾设置为空字符，并且总会在为buf数组分配空间时多分配一个字节来容纳这个空字符，这是为了让那些保存文本数据的SDS可以重用一部分<string.h>库定义的函数。

### SDS API

SDS 主要操作 API

| **API**       | **作用**                            | **时间复杂度**                |
|---------------|-----------------------------------|--------------------------|
| `sdsnew`      | 创建一个包含给定 C 字符串的 SDS               | O(M)，M 为给定 C 字符串的长度      |
| `sdsempty`    | 创建一个空的 SDS                        | O(1)                     |
| `sdsfree`     | 释放给定的 SDS                         | O(1)，只是释放内存              |
| `sdslen`      | 返回 SDS 的已使用空间字节数                  | O(1)，直接读取元数据             |
| `sdsavail`    | 返回 SDS 的剩余可用空间字节数                 | O(1)，直接读取元数据             |
| `sdsdup`      | 创建一个给定 SDS 的副本                    | O(M)，M 为给定 SDS 的长度       |
| `sdsclear`    | 清空 SDS 保存的字符串内容                   | O(1)，保留空间，不释放内存          |
| `sdscat`      | 将给定 C 字符串拼接到 SDS 字符串的末尾           | O(M)，M 为被拼接 C 字符串的长度     |
| `sdscatsds`   | 将给定 SDS 字符串拼接到另一个 SDS 字符串的末尾      | O(M)，M 为被拼接 SDS 字符串的长度   |
| `sdscpy`      | 将给定的 C 字符串复制到 SDS 中，覆盖 SDS 原有的字符串 | O(N)，N 为被复制 C 字符串的长度     |
| `sdsgrowzero` | 扩展 SDS 到指定长度，如果长度变大，则在新增空间中填充零字符  | O(M)，M 为扩展新增的字节数         |
| `sdssubstr`   | 保留 SDS 给定区间内的数据，不在区间内的数据会被覆盖或删除   | O(N)，N 为被保留数据的字节数        |
| `sdstrim`     | 移除 SDS 中所有在给定 C 字符串中出现过的字符        | O(M)，M 为给定 C 字符串的长度      |
| `sdscmp`      | 比较两个 SDS 字符串是否相同                  | O(N)，N 为两个 SDS 中较短的那个的长度 |

### End

Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS（Simple Dynamic String，简单动态字符串）作为字符串表示。

这里对字符串的包装，跟很多其他语言中的字符串类似。不过大部分语言中的字符串是不可变的。
可能和 go 中数组更类似，使用 make 来创建，可以传两个整型，第一个是长度，第二个是容量。

## 第三章 - 链表

链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。
作为一种常用数据结构，链表内置在很多高级的编程语言里面，因为Redis使用的C语言并没有内置这种数据结构，所以Redis构建了自己的链表实现。
链表在Redis中的应用非常广泛，比如列表键的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。
除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，Redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区（output buffer）

### 链表和链表节点的实现

每个链表节点使用一个adlist.h/listNode结构来表示：

~~~c
typedef struct listNode {
    // 前置节点
    struct listNode * prev;
    // 后置节点
    struct listNode * next;
    // 节点的值
    void * value;
}listNode;
~~~

多个listNode可以通过prev和next指针组成双端链表，如下图

![由多个listNode组成的双端链表.png](https://cooooing.github.io/images/《Redis设计与实现》读书笔记-数据结构与对象/由多个listNode组成的双端链表.png)

虽然仅仅使用多个listNode结构就可以组成链表，但使用adlist.h/list来持有链表的话，操作起来会更方便。

~~~c
typedef struct list {
    // 表头节点
    listNode * head;
    // 表尾节点
    listNode * tail;
    // 链表所包含的节点数量
    unsigned long len;
    // 节点值复制函数
    void *(*dup)(void *ptr);
    // 节点值释放函数
    void (*free)(void *ptr);
    // 节点值对比函数
    int (*match)(void *ptr,void *key);
} list;
~~~

list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数：

* dup函数用于复制链表节点所保存的值
* free函数用于释放链表节点所保存的值
* match函数则用于对比链表节点所保存的值和另一个输入值是否相等

![由list结构和listNode结构组成的链表.png](https://cooooing.github.io/images/《Redis设计与实现》读书笔记-数据结构与对象/由list结构和listNode结构组成的链表.png)

Redis的链表实现的特性可以总结如下：

* 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O（1）。
* 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。
* 带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O（1）。
* 带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O（1）。
* 多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。

### 链表和链表节点的API

| **函数**               | **作用**                        | **时间复杂度**                       |
|----------------------|-------------------------------|---------------------------------|
| `listSetDupMethod`   | 将给定的函数设置为链表的节点值复制函数           | 复制函数可以通过链表的 `dup` 属性直接获得，O(1)   |
| `listGetDupMethod`   | 返回链表当前正在使用的节点值复制函数            | O(1)                            |
| `listSetFreeMethod`  | 将给定的函数设置为链表的节点值释放函数           | 释放函数可以通过链表的 `free` 属性直接获得，O(1)  |
| `listGetFreeMethod`  | 返回链表当前正在使用的节点值释放函数            | O(1)                            |
| `listSetMatchMethod` | 将给定的函数设置为链表的节点值对比函数           | 对比函数可以通过链表的 `match` 属性直接获得，O(1) |
| `listGetMatchMethod` | 返回链表当前正在使用的节点值对比函数            | O(1)                            |
| `listLength`         | 返回链表的长度（包含多少个节点）              | 链表长度可以通过链表的 `len` 属性直接获得，O(1)   |
| `listFirst`          | 返回链表的表头节点                     | 表头节点可以通过链表的 `head` 属性直接获得，O(1)  |
| `listLast`           | 返回链表的表尾节点                     | 表尾节点可以通过链表的 `tail` 属性直接获得，O(1)  |
| `listPrevNode`       | 返回给定节点的前置节点                   | 前置节点可以通过节点的 `prev` 属性直接获得，O(1)  |
| `listNextNode`       | 返回给定节点的后置节点                   | 后置节点可以通过节点的 `next` 属性直接获得，O(1)  |
| `listNodeValue`      | 返回给定节点当前保存的值                  | 节点值可以通过节点的 `value` 属性直接获得，O(1)  |
| `listCreate`         | 创建一个不包含任何节点的新链表               | O(1)                            |
| `listAddNodeHead`    | 将一个包含给定值的新节点添加到链表的表头          | O(1)                            |
| `listAddNodeTail`    | 将一个包含给定值的新节点添加到链表的表尾          | O(1)                            |
| `listInsertNode`     | 将一个包含给定值的新节点插入到指定节点的前或后       | O(1)                            |
| `listSearchKey`      | 查找并返回链表中包含给定值的节点              | O(N)，N 为链表长度                    |
| `listIndex`          | 返回链表中给定索引位置的节点                | O(N)，N 为链表长度                    |
| `listDelNode`        | 从链表中删除给定的节点                   | O(1)                            |
| `listRotate`         | 将链表的表尾节点弹出，并插入到链表的表头，成为新的表头节点 | O(1)                            |
| `listDup`            | 复制一个给定链表的副本                   | O(N)，N 为链表长度                    |
| `listRelease`        | 释放给定链表及其所有节点                  | O(N)，N 为链表长度                    |

## 第四章 - 字典

字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。
在字典中，一个键（key）可以和一个值（value）进行关联（或者说将键映射为值），这些关联的键和值就称为键值对。
字典中的每个键都是独一无二的，程序可以在字典中根据键查找与之关联的值，或者通过键来更新值，又或者根据键来删除整个键值对，等等。
字典经常作为一种数据结构内置在很多高级编程语言里面，但Redis所使用的C语言并没有内置这种数据结构，因此Redis构建了自己的字典实现。
字典在Redis中的应用相当广泛，比如Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。

### 字典的实现

Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。

#### 哈希表

Redis字典所使用的哈希表由dict.h/dictht结构定义：

~~~c
typedef struct dictht {
	// 哈希表数组
	dictEntry **table;
	// 哈希表大小
	unsigned long size;
	// 哈希表大小掩码，用于计算索引值
	// 总是等于size-1
	unsigned long sizemask;
	// 该哈希表已有节点的数量
	unsigned long used;
} dictht;
~~~

table 属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对。
size 属性记录了哈希表的大小，也即是table数组的大小。
used 属性则记录了哈希表目前已有节点（键值对）的数量。
sizemask 属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面。

![一个空的哈希表.png](https://cooooing.github.io/images/《Redis设计与实现》读书笔记-数据结构与对象/一个空的哈希表.png)

#### 哈希表节点

哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：

~~~c
typedef struct dictEntry {
    // 键
    void *key;
    // 值
    union{
        void *val;
        uint64_tu64;
        int64_ts64;
    } v;
    // 指向下个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
~~~

key 属性保存着键值对中的键。
v 属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。
next 属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题。

![连接在一起的键K1和键K0.png](https://cooooing.github.io/images/《Redis设计与实现》读书笔记-数据结构与对象/连接在一起的键K1和键K0.png)

### 字典

Redis中的字典由dict.h/dict结构表示：

~~~c
typedef struct dict {
    // 类型特定函数
    dictType *type;
    // 私有数据
    void *privdata;
    // 哈希表
    dictht ht[2];
    // rehash索引
    // 当rehash不在进行时，值为-1
    in trehashidx; /* rehashing not in progress if rehashidx == -1 */
} dict;
~~~

type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：

* type 属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。
* privdata 属性保存了需要传给那些类型特定函数的可选参数。

ht 属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用`ht[0]`哈希表，`ht[1]`哈希表只会在对`ht[0]`哈希表进行rehash时使用。
rehashidx 属性记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。

~~~c
typedef struct dictType {
    // 计算哈希值的函数
    unsigned int (*hashFunction)(const void *key);
    // 复制键的函数
    void *(*keyDup)(void *privdata, const void *key);
    // 复制值的函数
    void *(*valDup)(void *privdata, const void *obj);
    // 对比键的函数
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    // 销毁键的函数
    void (*keyDestructor)(void *privdata, void *key);
    // 销毁值的函数
    void (*valDestructor)(void *privdata, void *obj);
} dictType;
~~~

![普通状态下的字典.png](https://cooooing.github.io/images/《Redis设计与实现》读书笔记-数据结构与对象/普通状态下的字典.png)

### 哈希算法

当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

Redis计算哈希值和索引值的方法如下：

使用字典设置的哈希函数，计算键 key 的哈希值
`hash = dict->type->hashFunction(key);`

使用哈希表的 sizemask 属性和哈希值，计算出索引值

根据情况不同，`ht[x]`可以是`ht[0]`或者`ht[1]`
`index = hash & dict->ht[x].sizemask;`

当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。
[MurmurHash Wiki](https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C)


### 解决键冲突

当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突（collision）。
**Redis的哈希表使用链地址法（separate chaining）来解决键冲突**，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。
因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，**程序总是将新节点添加到链表的表头位置（复杂度为O（1））**，排在其他已有节点的前面。

![使用链表解决k2和k1的冲突.png](https://cooooing.github.io/images/《Redis设计与实现》读书笔记-数据结构与对象/使用链表解决k2和k1的冲突.png)

### Rehash

随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。
扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，Redis对字典的哈希表执行rehash的步骤如下：
1. 为字典的`ht[1]`哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及`ht[0]`当前包含的键值对数量（也即是`ht[0]`.used属性的值）：
	* 如果执行的是扩展操作，那么`ht[1]`的大小为第一个大于等于`ht[0]`.used*2的2^n（2的n次方幂），即两倍。           
    * 如果执行的是收缩操作，那么`ht[1]`的大小为第一个大于等于`ht[0]`.used的2^n。即元素数量的最小倍数。
2. 将保存在`ht[0]`中的所有键值对rehash到`ht[1]`上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到`ht[1]`哈希表的指定位置上。
3. 当`ht[0]`包含的所有键值对都迁移到了`ht[1]`之后（`ht[0]`变为空表），释放`ht[0]`，将`ht[1]`设置为`ht[0]`，并在`ht[1]`新创建一个空白哈希表，为下一次rehash做准备。


当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：
1. 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。
2. 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。

当哈希表的负载因子小于0.1（即小于当前大小十倍）时，程序自动开始对哈希表执行收缩操作。

其中哈希表的负载因子可以通过下面的公式算出：
负载因子 = 哈希表已保存节点数量 / 哈希表大小 
load_factor = ht[0].used / ht[0].size

根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同。
这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率。
所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。

> `BGSAVE` 命令用于在后台异步地执行数据快照（snapshot）保存操作，即创建 Redis 数据的 RDB 文件。执行这个命令时，Redis 会生成一个 RDB 文件，并将当前数据库中的所有数据保存到这个文件中。
> `BGREWRITEAOF` 命令用于在后台异步地重写 AOF（Append Only File）日志文件。AOF 是 Redis 提供的另一种持久化方式，通过记录每一个写命令来实现数据的持久化。
> 写时复制（copy-on-write）是指当一个进程创建一个子进程时，子进程会共享父进程的内存页面，而不是立即拷贝整个内存数据。这种共享是“只读”的，直到某一方（父进程或子进程）试图修改共享的数据时，系统才会真正复制该内存页面。这种方式避免了在创建子进程时立即拷贝大量内存数据的开销。

### 渐进式rehash













