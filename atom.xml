<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>咕咕咕的小破站</title>
  
  
  <link href="https://cooooing.github.io/atom.xml" rel="self"/>
  
  <link href="https://cooooing.github.io/"/>
  <updated>2025-01-14T02:35:39.000Z</updated>
  <id>https://cooooing.github.io/</id>
  
  <author>
    <name>咕咕咕</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《go语言并发之道》读书笔记-并发组件</title>
    <link href="https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E7%BB%84%E4%BB%B6/"/>
    <id>https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E7%BB%84%E4%BB%B6/</id>
    <published>2025-01-14T02:35:39.000Z</published>
    <updated>2025-01-14T02:35:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-Go语言并发组件"><a href="#第三章-Go语言并发组件" class="headerlink" title="第三章 - Go语言并发组件"></a>第三章 - Go语言并发组件</h2><p>这章介绍Go中的特性，以及它如何支持并发。（终于到实际使用了</p><h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p>goroutine是Go语言程序中最基本的组织单位之一。<br>每个Go语言程序都至少有一个goroutine:main goroutine，它在进程开始时自动创建并启动。<br>几乎在所有的项目中，你迟早会使用goroutine来解决Go语言编程遇到的问题。所以，它们是什么？</p><p>简单地说，goroutine是一个并发的函数（记住：不一定是并行的），与其他代码一起运行。<br>你可以简单地在一个函数之前添加go关键字来触发：<code>go sum()</code><br>同样可以作为匿名函数使用！这里有一个例子和前面的例子一样。<br>然而，我们不是创建一个基于函数的goroutine,而是创建一个基于匿名函数 goroutine:<code>go func() &#123; // ... &#125;()</code></p><p>下面的内容来看看 goroutine 是如何工作的？它们是OS线程吗？绿色线程？我们能创造多少个 goroutine？</p><p>Go语言中的goroutine是独一无二的（尽管其他的一些语言有类似的并发原语)。<br>它们不是OS线程，也不是绿色线程（由语言运行时管理的线程），它们是一个更高级别的抽象，称为协程。<br><strong>协程是一种非抢占式的简单并发子goroutine(函数、闭包或方法)，也就是说，它们不能被中断。</strong> 取而代之的是，协程有多个点，允许暂停或重新进入。</p><p>goroutine的独特之处在于它们与Go语言的运行时的深度集成。goroutine没有定义自己的暂停方法或再运行点。<br><strong>Go语言的运行时会观察goroutine的运行时行为，并在它们阻塞时自动挂起它们，然后在它们不被阻塞时恢复它们。</strong><br><strong>在某种程度上，这使它们成为可抢占的，但只是在goroutine被阻塞的情况。</strong> 在运行时和goroutine的逻辑之间，是一种优雅的伙伴关系。<br>因此，goroutine可以被认为是一种特殊类型的协程。</p><p>协程和goroutine都是隐式并发结构，但并发并不是协程的属性：必须同时托管多个协程，并给每个协程一个执行的机会。否则，它们就不会并发！<br>请注意，这并不意味着协程是隐式并行的。当然有可能有几个协程按顺序并行执行的假象，事实上，这种情况一直在发生。</p><p>Go语言的主机托管机制是一个名为M:N调度器的实现，这意味着它将M个绿色线程映射到N个OS线程。然后将goroutine安排在绿色线程上。<br>当我们的goroutine数量超过可用的绿色线程时，调度程序将处理分布在可用线程上的goroutine,并确保当这些goroutine被阻塞时，其他的goroutine可以运行。<br>这里只介绍Go语言的并发模型，细节在后续章节中。</p><p>Go语言遵循一个称为ork-join的并发模型。<br>fork这个词指的是在程序中的任意一点，它可以将执行的子分支与共父节点同时运行。<br>jon这个词指的是，在将来某个时候，这些并发的执行分支将会合并在一起。<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E7%BB%84%E4%BB%B6/fork-join%E7%A4%BA%E6%84%8F%E5%9B%BE.png"                        alt="img.png"                 ></p><p>Go语言是如何执行fork的，执行的子线程是goroutine。<br>让我们回到简单的goroutine例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sayHello := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> sayHello()</span><br><span class="line"><span class="comment">//继续执行自己的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，sayHello函数将在goroutine上运行，而程序的其余部分将继续执行。<br>在本例中，没有join点。执行sayHello的goroutine将在未来的某个不确定的时间退出，而程序的其余部分将会继续执行。</p><p>但是，这个例子有一个问题：正如上面所写的程序，它不确定sayHello函数是否会运行。<br>goroutine将会被创建，并计划在Go语言运行时执行，但是它实际上可能没有机会在main goroutine退出之前运行。</p><p>实际上，因为我们省略了min函数的其余部分，为了简单起见，当运行这个小示例时，几乎可以肯定的是，程序将在goroutine被系统调用之前完成执行。<br>因此，你不会看到“hello’”这个词被打印到stdout。你可以在创建goroutine之后执行time.Sleep,但是要记住，这实际上并没有创建一个join点，只有一个竞争条件。<br>如果回顾第1章，你增加了goroutine在程序退出前执行的概率，但你并不能保证一定会执行。<strong>join点是保证程序正确性和消除竞争条件的关键。</strong></p><p>为了创建一个join点，你必须同步main goroutine和sayHello goroutine。<br>这可以通过多种方式实现，这里使用：sync.Waitgroup。<br>下面是一个正确的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">sayHello := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> sayHello()</span><br><span class="line">wg.Wait() <span class="comment">// 这就是连接点的使用方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下： <code>hello</code></p><p>这个例子将决定main goroutine,直到goroutine托管sayHello函数为止。<br>我们在示例中使用了许多匿名函数来创建快速goroutine样例。让我们把注意力转移到闭包上。<br>闭包可以从创建它们的作用域中获取变量。如果你在goroutine中运行一个闭包，那么闭包是在这些变量的副本上运行，还是原值的引用上运行？<br>让我们试试看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">salutation := <span class="string">&quot;hello&quot;</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">salutation = <span class="string">&quot;welcome&quot;</span> <span class="comment">// 尝试修改 salutation 变量</span></span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(salutation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<code>welcome</code><br>事实证明，goroutine在它们所创建的相同地址空间内执行，因此我们的程序打印出“welcome”这个词。<br>让我们再看一个例子。你认为这个程序会输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, salutation := <span class="keyword">range</span> []<span class="type">string</span>&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;greetings&quot;</span>, <span class="string">&quot;good day&quot;</span>&#125; &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(salutation) <span class="comment">// 引用了字符串类型的切片作为创建循环变量的salutation值</span></span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案比大多数人想象的要复杂得多，而且是为数不多的令人惊讶的事情之一。<br>大多数人直觉上认为这将会不确定顺序地打印出“hello”“greetings”和“good day”,但看看它做了什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">good day</span><br><span class="line">good day</span><br><span class="line">good day</span><br></pre></td></tr></table></figure><p>这里真的是这样吗？在我电脑上的输出是符合大多数人的直觉的：会以不确定的顺序打印出“hello”“greetings”和“good day”。<br>为什么呢？查了资料后发现，这是循环迭代器变量引用的问题：<a class="link"   href="https://go.dev/wiki/CommonMistakes" >常见错误<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://go.dev/ref/spec#For_statements" >For 语句<i class="fas fa-external-link-alt"></i></a><br>在1.22及后不会出现循环迭代器变量引用的问题。每个循环迭代器变量都是一个新的副本，所以上面程序的输出会是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">greetings</span><br><span class="line">good day</span><br></pre></td></tr></table></figure><p>并且是乱序的（每次输出都不一致），下面的讨论在1.22之前，1.22及后不会出现。<br>在上面的示例中，goroutine正在运行一个闭包，<strong>该闭包使用变量salutation时，字符串的迭代已经结束。</strong><br>当我们循环迭代时，salutation被分配到slice literal中的下一个字符串值。因为计划中的goroutine可能在未来的任何时间点运行，它不确定在goroutine中会打印出什么值。<br>在性能比较好的机器上，在goroutine开始之前循环有很高的概率会退出。这意味着变量的salutation值不在范围之内。然后会发生什么呢？<br>goroutine还能引用一些已经超出范围的东西吗？goroutine不会访问那些可能被垃圾回收的内存吗？<br>这是一个关于如何管理内存的有趣的点。Go语言运行时会足够小心地将对变量salutation值的引用仍然保留，由内存转移到堆，以便goroutine可以继续访问它。</p><p>通常在我的计算机上，在任何goroutine开始运行之前，循环就会退出，所以salutation会被转移到堆中，在我的字符串切片中引用最后一个值“good day”。<br>所以我通常会看到三次“good day”。编写这个循环的正确方法是将salutation的副本传递到闭包中，这样当goroutine运行时，它将从循环的迭代中操作数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, salutations := <span class="keyword">range</span> []<span class="type">string</span>&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;greetings&quot;</span>, <span class="string">&quot;good day&quot;</span>&#125; &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(salutations <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(salutations)</span><br><span class="line">&#125;(salutations)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，在1.22及以后的版本是不需要这么写的。</p><p>这些goroutine在相同的地址空间中运行，并且只有简单的宿主函数，所有使用goroutine编写非并发代码是非常自然的。<br>Go语言的编译器很好地处理了内存中的变量，这样goroutine就不会意外地访问被释放的内存，这使得开发人员可以专注于他们的问题空间而不是内存管理。<br>然而，这不是一张空白支票。</p><p>由于多个goroutine可以在同一个地址空间上运行，所以我们仍然需要担心同步问题。<br>正如我们已经讨论过的，我们可以选择同步访问goroutine访问的共享内存，或者可以使用CSP原语通过通信来共享内存。</p><p>goroutine的另一个好处是它们非常轻。下面是“Go语言FAQ”的摘录：</p><blockquote><p>一个新创建的goroutine被赋予了几千字节，这在大部分情况都是足够的。<br>当它不运行时，Go语言运行时就会自动增长（缩小）存储堆栈的内存，允许许多goroutine存在适当的内存中。<br>每个函数调用CPU的开销平均为3个廉价指令。在同一个地址空间中创建成千上万的goroutine是可行的。如果goroutine只是线程，系统的资源消耗会更小。</p></blockquote><p>每个goroutine几千字节，这并没有什么问题！让我们来验证一下。<br>但是在我们开始之前，我们必须讨论一个关于goroutine有趣的事情：<br><strong>GC并没有回收被丢弃的goroutine。</strong><br>如果我写如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//将永远阻塞的操作</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//开始工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的goroutine将一直存在直到进程退出（<strong>协程泄露！</strong>）。在下一个例子中，我们将利用这一点来实际测算goroutine的大小。</p><p>在下面的例子中，我们将goroutine不被GC的事实与运行时的自省能力结合起来，并测算在goroutine创建之前和之后分配的内存数量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">memConsumed := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">runtime.GC()</span><br><span class="line"><span class="keyword">var</span> s runtime.MemStats</span><br><span class="line">runtime.ReadMemStats(&amp;s)</span><br><span class="line"><span class="keyword">return</span> s.Sys</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c &lt;-<span class="keyword">chan</span> any</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">noop := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; wg.Done(); &lt;-c &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numGoroutines = <span class="number">1e6</span></span><br><span class="line">wg.Add(numGoroutines)</span><br><span class="line">before := memConsumed()</span><br><span class="line"><span class="keyword">for</span> i := numGoroutines; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">go</span> noop()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">after := memConsumed()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%fkb&quot;</span>, <span class="type">float64</span>(after-before)/numGoroutines/<span class="number">1024</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要一个永远不会退出的goroutine.,这样就可以在内存中保留一段时间用于测侧算。<br>定义了要创建的goroutine的数量。我们将用大数定律，渐渐地接近一个goroutine的大小。<br>输出结果为：<code>8.560508kb</code>，这里go版本为1.22.4。老版本goroutine的大小会更小。</p><p>理论上百万个goroutine内存占用只有9G。这也足以说明goroutine的轻量。<br><strong>可能会影响性能的是上下文切换，即当一个被托管的并发进程必须保存它的状态以切换到一个不同的运行并发进程时。</strong><br>如果我们有太多的并发进程，可能会将所有的CPU时间消耗在它们之间的上下文切换上，而没有资源完成任何真正需要CPU的工作。<br>在操作系统级别，使用线程可能非常昂贵。OS线程必须保存如寄存器值、查找表和内存映射之类的东西，以便能够在有限的时间内成功地切换回当前线程。<br>然后，它必须为传入的线程加载相同的信息。</p><p>软件中的上下文切换相对来说要廉价得多。<br>在一个软件定义的调度器下，运行时可以更有选择性地保存数据用于检索，如何持久化，以及何时需要持久化。<br>让我们来看看在OS线程和goroutine之间切换的上下文的相对性能。<br>首先，我们将利用Linux的内置基准测试套件来度量在相同核心的两个线程之间发送消息需要多长时间（需要安装perf工具，需要与内核版本匹配：<code>sudo apt install linux-tools-common linux-tools-generic</code>）：<br><code>taskset -c 0 perf bench sched pipe -T</code></p><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Running &#x27;sched/pipe&#x27; benchmark:</span><br><span class="line"># Executed 1000000 pipe operations between two threads</span><br><span class="line"></span><br><span class="line">     Total time: 5.855 [sec]</span><br><span class="line"></span><br><span class="line">       5.855618 usecs/op</span><br><span class="line">         170776 ops/sec</span><br></pre></td></tr></table></figure><p>这个基准实际上度量了在线程上发送和接收消息所需的时间，因此我们将计算结果并将其除以2。<br>我们用了<code>2.927μs</code>来进行上下文切换。这看起来不算太糟，但还是保留判断，直到我们检查goroutine之间的上下文切换。</p><p>我们将使用Go语言构建一个类似的基准。下面的示例将创建两个goroutine并在它们之间发送一条消息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkContextSwitch</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">begin := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> token <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">sender := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">&lt;-begin</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">c &lt;- token</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">receiver := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">&lt;-begin</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">&lt;-c</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> sender()</span><br><span class="line"><span class="keyword">go</span> receiver()</span><br><span class="line">b.StartTimer()</span><br><span class="line"><span class="built_in">close</span>(begin)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果（<code>go test -bench=. -cpu=1</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkContextSwitch   6329348        218.8 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok   learn 1.582s</span><br></pre></td></tr></table></figure><p>每个上下文切换需要<code>218.8ns</code>，2.927μs的7.48%<br>很难断言goroutine会导致上下文切换过于频繁，但上限可能不会成为使用goroutine的阻碍。</p><h3 id="sync包"><a href="#sync包" class="headerlink" title="sync包"></a>sync包</h3><p><strong>sync包包含对低级别内存访问同步最有用的并发原语</strong>。<br>如果你使用的语言主要通过内存访问同步来处理并发，那么你可能已经熟悉了这些类型。<br>Go语言和这些语言之间的区别在于，Go语言已经在内存访问同步原语之上构建了一组新的并发原语，以向你提供一组扩展的工作。<br>正如我们在第2章“Go语言的并发哲学”中所讨论的，这些操作都有它们的用途，主要是在诸如struct这样的小范围内。由你决定何时进行内存访问同步。<br>说到这里，让我们开始看一下sync包公开的各种原语。</p><h4 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h4><p>当你不关心并发操作的结果，或者你有其他方法来收集它们的结果时，WaitGroup是等待一组并发操作完成的好方法。<br>如果这两个条件都不满足，我建议你使用channel和select语句。<br>下面是一个使用WaitGroup等待goroutine完成的基本例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(<span class="string">&quot;1st goroutine sleeping...&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">1</span>)</span><br><span class="line">&#125;()</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(<span class="string">&quot;2nd goroutine sleeping...&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">2</span>)</span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;All goroutines completed.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2nd goroutine sleeping...</span><br><span class="line">1st goroutine sleeping...</span><br><span class="line">All goroutines completed.</span><br></pre></td></tr></table></figure><p>可以将WaitGroup视为一个并发-安全的计数器：<strong>调用通过传入的整数执行add方法增加计数器的增量，并调用Done方法对计数器进行递减。Wait阻塞，直到计数器为零。</strong></p><p>注意，添加的Add调用是在他们帮助跟踪的goroutine之外完成的。<br>如果我们不这样做，我们就会引人一种竞争条件，因为在本章前面“goroutines’”中，我们不能保证goroutine何时会被调度，可以在goroutine开始调度前调用Wait方法。<br>如果将调用Add的方法添加到goroutine的闭包中，那么Wait调用可能会直接返回，而且不会阻塞，因为Add调用不会发生。</p><h5 id="互斥锁与读写锁"><a href="#互斥锁与读写锁" class="headerlink" title="互斥锁与读写锁"></a>互斥锁与读写锁</h5><p>Mutex 是“互斥”的意思，是保护程序中临界区的一种方式。<br>临界区是你程序中需要独占访问共享资源的区域。<br>Mutex提供了一种安全的方式来表示对这些共享资源的独占访问。<br>为了使用一个资源，channel通过通信共享内存，而Mutex通过开发人员的约定同步访问共享内存。<br>你可以通过使用Mutex对内存进行保护来协调对内存的访问。<br>这里有一个简单的例子，两个goroutine试图增加和减少一个共同的值，它们使用Mutex互斥锁来同步访问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line">increment := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">count++</span><br><span class="line">fmt.Printf(<span class="string">&quot;Incrementing: %d\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br><span class="line">decrement := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">count--</span><br><span class="line">fmt.Printf(<span class="string">&quot;Decrementing: %d\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 增量</span></span><br><span class="line"><span class="keyword">var</span> arithmetic sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">arithmetic.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> arithmetic.Done()</span><br><span class="line">increment()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 减量</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">arithmetic.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> arithmetic.Done()</span><br><span class="line">decrement()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">arithmetic.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;Arithmetic complete.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Incrementing: 1</span><br><span class="line">Decrementing: 0</span><br><span class="line">Decrementing: -1</span><br><span class="line">Incrementing: 0</span><br><span class="line">Decrementing: -1</span><br><span class="line">Decrementing: -2</span><br><span class="line">Incrementing: -1</span><br><span class="line">Incrementing: 0</span><br><span class="line">Arithmetic complete.</span><br></pre></td></tr></table></figure><p>你会注意到，<strong>我们总是在defer语句中调用Unlock。这是一个十分常见的习惯用法，它使用Mutex互斥锁来确保即使出现了panic,调用也总是发生。如果不这样做，可能会导致程序陷人死锁。</strong><br>关键部分之所以如此命名，是因为它们反映了程序中的瓶颈。进入和退出一个临界区是有消耗的，所以一般人会尽量减少在临界区的时间。<br>这样做的一个策略是减少临界区的范围。可能存在需要在多个并发进程之间共享内存的情况，但可能这些进程不是都需要读写此内存。<br>如果是这样，你可以利用不同类型的互斥对象：sync.RWMutex。</p><p>Sync.RWMutex在概念上和互斥是一样的：它守卫着对内存的访问，然而，RWMutex让你对内存有了更多控制。<br>你可以请求一个锁用于读处理，在这种情况下你将被授予访问权限，除非该锁被用于写处理。<br>这意味着，任意数量的读消费者可以持有一个读锁，只要没有共他事物持有一个写锁。<br>这里有一个例子，它演示了一个生产者，它不像代码中创建的众多消费者那样活跃：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;text/tabwriter&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">producer := <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, l sync.Locker)</span></span> &#123; <span class="comment">// 第二个参数是 sync.Locker 类型。这个接口有两个方法，Lock和Unlock。go包中有两个实现，sync.Mutex和sync.RWMutex。</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">5</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">l.Lock()</span><br><span class="line">l.Unlock()</span><br><span class="line">time.Sleep(<span class="number">1</span>) <span class="comment">// 让 producer 等待，使其比观察者的 goroutine 更不活跃。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">observer := <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, l sync.Locker)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">l.Lock()</span><br><span class="line"><span class="keyword">defer</span> l.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">test := <span class="function"><span class="keyword">func</span><span class="params">(count <span class="type">int</span>, mutex, rwMutex sync.Locker)</span></span> time.Duration &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(count + <span class="number">1</span>)</span><br><span class="line">beginTestTime := time.Now()</span><br><span class="line"><span class="keyword">go</span> producer(&amp;wg, mutex)</span><br><span class="line"><span class="keyword">for</span> i := count; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">go</span> observer(&amp;wg, rwMutex)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="keyword">return</span> time.Since(beginTestTime)</span><br><span class="line">&#125;</span><br><span class="line">tw := tabwriter.NewWriter(os.Stdout, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">defer</span> tw.Flush()</span><br><span class="line"><span class="keyword">var</span> m sync.RWMutex</span><br><span class="line">fmt.Fprintf(tw, <span class="string">&quot;Readers\tRWMutext\tMutex\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">count := <span class="type">int</span>(math.Pow(<span class="number">2</span>, <span class="type">float64</span>(i)))</span><br><span class="line">fmt.Fprintf(</span><br><span class="line">tw,</span><br><span class="line"><span class="string">&quot;%d\t%v\t%v\n&quot;</span>,</span><br><span class="line">count,</span><br><span class="line">test(count, &amp;m, m.RLocker()),</span><br><span class="line">test(count, &amp;m, &amp;m),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Readers  RWMutext    Mutex</span><br><span class="line">1        76.0748ms   78.666ms</span><br><span class="line">2        77.9551ms   77.8809ms</span><br><span class="line">4        78.9414ms   77.7889ms</span><br><span class="line">8        61.973ms    78.1634ms</span><br><span class="line">16       77.1572ms   61.3356ms</span><br><span class="line">32       62.9075ms   77.792ms</span><br><span class="line">64       61.6918ms   76.5042ms</span><br><span class="line">128      61.6087ms   77.0605ms</span><br><span class="line">256      62.1438ms   77.894ms</span><br><span class="line">512      62.8352ms   46.7669ms</span><br><span class="line">1024     46.7329ms   47.4825ms</span><br><span class="line">2048     46.5684ms   31.1086ms</span><br><span class="line">4096     47.5138ms   62.2136ms</span><br><span class="line">8192     7.0075ms    38.8685ms</span><br><span class="line">16384    12.4982ms   4.732ms</span><br><span class="line">32768    6.505ms     8.7366ms</span><br><span class="line">65536    14.3337ms   16.2156ms</span><br><span class="line">131072   32.3444ms   35.852ms</span><br><span class="line">262144   58.6523ms   71.3403ms</span><br><span class="line">524288   117.7048ms  147.1611ms</span><br></pre></td></tr></table></figure><h4 id="cond"><a href="#cond" class="headerlink" title="cond"></a>cond</h4><p>对于cond类型的注释确实很好地描述了它的用途：</p><blockquote><p>…一个goroutine的集合点，等待或发布一个event。</p></blockquote><p>在这个定义中，一个“event”是两个或两个以上的goroutine之间的任意信号，除了它已经发生的事实外，没有任何信息。<br>通常情况下，在goroutine继续执行之前，你需要等待其中一个信号。如果我们要研究如何在没有Cond类型的情况下实现这一目标，一个简单的方法就是使用无限循环：<code>for conditionTrue() == false &#123;&#125;</code><br>然而，这将消耗一个CPU核心的所有周期。为了解决这个问题，我们可以引入一个time.Sleep：<code>for conditionTrue() == false &#123; time.Sleep(1*time.Millisecond) &#125;</code><br>这样更好，但它仍然是低效的，而且你必须弄清楚要等待多久：太长，会人为地降低性能：太短，会不必要地消耗太多的CPU时间。<br>如果有一种方法可以让goroutine有效地等待，直到它发出信号并检查它的状态，那就更好了。<br>这正是Cond类型为我们所做的。使用Cond,我们可以这样编写前面例子的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := sync.NewCond(&amp;sync.Mutex&#123;&#125;) <span class="comment">// 实例化一个cond。NewCond函数创建一个类型，满足sync.Locker接口。这使得cond类型能够以一种并发安全的方式与其他goroutine协调</span></span><br><span class="line">c.L.Lock()                       <span class="comment">// 锁定这个条件。这是必要的，因为在进入Locker的时候，执行wait会自动执行unlock。</span></span><br><span class="line"><span class="keyword">for</span> conditionTrue() == <span class="literal">false</span> &#123;</span><br><span class="line">c.Wait() <span class="comment">// 等待通知，条件已经发生。这是一个阻塞通信，goroutine将被暂停。</span></span><br><span class="line">&#125;</span><br><span class="line">c.L.Unlock() <span class="comment">// 为这个条件Locker执行解锁操作。这是必要的，因为当执行Wait退出操作的时候，它会在Locker上调用Lock方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法效率更高。注意，调用Wait不只是阻塞，它挂起了当前的goroutine,允许其他goroutine在OS线程上运行。<br>当你调用Wait时，会发生一些其他事情：<strong>进入Wait后，在Cond变量的Locker上调用Unlock方法，在退出Wait时，在Cond变量的Locker上执行Lock方法。</strong><br>它实际上是方法的一个隐藏的副作用。看起来我们在等待条件发生的时候一直持有这个锁，但事实并非如此。当你浏览代码时，你需要留意这个模式。</p><p>让我们扩展这个例子，并显示等式的两边：等待信号的goroutine和发送信号的goroutine。<br>假设我们有一个固定长度为2的队列，还有10个我们想要推送到队列中的项目。<br>我们想要在有房间的情况下尽快排队，所以就希望在队列中有空间时能立即得到通知。<br>让我们尝试使用Cond来管理这种调度：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">queue := <span class="built_in">make</span>([]any, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">removeFromQueue := <span class="function"><span class="keyword">func</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">time.Sleep(delay)</span><br><span class="line">c.L.Lock()</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line">fmt.Println(<span class="string">&quot;Removed from queue&quot;</span>)</span><br><span class="line">c.L.Unlock()</span><br><span class="line">c.Signal()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) == <span class="number">2</span> &#123;</span><br><span class="line">c.Wait()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Adding to queue&quot;</span>)</span><br><span class="line">queue = <span class="built_in">append</span>(queue, <span class="keyword">struct</span>&#123;&#125;&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> removeFromQueue(<span class="number">1</span> * time.Second)</span><br><span class="line">c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Adding to queue</span><br><span class="line">Adding to queue</span><br><span class="line">Removed from queue</span><br><span class="line">Adding to queue</span><br><span class="line">Removed from queue</span><br><span class="line">Adding to queue</span><br><span class="line">Removed from queue</span><br><span class="line">Adding to queue</span><br><span class="line">Removed from queue</span><br><span class="line">Adding to queue</span><br><span class="line">Removed from queue</span><br><span class="line">Removed from queue</span><br><span class="line">Adding to queue</span><br><span class="line">Adding to queue</span><br><span class="line">Removed from queue</span><br><span class="line">Adding to queue</span><br><span class="line">Removed from queue</span><br><span class="line">Adding to queue</span><br></pre></td></tr></table></figure><p>该程序成功地将所有10个项目添加到队列中（并且在它有机会将前两项删除之前退出)。<br>它也总是等待，直到至少有一个项目被排入队列，然后再进行另一个项目。<br>在这个例子中，我们还有一个新方法，Signal。这是Cond类型提供的两种方法中的一种，<strong>它提供通知goroutine阻塞的调用Wait,条件已经被触发。</strong><br>另一种方法叫做Broadcast。运行时内部维护一个FIFO列表，等待接收信号；<strong>Signal发现等待最长时间的goroutine并通知它，而Broadcast向所有等待的goroutine发送信号。</strong><br>Broadcast可以说是这两种方法中比较有趣的一种，因为它提供了一种同时与多个goroutine通信的方法。<br>我们可以通过channel对信号进行简单的复制，但是重复调用Broadcast的行为将会更加困难。<br>此外，与利用channel相比，Cond类型的性能要高很多。</p><p>为了了解使用Broadcast的方法，让我们假设正在创建一个带有按钮的GUI应用程序。我们想注册任意数量的函数，当该按钮被单击时，它将运行。<br>Cond可以完美胜任，因为我们可以使用它的Broadcast方法通知所有注册的处理程序。让我们看看它的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义 Button 类型，包含 Clicked 条件</span></span><br><span class="line"><span class="keyword">type</span> Button <span class="keyword">struct</span> &#123;</span><br><span class="line">Clicked *sync.Cond</span><br><span class="line">&#125;</span><br><span class="line">button := Button&#123;Clicked: sync.NewCond(&amp;sync.Mutex&#123;&#125;)&#125;</span><br><span class="line"><span class="comment">// 定义订阅函数，提供注册函数以处理来自条件的信号的功能</span></span><br><span class="line">subscribe := <span class="function"><span class="keyword">func</span><span class="params">(c *sync.Cond, fn <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> goroutineRunning sync.WaitGroup</span><br><span class="line">goroutineRunning.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">goroutineRunning.Done()</span><br><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.L.Unlock()</span><br><span class="line">c.Wait()</span><br><span class="line">fn()</span><br><span class="line">&#125;()</span><br><span class="line">goroutineRunning.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> clickRegistered sync.WaitGroup</span><br><span class="line">clickRegistered.Add(<span class="number">3</span>)</span><br><span class="line">subscribe(button.Clicked, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Maximizing window.&quot;</span>)</span><br><span class="line">clickRegistered.Done()</span><br><span class="line">&#125;)</span><br><span class="line">subscribe(button.Clicked, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Displaying annoying dialog box!&quot;</span>)</span><br><span class="line">clickRegistered.Done()</span><br><span class="line">&#125;)</span><br><span class="line">subscribe(button.Clicked, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Mouse clicked.&quot;</span>)</span><br><span class="line">clickRegistered.Done()</span><br><span class="line">&#125;)</span><br><span class="line">button.Clicked.Broadcast()</span><br><span class="line">clickRegistered.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mouse clicked.</span><br><span class="line">Maximizing window.</span><br><span class="line">Displaying annoying dialog box!</span><br></pre></td></tr></table></figure><p>可以看到，在 Click Cond 上调用 Broadcast ，所有三个处理程序都将运行。<br>如果不是 clickRegistered 的 WaitGroup,我们可以调用button.Clicked.Broadcast()多次，并且.每次都调用三个处理程序。<br>这是channel不太容易做到的，因此是利用Cond类型的主要原因之一。</p><p>与sync包中所包含的大多数其他东西一样，Cond的使用最好被限制在一个紧凑的范围中，或者是通过封装它的类型来暴露在更大范围内。</p><h4 id="once"><a href="#once" class="headerlink" title="once"></a>once</h4><p>once 比较简单，顾名思义：只会被执行一次。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line">increment := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">count++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="keyword">var</span> increments sync.WaitGroup</span><br><span class="line">increments.Add(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> increments.Done()</span><br><span class="line">once.Do(increment)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">increments.Wait()</span><br><span class="line">fmt.Printf(<span class="string">&quot;Count is %d\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：<code>Count is 1</code></p><p>sync.Once是一种类型，它在内部使用一些sync原语，以确保即使在不同的goroutine上，也只会调用一次Do方法处理传递进来的函数。<br>这确实是因为我们将调用sync.Once方式执行Do方法。</p><p>使用sync.Once有几件事需要注意。让我们看另一个例子，你认为它会打印什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line">increment := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; count++ &#125;</span><br><span class="line">decrement := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; count-- &#125;</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line">once.Do(increment)</span><br><span class="line">once.Do(decrement)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Count: %d\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：<code>Count: 1</code></p><p><strong>sync.Once只计算调用Do方法的次数，而不是多少次唯一调用Do方法。</strong><br>这样，<strong>sync.Once的副本与所要调用的函数紧密耦合</strong>，我们再次看到如何在一个严格的范围内合理使用sync包中的类型以发挥最佳效果。<br>我建议你通过将sync.Once包装在一个小的语法块中来形式化这种耦合：要么是一个小函数，要么是将两者包装在一个结构体中。<br>这个例子你认为会发生什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> onceA, onceB sync.Once</span><br><span class="line"><span class="keyword">var</span> initB <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">initA := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; onceB.Do(initB) &#125;</span><br><span class="line">initB = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; onceA.Do(initA) &#125; <span class="comment">// 1</span></span><br><span class="line">onceA.Do(initA)                    <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1这个调用在2返回之前不能进行。<br>这个程序将会死锁，因为在1调用的Do直到2调用Do并退出后才会继续，这是死锁的典型例子。<br>对一些人来说，这可能有点违反直觉，因为它看起来好像我们使用的sync.Once是为了防止多重初始化，但sync.Once唯一能保证的是你的函数只被调用一次。<br>有时，这是通过死锁程序和暴露逻辑中的缺陷来完成的，在这个例子中是一个循环引用。</p><h4 id="池"><a href="#池" class="headerlink" title="池"></a>池</h4><p>池(Pool)是(Pool模式)(<a class="link"   href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F)%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%AE%9E%E7%8E%B0%E3%80%82" >https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F)的并发安全实现。<i class="fas fa-external-link-alt"></i></a><br>在较高的层次上，Pool模式是一种创建和提供可供使用的固定数量实例或 Pool实例的方法。<br>它通常用于约束创建昂贵的场景（如数据库连接），以便只创建固定数量的实例，但不确定数量的操作仍然可以请求访问这些场景。<br>对于Go语言的sync.Pool,这种数据类型可以被多个goroutine安全地使用。</p><p>Pool的主接口是它的Get方法。当调用时，Get将首先检查池中是否有可用的实例返回给调用者，如果没有，调用它的new方法来创建一个新实例。<br>当完成时，调用者调用Put方法把工作的实例归还到池中，以供其他进程使用。<br>这里有一个简单的例子来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">myPool := &amp;sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Creating new instance.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;&#125;</span><br><span class="line">myPool.Get()             <span class="comment">// 调用 Pool 的 get 方法，会执行 Pool 中定义的 New 函数，因为实例还没有实例化。 </span></span><br><span class="line">instance := myPool.Get() <span class="comment">// 同上</span></span><br><span class="line">myPool.Put(instance)     <span class="comment">// 将之前的实例放回池中，增加了池内可用数量。</span></span><br><span class="line">myPool.Get()             <span class="comment">// 再调用时，会重用之前的示例，不会调用 New 函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只看到两个对New函数的调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Creating new instance.</span><br><span class="line">Creating new instance.</span><br></pre></td></tr></table></figure><p>那么，为什么要使用 Pool,而不只是在运行时实例化对象呢？Go语言是有 GC 的，因此实例化的对象将被自动清理。<br>有什么意义？考虑下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> numCalcsCreated <span class="type">int</span></span><br><span class="line">calcPool := &amp;sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any &#123;</span><br><span class="line">numCalcsCreated += <span class="number">1</span></span><br><span class="line">mem := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">return</span> &amp;mem <span class="comment">// 存储bytes切片的地址</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用4KB初始化 pool</span></span><br><span class="line">calcPool.Put(calcPool.New())</span><br><span class="line">calcPool.Put(calcPool.New())</span><br><span class="line">calcPool.Put(calcPool.New())</span><br><span class="line">calcPool.Put(calcPool.New())</span><br><span class="line"><span class="keyword">const</span> numWorkers = <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(numWorkers)</span><br><span class="line"><span class="keyword">for</span> i := numWorkers; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">mem := calcPool.Get().(*[]<span class="type">byte</span>)</span><br><span class="line"><span class="keyword">defer</span> calcPool.Put(mem)</span><br><span class="line"><span class="comment">// 做一些有趣的假设，但是很快就会用这个内存完成</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d calculators were created.&quot;</span>, numCalcsCreated)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：<code>23 calculators were created.</code><br>如果我没有用sync.Pool运行这个例子，尽管结果是不确定的，在最坏的情况下，我可能尝试分配一个十亿字节的内存，但是正如你从输出看到的，我只分配了4KB。<br>另一种常见的情况是，用Pool来尽可能快地将预先分配的对象缓存加载启动。在这种情况下，我们不是试图通过限制创建的对象的数量来节省主机的内存，而是通过提前加载获取引用到另一个对象所需的时间，来节省消费者的时间。<br>这在编写高吞吐量网络服务器时十分常见，服务器试图快速响应请求。让我们来看看这样的场景。<br>首先，让我们创建一个模拟创建到服务的连接的函数。我们会让这次连接花很长时间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectToService</span><span class="params">()</span></span> any &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，让我们了解一下，如果服务为每个请求都启动一个新的连接，那么网络服务的性能如何。<br>我们将编写一个网络处理程序，为每个请求都打开一个新的连接。<br>为了使基准测试简单，我们只允许一次连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startNetworkDaemon</span><span class="params">()</span></span> *sync.WaitGroup &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">server, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;cannot listen:%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> server.Close()</span><br><span class="line">wg.Done()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := server.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;cannot accept connection:%v&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">connectToService()</span><br><span class="line">fmt.Fprintln(conn, <span class="string">&quot;&quot;</span>)</span><br><span class="line">conn.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> &amp;wg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectToService</span><span class="params">()</span></span> any &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们的基准如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">daemonStarted := startNetworkDaemon()</span><br><span class="line">daemonStarted.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkNetworkRequest</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">b.Fatalf(<span class="string">&quot;cannot dial host:%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, err := ioutil.ReadAll(conn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">b.Fatalf(<span class="string">&quot;cannot read:%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkNetworkRequest</span><br><span class="line">BenchmarkNetworkRequest-20          101010578820 ns/op</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>看看 sync.Pool 改进的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">warmServiceConnCache</span><span class="params">()</span></span> *sync.Pool &#123;</span><br><span class="line">p := &amp;sync.Pool&#123;</span><br><span class="line">New: connectToService,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">p.Put(p.New())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startNetworkDaemon</span><span class="params">()</span></span> *sync.WaitGroup &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">connPool := warmServiceConnCache()</span><br><span class="line">server, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;cannot listen:%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> server.Close()</span><br><span class="line">wg.Done()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := server.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;cannot accept connection:%v&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">svcConn := connPool.Get()</span><br><span class="line">fmt.Fprintln(conn, <span class="string">&quot;&quot;</span>)</span><br><span class="line">connPool.Put(svcConn)</span><br><span class="line">conn.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> &amp;wg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectToService</span><span class="params">()</span></span> any &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkNetworkRequest</span><br><span class="line">BenchmarkNetworkRequest-20        3800   4567334 ns/op</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>快了三个数量级，在处理代价昂贵的事务时使用这种模式可以极大的提高响应时间。</p><p>当你的并发进程需要请求一个对象，但是在实例化之后很快地处理它们时，或者在这些对象的构造可能会对内存产生负面影响，这时最好使用Pool设计模式。<br>然而，有些情况下要谨慎决定你是否应该使用Pool:如果你使用Pool代码所需要的东西不是大概同质的，那么从Pool中转化检索到所需要的内容的时间可能比重新实例化内容要花费的时间更多。<br>例如，如果你的程序需要随机和可变长度的切片，那么Pool将不会对你有多大帮助。你直接从Pool中获得一个正确的切片的概率是很低的。</p><p>所以当你使用Pool工作时，记住以下几点：</p><ul><li>当实例化sync.Pool,使用new方法创建一个成员变量，在调用时是线程安全的。</li><li>当你收到一个来自 Get 的实例时，不要对所接收的对象的状态做出任何假设。</li><li>当你用完了一个从Pool中取出来的对象时，一定要调用Put,否则，Pool就无法复用这个实例了。通常情况下，这是用defer完成的。</li><li>Pool内的分布必须大致均匀。</li></ul><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>channel是由Hoare的CSP派生的同步原语之一。<br>虽然它们可以用来同步内存访问，但它们最好用于在goroutine之间传递信息。<br>正如我们在第2章“Go语言的并发哲学”中所讨论的，在任何大小的程序中，channel都非常有用，因为它们可以组合在一起。</p><p>就像河流一样，一个channel充当着信息传送的管道，值可以沿着channel传递，然后在下游读出。<br>当你使用channel时，你会将一个值传递给一个chan变量，然后你程序中的某个地方将它从channel中读出。<br>程序中不同的部分不需要相互了解，只需要在channel所在的内存中引用相同的位置即可。这可以通过对程序上下游的channel引用来完成。</p><p>创建一个channel非常简单。使用内置的make函数：<code>dataChan := make(chan any)</code> 这是一个双向的channel。<br>channel也可以声明为只支持单向的数据流，也就是说，可以定义一个channel只支持发送或接收信息：<code>dataChan := make(chan&lt;- any)</code> or <code>dataChan := make(&lt;-chan any)</code><br>通过 <code>&lt;-</code> 的方向来区分，还是非常直观的。</p><p>但我们通常不会看到单向channel实例化，但是会经常看到它们用作函数参数和返回类型。<br><strong>当需要时，Go语言会隐式地将双向channel转换为单向channel。</strong><br>这里有一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiveChan &lt;-<span class="keyword">chan</span> any</span><br><span class="line"><span class="keyword">var</span> sendChan <span class="keyword">chan</span>&lt;- any</span><br><span class="line">dataStream := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="comment">// 有效的语法：</span></span><br><span class="line">receiveChan = datastream</span><br><span class="line">sendChan = dataStream</span><br></pre></td></tr></table></figure><p>使用 channel 也是通过 <code>&lt;-</code> 操作符来完成。<br>将数据放到channel中：<code>dataChan &lt;- data</code><br>从channel中读取数据：<code>data := &lt;-dataChan</code></p><p>尝试向只读的channel写数据会报错：<code>invalid operation: cannot send to receive-only channel readOnlyCh (variable of type &lt;-chan int)</code><br>尝试从只写的channel读数据会报错：<code>invalid operation: cannot receive from send-only channel writeOnlyCh (variable of type chan&lt;- int)</code><br>这是Go语言的类型系统的一部分，它允许我们在处理并发原语时使用type-safety。</p><p><strong>Go语言中的channel是阻塞的。</strong><br>这意味着只有 channel 内的数据被消费后，新的数据才能写入，而任何试图从空channel 读取数据的goroutine将等待至少一条数据被写入channel后才能读到。</p><p>如果不正确地构造程序，这会导致死锁：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stringStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> != <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">stringStream &lt;- <span class="string">&quot;Hello channels!&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(&lt;-stringStream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过 <code>&lt;-</code> 操作符的接受形式也可以选择返回两个值：<code>data, ok := &lt;-dataChan</code></strong><br><strong>ok 是一个布尔值。当channel关闭时，ok为false，data为零值。当channel开启时，ok为true，data为channel中存储的值。如果没有数据，则会阻塞。</strong><br><strong>使用 <code>close(dataChan)</code> 关闭一个channel。</strong></p><p>这为我们提供了一些新的模式。<br>第一个是从channel中获取。通过range关键作为参数遍历（与for语句一起使用），并且<strong>在channel关闭时自动中断循环。</strong><br>这允许对channel上的值进行简洁的迭代。让我们看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">intstream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 我们确保在goroutine退出之前channel是关闭的。这是一个很常见的模式。</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(intstream)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">intstream &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 遍历了 intstream</span></span><br><span class="line"><span class="keyword">for</span> integer := <span class="keyword">range</span> intstream &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v &quot;</span>, integer)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<code>1 2 3 4 5 </code></p><p><strong>注意该循环不需要退出条件，并且 range 方法不返回第二个布尔值。处理一个已关闭的 channel 的细节可以让你保持循环简洁。</strong></p><p><strong>关闭 channel 也是一种同时给多个 goroutine 发信号的方法。</strong> 如果有 n 个 goroutine 在一个 channel 上等待，而不是在 channel 上写 n 次来打开每个 goroutine,你可以简单地关闭 channel。<br>由于一个被关闭的 channel 可以被无数次读取，所以不管有多少 goroutine 在等待它，关闭 channel 都比执行 n 次更适合，也更快。<br>这里有一个例子，可以同时打开多个 goroutine:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">begin := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">&lt;-begin <span class="comment">// goroutine会一直等待，直到它被告知可以继续。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v has begun\n&quot;</span>, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Unblocking goroutines...&quot;</span>)</span><br><span class="line"><span class="built_in">close</span>(begin) <span class="comment">// 关闭channel,从而同时打开所有的goroutine。</span></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到，在我们关闭开始channel之前，所有的goroutine都没有开始运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Unblocking goroutines...</span><br><span class="line">4 has begun</span><br><span class="line">2 has begun</span><br><span class="line">3 has begun</span><br><span class="line">o has begun</span><br><span class="line">1 has begun</span><br></pre></td></tr></table></figure><p>请记住在本章前面“sync包”中，我们讨论了使用sync.Cond类型执行相同的行为。你当然可以使用它，但是正如我们已经讨论过的，channel是可组合的。<br>我们还可以创建 buffered channel,它是在实例化时提供容量的 channel。<br>这意味着即使没有在 channel 上执行读取操作，goroutine 仍然可以执行 n 写入，其中 n 是缓冲 channel 的容量。<br><strong><code>dataChan := make(chan any, 4)</code>创建一个有4个容量的缓冲channel。</strong> 这意味着我们可以把4个东西放到 channel 上，不管它是否被读取。<br>这有点意思，因为它意味着 goroutine 可以控制实例化一个 channel 时否需要缓冲。这表明，创建一个 channel 应该与 goroutines 紧密耦合，而 goroutines 将会在它上面执行写操作，这样我们就可以更容易地推断它的行为和性能。</p><p>没有缓冲的 channel 也被定义为缓冲 channel,一个无缓冲channel只是一个以0的容量创建的缓冲channel。<br><strong><code>a := make(chan any)</code>和<code>b := make(chan any, 0)</code> 是等价的。</strong><br>请记住，当我们讨论阻塞时，如果说 channel 是满的，那么写入 channel 阻塞，如果 channel 是空的，则从 channels 读取的是什么？<br>“Full”和“empty”是容量或缓冲区大小的函数。无缓冲channel的容量为零，因此在任何写人之前channel已经满了。<br>一个没有下游接受的容量为4的缓冲channel在被写4次之后就满了，并且在写第5次的时候阻塞，因为它没有其他地方放置第五个元素。<br>与未缓冲的channel一样，缓冲channel仍然阻塞；channel为空或满的前提条件是不同的。<br>通过这种方式，缓冲channel是一个内存中的FIFO队列，用于并发进程进行通信。</p><p>为了帮助理解这一点，让我们用例子来解释一个具有4个容量的缓冲 channel 的情况。<br>首先，让我们来初始化： <code>c ：= make(chan rune, 4)</code><br>从逻辑上讲，这创建了一个带有四个槽的缓冲区。现在让我们往channel里写数据： <code>c &lt;- &#39;A&#39;</code><br>当这个channel没有下游读取时，一个数据将被放置在channel缓冲区的第一个槽中。<br>然后 <code>c &lt;- &#39;B&#39;</code>、<code>c &lt;- &#39;C&#39;</code>、<code>c &lt;- &#39;D&#39;</code>，经过4次写入后，缓冲区已满。<br>再试图写入 <code>c &lt;- &#39;E&#39;</code>，执行这个写入操作的 goroutine 将被阻塞，直到有读取操作。<br>下游读取时会依次接受位于缓冲区中的数据，直到缓冲区为空。</p><p>如果一个缓冲 channel 是空的，并且有一个下游接收，那么缓冲区将被忽略，并且该值将直接从发送方传递到接收方。<br>在实践中这是透明的，但是对了解缓冲channel的配置是值得的。缓冲 channel 在某些情况下是有用的，但是应该小心地创建它们。<br><strong>缓冲channel很容易成为一个不成熟的优化，并且使隐藏的死锁更不容易发生。这听起来像是一件好事，但我猜你宁愿在第一次写代码的时候发现死锁，而不是在生产系统崩遗的时候才发现。</strong></p><p>程序如何与值为 nil 的 channel 交互？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataStream <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">&lt;-dataStream</span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">dataStream &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure><p>会报错：<code>fatal error: all goroutines are asleep - deadlock!</code><br>尝试<code>close(dataStream)</code>也会报错：<code>panic: close of nil channel</code></p><hr><p>channel 操作的结果给出了 channel 的状态：</p><table><thead><tr><th>操作</th><th>Channel 状态</th><th>结果</th></tr></thead><tbody><tr><td>Read</td><td>nil</td><td>阻塞</td></tr><tr><td>Read</td><td>打开且非空</td><td>输出值</td></tr><tr><td>Read</td><td>打开且空</td><td>阻塞</td></tr><tr><td>Read</td><td>关闭</td><td>&lt;默认值&gt;,false</td></tr><tr><td>Read</td><td>只写</td><td>编译错误</td></tr><tr><td>Write</td><td>nil</td><td>阻塞</td></tr><tr><td>Write</td><td>打开但填满</td><td>阻塞</td></tr><tr><td>Write</td><td>打开且不满</td><td>写入值</td></tr><tr><td>Write</td><td>关闭</td><td>panic</td></tr><tr><td>Write</td><td>只读</td><td>编译错误</td></tr><tr><td>Close</td><td>nil</td><td>panic</td></tr><tr><td>Close</td><td>打开且非空</td><td>关闭Channel，读取成功，直到缓存被读完，然后读取生产者的默认值</td></tr><tr><td>Close</td><td>打开且空</td><td>关闭Channel，读取生产者的默认值</td></tr><tr><td>Close</td><td>关闭</td><td>panic</td></tr><tr><td>Close</td><td>只读</td><td>编译错误</td></tr></tbody></table><p>channel是吸引人们使用Go语言的原因之一。<br>结合了goroutine和闭包的简单性，我很清楚地知道编写干净、正确的并发代码是多么容易。<br>在很多方面，channel是将goroutine黏合在一起的黏合剂。<br>本章应该给了你一个关于什么是channel以及如何使用它们的很好的概述。<br>真正的乐趣始于我们开始编写channel以形成高阶并发设计模式。我们会在下一章讲到。</p><p>期待。</p><h3 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h3><p>select语句是将channel绑定在一起的黏合剂，这就是我们如何在一个程序中组合channel以形成更大的抽象事务的方式。<br>声明select语句是一个具有并发性的Go语言程序中最重要的事情之一，这并不是夸大共词。<br>在一个系统中两个或多个组件的交集中，可以在本地、单个函数或类型以及全局范围内找到select语句绑定在一起的channel。<br>除了连接组件之外，在程序中的这些关键节点上，select语句可以帮助安全地将channel与诸如取消、超时、等待和默认值之类的概念结合在一起。</p><p>那么这些强大的select语句是什么呢？我们如何使用它们，它们是如何工作的？<br>让我们先把它放出来。这里有一个很简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c1, c2 &lt;-<span class="keyword">chan</span> any</span><br><span class="line"><span class="keyword">var</span> c3 <span class="keyword">chan</span>&lt;- any</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c1:</span><br><span class="line"><span class="comment">//执行某些逻辑</span></span><br><span class="line"><span class="keyword">case</span> &lt;-c2:</span><br><span class="line"><span class="comment">//执行某些逻辑</span></span><br><span class="line"><span class="keyword">case</span> c3 &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line"><span class="comment">// 执行某些逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它看起来有点像一个选择模块，一个select模块包含一系列的case语句，这些语句可以保护一系列语句。<br>然而，这就是相似之处。<strong>与switch块不同，select块中的case语句没有测试顺序，如果没有满足任何条件，执行也不会失败。</strong></p><p>相反，所有的channel读取和写入都需要查看是否有任何一个已准备就绪可以用的数据：在读取的情况下关闭channel,以及写入不具备下游消费能力的channel。<br>如果所有channel都没有谁备好，则执行整个select语句模块。当一个channel准备好了，这个操作就会继续，它相应的语句就会执行。<br>让我们来看一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 等待5s后关闭channel</span></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">&quot;Blocking on read...&quot;</span>)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c:</span><br><span class="line"><span class="comment">// 尝试在channel上读取数据</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Unblocked %v later.\n&quot;</span>, time.Since(start))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blocking on read...</span><br><span class="line">Unblocked 5.0109829s later.</span><br></pre></td></tr></table></figure><p>在进人select模块后大约5秒，我们就会解锁。这是一种简单而有效的方法来阻止我们等待某事的发生，但如果我们思考一下，我们可以提出一些问题：</p><ul><li>当多个channel有数据可供给下游读取的时候会发生什么？</li><li>如果没有任何可用的channel怎么办？</li><li>如果我们想要做一些事情，但是没有可用的channels怎么办？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="built_in">close</span>(c1)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> any)</span><br><span class="line"><span class="built_in">close</span>(c2)</span><br><span class="line"><span class="keyword">var</span> c1Count, c2Count <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1000</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c1:</span><br><span class="line">c1Count++</span><br><span class="line"><span class="keyword">case</span> &lt;-c2:</span><br><span class="line">c2Count++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;c1Count:%d\nc2Count:%d\n&quot;</span>, c1Count, c2Count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1Count:485</span><br><span class="line">c2Count:515</span><br></pre></td></tr></table></figure><p>在一千次迭代中，大约有一半的时间从c1读取se1ect语句，大约一半的时间从c2读取。这看起来很有趣，也许有点太巧了。事实如此！<br><strong>Go 语言运行时将在一组case语句中执行伪随机选择。这就意味着，在你的case语句集合中，每一个都有一个被执行的机会。</strong><br>乍一看，这似乎并不重要，但背后的原因却非常有趣。<br>让我们先做一个很明显的阐述：Go语言运行时无法解析select语句的意图，也就是说，它不能推断出问题空间，或者说为什么将一组channel组合到一个select语句中。正因为如此，运行时所能做的最好的事情就是在平均情况下运行良好。<br>一种很好的方法是将一个随机变量引入到等式中（在这种情况下，se1ect后续的channel)。通过加权平均每个channel被使用的机会，所有使用select语句的程序将在平均情况下表现良好。</p><p>关于第二个问题：如果没有任何channel可用，会发生什么？如果所有的channel都被阻塞了，如果没有可用的，但是你可能不希望永远阻塞，可能需要超时机制。<br>Go语言的time包提供了一种优雅的方式，可以在select语句中很好地使用channel。<br>这里有一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c &lt;-<span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c:</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">fmt.Println(<span class="string">&quot;Timed out.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个case语句永远不会被解锁，因为我们是从 nil channel 读取的。<br>输出如下：<code>Timed out.</code><br>time.After 函数通过传入 time.Duration 参数返回一个数值并写入 channel,该channel会返回执行后的时间。这为select语句提供了一种简明的方法。</p><p>最后一个问题：当没有可用channel时，我们需要做些什么？<br>像case语句一样，select语句也允许默认的语句。就像“case”语句一样，当“select’”语句中的所有channel都被阻塞的时候，“select”语句也允许你调用默认语句。<br>以下是一个实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">var</span> c1, c2 &lt;-<span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c1:</span><br><span class="line"><span class="keyword">case</span> &lt;-c2:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;In default after %v\n&quot;</span>, time.Since(start))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：<code>In default after 0s</code><br>可以看到，它几乎是瞬间运行了默认语句。这允许在不阻塞的情况下退出 select 模块。<br>通常，你将看到一个默认的子句，它与 for-select 循环一起使用。<br>这允许goroutine在等待另一个goroutine上报结果的同时，可以继续执行自己的操作。<br>这里有一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line">&#125;()</span><br><span class="line">workCounter := <span class="number">0</span></span><br><span class="line">loop:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">break</span> loop</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟工作行为</span></span><br><span class="line">workCounter++</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Achieved %v cycles of work before signalled to stop.\n&quot;</span>, workCounter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：<code>Achieved 5 cycles of work before signalled to stop.</code></p><p>在这种情况下，我们有一个循环，它在执行某种操作，偶尔检查它是否应该被停止。<br>最后，对于空的select语句有一个特殊的情况：选择没有case子句的语句。<br>看起来像这样： <code>select &#123;&#125;</code> 这个语句将永远阻塞。<br>在第6章中，我们将深入研究select语句是如何工作的。从更高层次的角度来看，它应该是显而易见的，它可以帮助你安全高效地组合各种概念和子系统。</p><h3 id="GOMAXPROCS-控制"><a href="#GOMAXPROCS-控制" class="headerlink" title="GOMAXPROCS 控制"></a>GOMAXPROCS 控制</h3><p>在runtime包中，有一个函数称为GoMAXPR0CS。<br>这个名称是有误导性的：人们通常认为这个函数与主机上的逻辑处理器的数量有关（而且与它调度方式有关)，但实际上这个函数控制的OS线程的数量将承载所谓的“工作队列”。<br>有关这个函数的更多信息以及它的工作原理，请参见第6章。<br>在Go语言1.5之前，GoMAXPR0CS总是被设置为1，通常你会在大多数Go语言程序中找到这段代码：<code>runtime.GOMAXPROCS(runtime.NumCPU())</code><br>几乎大部分开发人员希望当他们的程序正在运行时，可以充分利用机器上的所有CPU核心。<del>（我还真干过）</del><br>因此，在随后的Go语言版本中，它自动设置为主机上逻辑CPU的数量。</p><p>那么为什么要调整这个值呢？大部分时间你都不太想去调节它。<br><strong>Go语言的调度算法在大多数情况下已经足够好了，在增加或减少工作队列和线程数量的情况下，可能会造成更多的问题，但是仍然有一些情况会改变这个值。</strong><br>例如，我在一个项目上调试，这个项目有一个测试组件，它被竞争环境困扰。<br>不管怎么说，这个团队有几个包，有时候测试失败。我们运行测试的主机有四个逻辑CPU,因此在任何一个点上，我们都有四个goroutines同时执行。<br>通过增加GoMAXPROCS以超过我们拥有的逻辑CPU数量，我们能够更频繁地触发竞争条件，从而更快地修复它们。</p><p>其他人可能通过实验发现，他们的程序在一定数量的工作队列和线程上运行得更好，但我更主张谨慎些。<br>如果你通过调整这个方法来压缩性能，那么在每次提交之后，当你使用不同的硬件，以及使用不同版本的Go语言时，一定要这样做。<br>调整这个值会使你的程序更接近它所运行的硬件，但以抽象和长期性能稳定为代价。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第三章-Go语言并发组件&quot;&gt;&lt;a href=&quot;#第三章-Go语言并发组件&quot; class=&quot;headerlink&quot; title=&quot;第三章 - Go语言并发组件&quot;&gt;&lt;/a&gt;第三章 - Go语言并发组件&lt;/h2&gt;&lt;p&gt;这章介绍Go中的特性，以及它如何支持并发。（终于到实</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://cooooing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="《go语言并发之道》" scheme="https://cooooing.github.io/tags/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B/"/>
    
    <category term="go" scheme="https://cooooing.github.io/tags/go/"/>
    
    <category term="并发" scheme="https://cooooing.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>《go语言并发之道》读书笔记-关于并发</title>
    <link href="https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91/"/>
    <id>https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91/</id>
    <published>2025-01-02T09:52:21.000Z</published>
    <updated>2025-01-02T09:52:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又开新书了，按照原来的计划，其实这次应该读的是 Kafka 相关的。<br>但奈何计划赶不上变化。</p><p>前几天给鱼排论坛写了聊天室的消息分发节点 <a class="link"   href="https://github.com/FishPiOffical/rhyus-golang" >rhyus-golang<i class="fas fa-external-link-alt"></i></a>，纯纯的多线程需要考虑并发的应用（虽然并发不高）。<br>所以变成了并发相关的书。</p><p>这篇计划阅读前两章，是关于并发概念的。</p><h2 id="第一章-并发概述"><a href="#第一章-并发概述" class="headerlink" title="第一章 - 并发概述"></a>第一章 - 并发概述</h2><p>书中前面关于摩尔定律、Web Scale和云计算相关的话题就跳过了。</p><h3 id="为什么并发很难？"><a href="#为什么并发很难？" class="headerlink" title="为什么并发很难？"></a>为什么并发很难？</h3><p>众所周知，并发代码是很难正确构建的。它通常需要完成几个迭代才能让它按预期的方式工作，即使这样，在某些时间点（更高的磁盘利用率、更多的用户登录到系统等)到达之前，bug在代码中存在数年的事情也不少见，以至于以前未被发现的bug在后面显露出来。<br>这段话我是有点体会的，上面的节点程序我迭代了很多次，很多问题都得在高并发或者高负载时才会出现。</p><h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><p><strong>当两个或多个操作必须按正确的顺序执行，而程序并未保证这个顺序，就会发生竞争条件。</strong><br>大多数情况下，这将在所谓的数据中出现，其中一个并发操作尝试读取一个变量，而在某个不确定的时间，另一个并发操作试图写入同一个变量。</p><p>下面是一个基本示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data <span class="type">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">data++</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">if</span> data == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;the value is %v.\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里，第8行和第11行都试图访问变量data,但并不能保证以什么顺序进行访问。<br>运行这段代码有三种可能的结果：</p><ol><li>不打印任何东西。在这种情况下，第8行在第10行之前执行。</li><li>打印“the value is 0.”。在这种情况下，第10行和第11行在第8行之前执行。</li><li>打印“the value is 1.”。在这种情况下，第8行在第10行之前执行，但第8行在第11行之前执行。</li></ol><p><strong>如你所见，虽然只有几行不正确的代码，但在你的程序中引入了巨大的不确定性。</strong><br>在并发代码中定位问题是非常困难的，需要考虑到各种可能出现的情况。</p><p><strong>有时候想象在两个操作之间会经过很长一段时间很有帮助。</strong><br>假设调用goroutine的时间和它运行的时间相差1h。那程序的其余部分将如何运行呢？<br>如果在goroutine执行成功和程序执行到if语句之间也花费了一小时，又会发生什么呢？<br>以这种方式思考对我很有帮助，因为对于计算机来说，规模可能不同，但相对的时间差异或多或少是相同的。</p><p>所以有时候，会出现下面的代码（在程序中大量使用休眠语句）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data <span class="type">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">data++</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 这种方式非常不优雅</span></span><br><span class="line"><span class="keyword">if</span> data == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;the value is %v.\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们的数据竞争问题解决了吗？并没有。事实上，在这个程序中之前的三个结果仍然有可能出现，只是可能性更小了。<br>我们在调用 goroutine 和检查数据值之间的休眠的时间越长，我们的程序就越接近正确，但那只是概率上接近逻辑的正确性：它永远不会真的变成逻辑上的正确。</p><p>除此之外，<strong>这让我们的算法变得低效</strong>。我们现在不得不休眠1s,来降低我们的程序出现数据竞争的可能。<br>所以，我们应该始终以逻辑正确性为目标。在代码中引人休眠可以方便地调试并发程序，但这并不能称之为一个解决方案。</p><blockquote><p>竞争条件是最难以发现的并发bug类型之一，因为它们可能在代码投人生产多年之后才出现。<br>通常代码正在执行时环境产生变化，或发生了某些罕见的事情，都有可能使其浮现出来。<br>往往代码只是看上去在用正确的方式来执行，但是事实上只是执行的顺序是正确的这件事本身的概率比较大而已，最终早晚有可能会出现一些意想之外的结果。</p></blockquote><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p><strong>当某些东西被队为是原子的，或者具有原子性的时候，这意味着在它运行的环境中，它是不可分割的或不可中断的。</strong></p><p>那么这到底意味着什么，为什么在使用并发代码时知道这一点很重要？<br>第一件非常重要的事情是“上下文(context)”这个词。<br>可能在某个上下文中有些东西是原子性的，而在另一个上下文中却不是。<br>在你的进程上下文中进行原子操作在操作系统的上下文中可能就不是原子操作；<br>在操作系统环境中原子操作在机器环境中可能就不是原子的，在你的机器上下文中原子操作在你的应用程序的上下文中可能不是原子的。<br>换句话说，操作的原子性可以根据当前定义的范围而改变。这种特性对你来说有利有弊！</p><p><strong>在考虑原子性时，经常第一件需要做的事就是定义上下文或范围，然后再考虑这些操作是否是原子性的。一切都应当遵循这个原则。</strong></p><p>术语“不可分割”(indivisible)和“不可中断”(uninterruptible)。<br>这些术语意味着在你所定义的上下文中，原子的东西将被完整的运行，而在这种情况下不会同时发生任何事情。<br>这仍然是一个整体，所以我们来看一个例子：<br><code>i++</code><br>这是一个任何人都可以设计的简单例子，但它很容易证明原子性的概念。它<br>可能看起来很原子，但是简要地分析一下就会发现其中有以下步骤：</p><ol><li>检索i的值。</li><li>增加i的值。</li><li>存储i的值。</li></ol><p>尽管这些操作中的每一个都是原子的，但三者的结合就可能不是，这取决于你的上下文。<br>这揭示了原子操作的一个有趣的性质：将它们结合并不一定会产生更大的原子操作。<br>使一个操作变为原子操作取决于你想让它在哪个上下文中。<br>如果你的上下文是一个没有并发进程的程序，那么该代码在该上下文中就是原子的。<br>如果你的上下文是一个goroutine,它不会将i暴露给其他 goroutine ,那么这个代码就是原子的。</p><p>为什么我们要关心这些呢？原子性非常重要，<strong>因为如果某个东西是原子的，隐含的意思是它在并发环境中是安全的。</strong>这使我们能够编写逻辑上正确的程序，并且这甚至可以作为优化并发程序的一种方式。<br>但大多数语句不是原子的，更不用说函数、方法和程序了。后面会通过各种方法来调和这个矛盾。</p><h3 id="内存访问同步"><a href="#内存访问同步" class="headerlink" title="内存访问同步"></a>内存访问同步</h3><p>假设有这样一个数据竞争：两个并发进程试图访问相同的内存区域，它们访问内存的方式不是原子的。<br>将之前的数据竞争的例子稍作修改就可以说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data <span class="type">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; data++ &#125;()</span><br><span class="line"><span class="keyword">if</span> data == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;the value is 0.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;the value is %v.\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里添加了一个e1se子句，所以不管数据的值如何，我们总会得到一些输出。请记住，正如之前所介绍，如果有一个数据竞争存在，那么该程序的输出将是完全不确定的。<br>实际上，<strong>程序中需要独占访问共享资源的部分有一个专有名词，叫临界区(critical section)。</strong><br>在这个例子中，我们有三个临界区：</p><ul><li>我们的 goroutine 正在增加数据变量。</li><li>我们的 if 语句，它检查数据的值是否为0。</li><li>我们的 fmt.Printf 语句，在检索并输出数据的值。</li></ul><p>有很多方法可以保护你的程序的临界区，go语言在设计时有一些更好的想法来解决这个问题，不过解决这个问题的其中一个办法是在你的临界区之间内存访问做同步。（加锁）<br>下面的代码不是Go语言中惯用的方法（我不建议像这样解决你的数据竞争问题)，但它很简单地演示了内存访问同步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> memoryAccess sync.Mutex</span><br><span class="line"><span class="keyword">var</span> value <span class="type">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">memoryAccess.Lock()</span><br><span class="line">value++</span><br><span class="line">memoryAccess.Unlock()</span><br><span class="line">&#125;()</span><br><span class="line">memoryAccess.Lock()</span><br><span class="line"><span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;the value is %v.\n&quot;</span>, value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;the value is %v.\n&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">memoryAccess.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里添加一个变量 memoryAccess，它将允许我们的代码对内存数据的访问做同步。（锁，后续介绍）<br>这样虽然解决了数据竞争，但是并没有解决竞争条件。即这个程序的操作顺序仍然是不确定的，只是缩小了非确定性的范围。</p><p>从表面上看，这似乎很简单：如果你发现你的代码中有临界区，那就添加锁来同步内存访问！<br>虽然通过内存访问同步来解决一些问题，但正如我们刚刚看到的，它不会自动解决数据竞争或逻辑正确性问题。此外，它也可能造成维护和性能问题。</p><p>还有个问题就是 Lock 的调用会使我们的程序变慢。每次执行这些操作时，我们的程序就会暂停一段时间。<br>这会带来两个问题：</p><ol><li>临界区是否是频繁进入和退出？（锁竞争）</li><li>临界区应该有多大？（锁的粒度）</li></ol><p>在程序的上下文中解决这两个问题是一种艺术，并且增加了内存访问同步的难度。</p><h3 id="死锁、活锁和饥饿"><a href="#死锁、活锁和饥饿" class="headerlink" title="死锁、活锁和饥饿"></a>死锁、活锁和饥饿</h3><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁程序是所有的并发进程彼此等待的程序。在这种情况下，如果没有外界的干预，这个程序将永远无法恢复。</p><p>这听起来很严峻，那是因为的确如此！Go语言的运行时会尽其所能，检测一些死锁（所有的goroutine必须被阻塞，或者“<a class="link"   href="https://github.com/golang/go/issues/13759" >asleep<i class="fas fa-external-link-alt"></i></a>”），但是这对于防止死锁并没有太多的帮助。</p><p>下面是一个死锁的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> value <span class="keyword">struct</span> &#123;</span><br><span class="line">mu    sync.Mutex</span><br><span class="line">value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">printSum := <span class="function"><span class="keyword">func</span><span class="params">(v1, v2 *value)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">v1.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> v1.mu.Unlock()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">v2.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> v2.mu.Unlock()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;sum = %v\n&quot;</span>, v1.value+v2.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b value</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> printSum(&amp;a, &amp;b)</span><br><span class="line"><span class="keyword">go</span> printSum(&amp;b, &amp;a)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行会报错 <code>fatal error: all goroutines are asleep - deadlock!</code></p><p>事实证明，出现死锁有儿个必要条件。I971年，Edgar Coffman 在一篇论文中列举了这些条件。这些条件现在被称为 Coffman 条件，是帮助检测、防止和纠正死锁的技术依据。<br>Coffman 条件如下：</p><ol><li>互斥条件 - 并发进程同时拥有资源的独占权。</li><li>占有并等待条件 - 并发进程必须同时拥有一个资源，并等待额外的资源。</li><li>非抢占条件 - 并发进程拥有的资源只能被该进程释放，即可满足这个条件。</li><li>循环等待条件 - 一个并发进程(P1)必须等待一系列其他并发进程(P2),这些并发进程同时也在等待进程(P1),这样便满足了这个最终条件。</li></ol><p>这些规则也帮助我们防止死锁。如果确保至少有一个条件不成立，我们可以防止发生死锁。不幸的是，实际上这些条件很难推理，因此很难预防。</p><h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>活锁是正在主动执行并发操作的程序，但是这些操作无法向前推进程序的状态。</p><p>你曾经在走廊走向另一个人吗？她移动到一边让你通过，但你也做了同样的事情。所以你转到另一边，但她也是这样做的。想象一下这个情形永远持续下去，你就明白了活锁。<br><del>这个倒是经常发生</del></p><p>下面是一个活锁的例子，就是上面所说的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> value <span class="keyword">struct</span> &#123;</span><br><span class="line">mu    sync.Mutex</span><br><span class="line">value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cadence := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> time.Tick(<span class="number">1</span> * time.Millisecond) &#123;</span><br><span class="line">cadence.Broadcast()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">takeStep := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">cadence.L.Lock()</span><br><span class="line">cadence.Wait()</span><br><span class="line">cadence.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">tryDir := <span class="function"><span class="keyword">func</span><span class="params">(dirName <span class="type">string</span>, dir *<span class="type">int32</span>, out *bytes.Buffer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">fmt.Fprintf(out, <span class="string">&quot; %v&quot;</span>, dirName)</span><br><span class="line">atomic.AddInt32(dir, <span class="number">1</span>)</span><br><span class="line">takeStep()</span><br><span class="line"><span class="keyword">if</span> atomic.LoadInt32(dir) == <span class="number">1</span> &#123;</span><br><span class="line">fmt.Fprint(out, <span class="string">&quot;Success!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">takeStep()</span><br><span class="line">atomic.AddInt32(dir, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> left, right <span class="type">int32</span></span><br><span class="line">tryLeft := <span class="function"><span class="keyword">func</span><span class="params">(out *bytes.Buffer)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> tryDir(<span class="string">&quot;left&quot;</span>, &amp;left, out) &#125;</span><br><span class="line">tryRight := <span class="function"><span class="keyword">func</span><span class="params">(out *bytes.Buffer)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> tryDir(<span class="string">&quot;right&quot;</span>, &amp;right, out) &#125;</span><br><span class="line"></span><br><span class="line">walk := <span class="function"><span class="keyword">func</span><span class="params">(walking *sync.WaitGroup, name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> out bytes.Buffer</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(out.String()) &#125;()</span><br><span class="line"><span class="keyword">defer</span> walking.Done()</span><br><span class="line">fmt.Fprintf(&amp;out, <span class="string">&quot;%v is trying to scoot:&quot;</span>, name)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> tryLeft(&amp;out) || tryRight(&amp;out) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprintf(&amp;out, <span class="string">&quot;\n%v tosses her hands up in exasperation!&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> peopleInHallway sync.WaitGroup</span><br><span class="line">peopleInHallway.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> walk(&amp;peopleInHallway, <span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> walk(&amp;peopleInHallway, <span class="string">&quot;Barbara&quot;</span>)</span><br><span class="line">peopleInHallway.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Alice is trying to scoot: left right left right left right left right left right</span><br><span class="line">Alice tosses her hands up in exasperation!</span><br><span class="line">Barbara is trying to scoot: left right left right left right left right left right</span><br><span class="line">Barbara tosses her hands up in exasperation!</span><br></pre></td></tr></table></figure><p>你可以看到，Alice和Barbara在最终退出之前，会持续竞争。</p><ol><li>tryDir 函数允许一个人尝试向一个方向移动，并返回是否成功。dir 表示试图朝这个方向移动的人数。</li><li>首先，宣布尝试向这个方向移动，atomic 使 dir 原子操作加一。</li><li>takeStep 函数调用 cadence.Wait 来等待其他并发进程，用以同步每个协程的节奏。因为要演示活锁，每个人都必须以相同的速度或节奏移动。</li><li>当意识到不能向这个方向走时，便放弃。将 dir 减一。</li><li>walk 函数中，人为限制了尝试的次数，<strong>否则，它将会一直无意义执行下去。</strong></li><li>walk 中，会尝试向左走，如果失败，则尝试向右走。</li></ol><p>这个例子演示了使用活锁的一个十分常见的原因：两个或两个以上的并发进程试图在没有协调的情况下防止死锁。<br>这就好比，如果走廊里的人都同意，只有一个人会移动，那就不会有活锁；一个人会站着不动，另一个人会移到另一边，他们就会继续移动。<br>在我看来，活锁要比死锁更复杂，因为它看起来程序好像在工作。<br>如果一个活锁程序在你的机器上运行，那你可以通过查看CPU利用率来确定它是否在做处理某些逻辑，你可能会认为它确实是在工作。<br>根据活锁的不同，它甚至可能发出其他信号，让你认为它在工作。然而，你的程序将会一直上演“hallway-shuffle’”的循环游戏。</p><p>活锁是一组被称为“饥饿”的更大问题的子集。</p><h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>饥饿是在任何情况下，并发进程都无法获得执行工作所需的所有资源。</p><p>当我们讨论活锁时，每个goroutine的资源是一个共享锁。</p><p>活锁保证讨论与饥饿是无关的，因为在活锁中，所有并发进程都是相同的，并且没有完成工作。<br>更广泛地说，饥饿通常意味着有一个或多个贪婪的并发进程，它们不公平地阻止一个或多个并发进程，以尽可能有效地完成工作，或者阻止全部并发进程。</p><p>下面的例子有一个贪婪的 goroutine 和一个平和的 goroutine：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> sharedLock sync.Mutex</span><br><span class="line"><span class="keyword">const</span> runtime = <span class="number">1</span> * time.Second</span><br><span class="line"></span><br><span class="line">greedyWorker := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> begin := time.Now(); time.Since(begin) &lt;= runtime; &#123;</span><br><span class="line">sharedLock.Lock()</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Nanosecond)</span><br><span class="line">sharedLock.Unlock()</span><br><span class="line">count++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Greedy worker was able to execute %v work loops.\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br><span class="line">politeWorker := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> begin := time.Now(); time.Since(begin) &lt; runtime; &#123;</span><br><span class="line">sharedLock.Lock()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Nanosecond)</span><br><span class="line">sharedLock.Unlock()</span><br><span class="line">sharedLock.Lock()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Nanosecond)</span><br><span class="line">sharedLock.Unlock()</span><br><span class="line">sharedLock.Lock()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Nanosecond)</span><br><span class="line">sharedLock.Unlock()</span><br><span class="line">count++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Polite worker was able to execute %v work loops.\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> greedyWorker()</span><br><span class="line"><span class="keyword">go</span> politeWorker()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Greedy worker was able to execute 33 work loops.</span><br><span class="line">Polite worker was able to execute 12 work loops.</span><br></pre></td></tr></table></figure><p>贪婪的 worker 会贪婪地抢占共享锁，以完成整个工作循环，而平和的 worker 只会在必要时锁定。<br>两种 worker 都做到同样的工作（sleep 3 ns），但贪婪的 worker 工作量会比平和的 worker 多得多。</p><p>通过记录和采样确定进程工作速度是否符合预期，可以发现和解决饥饿。<br>所以，饥饿会导致你的程序表现不佳或不正确。前面的示例演示了低效场景，但是如果你有一个非常贪婪的并发进程，以至于完全阻止另一个并发进程完成工作，那么你就会遇到一个更大的问题。<br>我们还应该考虑到来自于外部过程的饥饿。请记住，饥饿也可以应用于CPU、内存、文件句柄、数据库连接：<strong>任何必须共享的资源都是饥饿的候选者</strong>。</p><h2 id="第二章-对你的代码建：通信顺序进程"><a href="#第二章-对你的代码建：通信顺序进程" class="headerlink" title="第二章 - 对你的代码建：通信顺序进程"></a>第二章 - 对你的代码建：通信顺序进程</h2><h3 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h3><blockquote><p>并发属于代码，并行属于一个运行中的程序。</p></blockquote><p>这个区别其实仔细体会一下，描述得很清楚。<br>比如，我写了一个两部分可以并行运行的程序，但我却在一个只有一个核心的机器上运行它。那么同一时刻只会有一个部分被执行，他不可能是并行的。但如果是多个核心的机器，那么两个部分就可以并行执行。<br>但这两台机器上我们都可以认为它是并发的，因为并发是一段时间内两个部分都被执行就认为是并发的。（当然，这句是我以前的观点。学习操作系统进程相关知识时的观点）</p><p>但这章中的观点是：并行是一个时间或者上下文的函数。<br>上一章中，上下文被定义为一个操作被认为是原子性的界限。这里，上下文定义为两个或以上的操作被认为是并行的界限。</p><p>比如，我们的上下文是一段5s的时长，执行了两个分别消耗1s的操作，我们应该认为这些操作是并行执行的。但如果我们的上下文是1s，应该认为这些操作是分别运行的。</p><p>对于我们来说，用不同的时间对上下文的概念进行重定义并不是一件好事，但是请记住上下文和时间并设有关系。<br>我们可以把上下文定义成我们程序所在运行的进程，一个操作系统的线程，或者是一台机器。<br>这很重要，因为你所定义的上下文是和并发性以及正确性密切相关。<br>就像原子操作可以按照你所定义的上下文来定义是否为原子性，并发操作也依据你所定义的上下文来确定正确性。一切都是相关的。</p><h3 id="什么是-CSP"><a href="#什么是-CSP" class="headerlink" title="什么是 CSP"></a>什么是 CSP</h3><p>CSP即“Communicating Sequential Processes’”(通信顺序进程)，既是个技术名词，也是介绍这种技术的论文的名字。<br>在1978年，Charles Antony Richard Hoare在Association for Computing Machinery(一般被称作ACM)中发表的论文。<br>在这篇论文里，Hoar认为输入与输出是两个被忽略的编程原语，尤其是在并发代码中。<br>在Hoare写作这篇论文的同时，关于如何架构程序的相关研究还在进行中，但是大部分的研究都是针对编写顺序代码的方法：goto语句的使用正在被讨论，面向对象范型正在成为编程的基石。并发操作并没有被给予过多的思考。<br>Hoare开始纠正这个现象，所以，关于CSP的这篇论文就横空出世了。<br>在1978年的论文中，CSP仅是一个完全用来展示通信顺序进程的能力的一个简单的编程语言。<br>事实上，他甚至在论文中写道：<code>因此，本文介绍的概念和符号应该...不被认为适合作为一种编程语言，无论是抽象的还是具体的编程。</code></p><p>而且正是因为CSP的原始论文以及从论文中进化而来的原语正是Go语言并发模型的主要灵感，而这正是我们接下来所要聚焦的。</p><p>用来支撑他关于输入与输出需要被按照语言的原语来考虑，Hoare的CSP编程语言包含用来建模输入与输出，或者说“在进程间正确通信”（这就是论文名字的由来)的原语。<br>为了在进程之间进行通信，Hoar心创造了输入与输出的命令：！代表发送输入到一个进程，？代表读取一个进程的输出。<br>每一个指令都需要指定具体是一个输出变量（从一个进程中读取一个变量的情况），还是一个目的地（将输入发送到一个进程的情况)。<br>有时，这两种方法会引用相同的东西，在这种情况下，这两个过程会被认为是相对应的。<br>换言之，一个进程的输出应该直接流向另一个进程的输入。</p><p>这种语言同时利用了一个所谓的守护命令，也就是Edgar Dijkstra在一篇之前在I974年所写的论文中介绍的，“Guarded commands,nondeterminacy and formal derivation of programs’”。<br>一个有守护的命令仅仅是一个带有左和右倾向的语句，由一来分割。左侧服务是有运行条件的，或者是守护右侧服务，如果左侧服务运行失败，或者在一个命令执行后，返回false或者退出，右侧服务永远不会被执行。<br>将这些与Hoare的I&#x2F;O命令组合起来，为Hoare的通信过程奠定了基础，从而实现了channel。</p><p>经验判断Hoare的建议是正确的，然而，有趣的是，在Go语言发布之前，很少有语言能够真正地为这些原语提供支持。<br><strong>大多数流行的语言都支持共享和内存访问同步到CSP的消息传递样式。</strong> 当然也有例外，但不幸的是，这些都局限于没有广泛采用的语言。<br>Go语言是最早将CSP的原则纳人共核心的语言之一，并将这种并发编程风格引入到大众中。它的成功也使得其他语言尝试添加这些原语。内存访问同步并不是天生就不好。<br>在Go语言中，甚至有时共享内存在某些情况下是合适的。但是，共享内存模型很难正确地使用，特别是在大型或复杂的程序中。<br>正是由于这个原因，并发被认为是Go语言的优势之一，它从一开始就建立在CSP的原则之上，因此很容易阅读、编写和推理。</p><h3 id="Go语言的并发哲学"><a href="#Go语言的并发哲学" class="headerlink" title="Go语言的并发哲学"></a>Go语言的并发哲学</h3><p>CSP一直都是Go语言设计的重要组成部分。然而，Go语言还支持通过内存访问同步和遵循该技术的原语来编写并发代码的传统方式。sync与其他包中的结构体与方法可以让你执行锁，创建资源池取代goroutine等。</p><p>能够在CSP原语和内存访问同步之间选择对于你来说很棒，因为它让你去编写解决问题的并发代码上有了更多选择，但这可能显得有些莫名其妙。<br>Go语言的初学者总是认为CSP样式编写并发代码是Go语言编写并发代码的唯一方式。<br>比如说，在sync包的文档中，有如下描述：</p><blockquote><p>sync包提供了基本的同步基元，如互斥锁。除了Once类型和WaitGroup类型，大部分都是适用低水平程序线程，高水平的同步使用channel通信更好一些。</p></blockquote><p>在Go语言的FAQ中，有如下陈述：</p><blockquote><p>为了尊重mutex,sync包实现了mutex,但是我们希望Go语言的编程风格将会鼓励人们尝试更高等级的技巧。尤其是考虑构建你的程序，以便一次只有一个goroutine负责某个特定的数据。<br>不要通过共享内存进行通信。相反，通过通信来共享内存。有数不清的关于Go语言核心图队的文章、讲座和访谈，相对于使用像sync.Mutex这样的原语，他们更加拥护CSP。</p></blockquote><p>因此，Go语言团队为什么选择公开内存访问同步原语会感到困惑是完全可以理解的。更令人因惑的是，你通常会在外面看到出现的同步原语。<br>见到人们抱怨过度使用channel,也会听到一些Go语言团队成员说使用它们是“OK”的。<br>Go语言的维基上有一个关于此的引用：</p><blockquote><p>Go语言的一个座右铭是，“<strong>使用通信来共享内存，而不是通过共享内存来通信。</strong>”<br>这就是说，Go语言确实在syc包中提供了传统的锁机制。大多数的锁问题都可以通过channel或者传统的锁两者之一来解决。<br>所以说，我该用哪个？<br>使用最好描述和最简单的那个方式。</p></blockquote><p>这是很好的建议，也是你在使用Go语言时经常看到的谁则，但它有点含糊。<br>我们如何理解什么更具表现力、更简单？我们应该使用什么标准？<br>幸运的是，我们可以使用一些标准来帮助我们做正确的事情。<br>正如我们将看到的那样，我们主要的区分方式来自于试图管理并发的地方：主观地想象一个狭窄的范围，或者在我们的系统外部。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91/%E5%86%B3%E7%AD%96%E6%A0%91.png"                        alt="决策树"                 ></p><p>让我们逐步来介绍这些决策：</p><p><strong>你想要转让数据的所有权么？</strong><br>如果你有一块产生计算结果并想共享这个结果给其他代码块的代码，你所实际做的事情是传递了数据的所有权。<br>如果你对内存所有制且不支持GC的语言很熟悉的话，对于这个概念你应该是很熟悉的：数据拥有所有者，并发程序安全就是保证同时只有一个并发上下文拥有数据的所有权。<br>channel通过将这个意图编写进channel类型本身来帮助我们表达这个意图。</p><p>这么做的一个很大的好处就是可以创建一个带缓存的channel来实现一个低成本的在内存中的队列来解耦你的生产者与消费者。<br>另一个好处就是通过使用channel确保你的并发代码可以和其他的并发代码进行组合。</p><p><strong>你是否试图在保护某个结构的内部状态？</strong><br>这时候内存访问同步原语的一个很好的选择，也是一个你不应该使用channel的很好的示例。<br>通过使用内存访问同步原语，可以为你的调用者隐藏关于重要代码块的实现细节。<br>这是一个线程安全类型的小例子，且不会给调用者带来复杂性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span></span><br><span class="line">mu    sync.Mutex</span><br><span class="line">value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Increment() &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">c.value++</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你能回想起关于原子性的细节，可以说我们在这里所做的就是定义了Counter类型的原子性范围。调用增量可被认为是原子的。<br>记住这里的关键词是“内部的”。如果你发现自己正在将锁暴露在一个类型之外，这时侯你应该注意了。试着将你的锁放在一个小的字典范围内。</p><p><strong>你是否试图协调多个逻辑片段？</strong><br>请记住，channel本质上比内存访问同步原语更具可组合性。<br>将锁分散在整个对象图中听起来像是一场噩梦，但是，将channel编写的随处可见是被鼓励以及期待的！<br>我可以组合channel,但是我不能轻易的组合锁或者有返回值的方法。</p><p>你会发现，因为Go语言的select语句，以及channel可以当作队列使用和被安全的随意传递。<br>所以，当在使用channel的时候，你可以更简单的控制你软件中出现的激增的复杂性。<br>如果你发现正在挣扎着理解你的并发代码是如何工作的，为什么会出现死锁以及竞争，而你正在只用原语，这是一个你应该切换到channel的好示例。</p><p><strong>这是一个对性能要求很高的临界区吗？</strong><br>这绝对不意味着“我想让我的程序拥有高性能，因此，我应该只是用mutex’”。<br>当然，如果你程序中的某部分，事实证明是一个主要的性能瓶颈，比程序的其他部分慢几个数量级，使用内存访问同步原语可能会帮助这个重要的部分在负载下执行。<br>这是因为channel使用内存访问同步来操作，因此它们只能更慢。<br>然而，在我们考虑这一点之前，性能至关重要的程序部分可能暗示着需要重新规划我们的程序。</p><p>希望这可以清楚地说明是否利用CSP风格的并发或内存访问同步。<br>还有其他一些模式和做法在使用操作系统线程作为并发抽象方式的语言中很有用。<br>在使用操作系统线程作为主要并发抽象的语言中还有其他的方式以及实践。<br>比如说，像是线程池之类的东西经常出现。因为这些抽象大多数都是为了利用操作系统线程的优点与缺点。<br>Go语言的并发性哲学可以这样总结：<strong>追求简洁，尽量使用channel,并且认为goroutine的使用是没有成本的。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;又开新书了，按照原来的计划，其实这次应该读的是 Kafka 相关的。&lt;br&gt;但奈何计划赶不上变化。&lt;/p&gt;
&lt;p&gt;前几天给鱼排论坛写了聊天室</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://cooooing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="《go语言并发之道》" scheme="https://cooooing.github.io/tags/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E3%80%8B/"/>
    
    <category term="go" scheme="https://cooooing.github.io/tags/go/"/>
    
    <category term="并发" scheme="https://cooooing.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2024年年终总结</title>
    <link href="https://cooooing.github.io/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/2024%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://cooooing.github.io/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/2024%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2024-12-22T06:29:54.000Z</published>
    <updated>2024-12-22T06:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>2024年过的平平淡淡，让我回忆一下，然后下面就是流水账时间…</p><h2 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h2><p>上半年都在实习公司度过，因为去年年底项目才上线，年初也比较忙，没有什么记录，基本就是上班。<br>不过因为忙，人手不够，所以也让我开始写Java了，不再是低代码平台和写写sql了。（不过，写CURD接口和写sql区别也不是特别大）</p><p>三月份配了台新电脑，花了四千三。内存也是上到了64G，不过很少跑满，跑一半的情况都比较少。不过基本不用担心内存不够的问题了，minecraft几百个mod的大型整合包我也能边开服务器边开客户端玩。<br>可惜的就是板U，买了Q1HY，工程测试的版本。便宜是真便宜，就是不稳定，频率高了会蓝屏。现在也基本默频在用，没有超频了。</p><p>到五月份，重要的事情就是毕设答辩了。<br>毕业设计这个东西的代码我从去年8月左右在实训的时候就开始写了。那时候很闲，处于慢慢写的状态，基本完成的差不多了。<br>也庆幸那时候就开始了，不然按实习那个工作强度，再加上毕设的代码和论文。会过得非常痛苦。<br>论文基本上第一遍就过了，后面按导师的意见改改格式，大体上的内容基本没有改动。<br>然后就是五月回学校答辩，答辩其实很水，感觉还是ppt和讲为主。最后展示系统的时候，三个老师看一个教师大概三十人，分开看。其实基本也就扫一眼，十秒左右。<br>总的来说，除了拿学位证之外，没有任何意义。（当然，也可以自己赋予意义。可惜的是，我赋予的意义最终也像大部分项目一样烂尾了。因为最初这个项目是为了给墨夏使用的。</p><p>五月另一个重要的事就是拍毕业照了。和不太熟悉的同班同学聊聊近况，和熟悉的朋友聊聊未来打算。<br>有人考上研，后面继续求学；有人考研失败，继续备考；有人和我一样找工作，问我怎么面试的；还有找到实习和我一样当牛马的。<br>大家都有各自的人生轨迹，也有计划，但无一例外地我觉得大家都很迷茫，只是短暂地享受着最后一个月的大学生活。<br>和室友不是一个专业，单独拍了一些照片（下面放个我在中间的宿舍合照吧）。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/2024%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/9-304%E5%AE%BF%E8%88%8D%E5%90%88%E7%85%A7.jpg"                        alt="9-403宿舍合照.jpg"                 ></p><p>最后说下舍友的情况吧，除了我他们都没有干计算机相关的工作。<br>左一，家境不错，回昆山找了个工作。steam全是游戏，三年前只狼就七周末乱杀…是个富哥。<br>左二，河南的小伙，在考公。第一次考就进了面，但面试被刷了，现在也依然在考公。很有梗，是个非常有趣的人。<br>右一，健身快三年了，合照可以看出来练得非常好。现在继续健身，并且在做电商主播（直播、模特、卖货应该）。把爱好当饭吃，很有个性的人。<br>还有一个不在的富哥，大二去澳大利亚留学了。<br>另外两个朋友也大概说下吧，他们在我隔壁宿舍，和我舍友是一个专业，转专业后和我是一个专业。非常巧的是，我们三个宿舍连在一起。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/2024%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/302-303-304.png"                        alt="302-303-304.png"                 ></p><p>左一，考研失败了。在学校附近找了份实习，同时继续备考。是周教授的关门大弟子，实验室唯一的本科生，三年来都没新生加入。搞人工智能高手。<br>右二，富哥，申请了美国的大学，现在也在美国待了很久了。是个心态上很摆的人，但事情做得很好。高考复读了一次，作文偏题吧。很牛逼的人。<br>左二，我们计算机院的章院长，现在被调到生物院了好像。</p><p>六月底，到毕业的时候了。又回了趟学校。<br>回去就两件事</p><ol><li>拿毕业证和学位证</li><li>和朋友们告别</li></ol><p>所有的一切都像走流程一样，没有太大的伤感氛围。<br>和舍友最后聚了一次，后面估计很难再在一起了。（不过他们三个前几天倒是聚了一次</p><h2 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h2><p>七月一号，我签了劳动合同，继续在这家公司干。还是牛马的生活。<br>不过项目暂时没那么忙了，就是年底会非常地忙。（大概是总部的业绩要求没有达到吧</p><p>七月底搬了次家，搬到现在住的地方。离公司更近了，但离地铁站更远了，为此买了辆山地车。（很烂的车，后悔了<br>搬家是因为原来租的房子涨价了，当初租房也十分地草率。去年的年终里有提<br>今年新租的房子是和同事整租的，他和他老婆原来住在她姐家，六楼的步梯房。因为他老婆怀孕不方便所以换房子。<br>那周末找了个中介和他跑了一下午，看了好几间。有一间是很有矛盾的，很合适的房子，但是才装修一年，他老婆觉得有甲醛所以否决掉了。<br>当时已经要放弃了，同时满足我们俩要求的房子实在是太少了。让中介找了最后一间，也就是这间基本满足了。<br>搬家是真累，我真要吐槽六楼的步梯房。（他俩东西还多</p><p>后面就正常上班，一直到十二月之前都不怎么忙。<br>这段时间看了两本书，《收获，不止Oracle》和《Redis设计与实现》。<br>还有两本本原来是在计划里的。一本是《收获，不止SQL优化》，看了大纲，和开发相关性不大，和DBA的相关性很大，所以就不准备读了。<br>另一本是《Apache Kafka实战》，因为太忙了，暂时也搁置了。这本后面有空还是会读的，在计划中。<br>期间也看了点《Haskell函数式编程入门（第2版）第1卷》，前面的概念太复杂了，而且语法也非常地抽象。可以说和现有的几乎所有编程语言都不一样。<br>最终也是只搭了环境，草草地跟着书写了一点就结束了。</p><p>后面打算自己写个项目，准备用p2p，整了很久也没整出来。研究 BitTorrent协议 和 内网穿透 研究了很久。后面应该会继续做吧<br>最后就是前几天，给鱼排的聊天室节点用go实现了一个版本。经过站长阿达的高强度测试，最终也是上了北京的节点暂时运行一周看看情况。<br>最开始五十多个客户端，阿达疯狂输管理员命令（管理员命令会广播两次，命令本身和系统回复）。会出现卡顿和明显地吞消息情况。<br>再到后来为每个消息都用协程发送，虽然改善了吞消息，但是并发一大就会崩。<br>最后改成为每个ws连接创建协程，终于是稳定了，250左右的连接测试时也非常流畅。（让阿达测上限，说上限是他的硬盘，250个连接电脑已经很卡了）<br>测试过程中，阿达一直说原本的实现就不会这样随便造。真是太欠了。那是netty牛逼，我要是能纯手搓出netty这样的，我做梦都能笑醒。（阿达骂人表情包.jpg）<br>还给我提了个限制流量的需求，真是难搞啊。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>是非常想换工作的一年，也是面试全部失败的一年，也是我第一次不想写java的一年。<br>想转go，不知前路如何。自己还是和前两年一样迷茫。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2024年过的平平淡淡，让我回忆一下，然后下面就是流水账时间…&lt;/p&gt;
&lt;h2 id=&quot;上半年&quot;&gt;&lt;a href=&quot;#上半年&quot; class=&quot;headerlink&quot; title=&quot;上半年&quot;&gt;&lt;/a&gt;上半年&lt;/h2&gt;&lt;p&gt;上半年都在实习公司度过，因为去年年底项目才上线，年初也</summary>
      
    
    
    
    <category term="记录生活" scheme="https://cooooing.github.io/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="年终总结" scheme="https://cooooing.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>云服日常被攻击（三）</title>
    <link href="https://cooooing.github.io/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E4%BA%91%E6%9C%8D%E6%97%A5%E5%B8%B8%E8%A2%AB%E6%94%BB%E5%87%BB%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://cooooing.github.io/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E4%BA%91%E6%9C%8D%E6%97%A5%E5%B8%B8%E8%A2%AB%E6%94%BB%E5%87%BB%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2024-11-28T01:55:13.000Z</published>
    <updated>2024-11-28T01:55:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>又又又被攻击了，这次是通过stp挂在公网的rdp。方便我远程访问家里云。</p><p>起初是看到了v站的一篇帖子：<a class="link"   href="https://v2ex.com/t/1092714" >求助，被入侵了，如何减小损失？<i class="fas fa-external-link-alt"></i></a><br>大致内容就是他通过ftp挂在公网的rdp被入侵了，常用的网站密码都泄露了。</p><p>然后我就想起来，这人的操作和我一样啊。赶紧上服务器看下日志：<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E4%BA%91%E6%9C%8D%E6%97%A5%E5%B8%B8%E8%A2%AB%E6%94%BB%E5%87%BB%EF%BC%88%E4%B8%89%EF%BC%89/%E6%97%A5%E5%BF%971.png"                        alt="日志1"                 ></p><p>看到日志这么大我就知道坏了，进去翻了一下，基本就是几个ip一直在连接：<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E4%BA%91%E6%9C%8D%E6%97%A5%E5%B8%B8%E8%A2%AB%E6%94%BB%E5%87%BB%EF%BC%88%E4%B8%89%EF%BC%89/%E6%97%A5%E5%BF%972.png"                        alt="日志2"                 ></p><p>再去翻一下家里云windows的日志：<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E4%BA%91%E6%9C%8D%E6%97%A5%E5%B8%B8%E8%A2%AB%E6%94%BB%E5%87%BB%EF%BC%88%E4%B8%89%EF%BC%89/%E6%97%A5%E5%BF%973.png"                        alt="日志3"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E4%BA%91%E6%9C%8D%E6%97%A5%E5%B8%B8%E8%A2%AB%E6%94%BB%E5%87%BB%EF%BC%88%E4%B8%89%EF%BC%89/%E6%97%A5%E5%BF%974.png"                        alt="日志4"                 ></p><p>基本就是用几个用户名在一直尝试，总共试了三万多次，我看日志的时候还在试是最难绷的。<br>把ftp服务听了之后，想想有什么办法防止这种情况。</p><p>windows的服务被暴露出来，首先肯定是从windows源头入手，看看有什么办法阻断。<br>看了windows的安全策略，默认多次登陆失败后账户会被锁定10分钟。<br>这个调不调整问题也不大，因为它似乎跑的是字典，连我的用户名都没试出来。（试出来的概率也不大<br>另外就是加ip黑名单，这个不现实。因为ftp服务，所有的请求都是从公网的服务器转发来的。</p><p>但是在服务器的层面加ip黑名单是可以的。<br>bash脚本我就不是很熟了，连夜和gpt一起写了个脚本，检测ftp的日志，把频繁访问的都加到防火墙的ip黑名单里。<br>最后配置个定时任务运行脚本。就完成了。</p><h2 id="bash-脚本"><a href="#bash-脚本" class="headerlink" title="bash 脚本"></a>bash 脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置参数</span></span><br><span class="line">LOG_FILE=<span class="string">&quot;/home/ubuntu/frp/frp_0.56.0_linux_amd64/frps.log&quot;</span>  <span class="comment"># 日志文件路径</span></span><br><span class="line">THRESHOLD=20                         <span class="comment"># 黑名单阈值</span></span><br><span class="line">BLACKLIST_FILE=<span class="string">&quot;/home/ubuntu/frp/blacklist.txt&quot;</span>  <span class="comment"># 黑名单文件路径</span></span><br><span class="line">CHAIN_NAME=<span class="string">&quot;FTP-BLACKLIST&quot;</span>        <span class="comment"># 自定义防火墙链名称</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建自定义防火墙链（如果不存在）</span></span><br><span class="line">iptables -L <span class="variable">$CHAIN_NAME</span> &amp;&gt; /dev/null</span><br><span class="line"><span class="keyword">if</span> [[ $? -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;创建自定义链: <span class="variable">$CHAIN_NAME</span>&quot;</span></span><br><span class="line">  iptables -N <span class="variable">$CHAIN_NAME</span></span><br><span class="line">  <span class="comment"># 确保 INPUT 链引用自定义链</span></span><br><span class="line">  iptables -I INPUT -j <span class="variable">$CHAIN_NAME</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取日志中的 IP 地址并统计</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;解析日志文件：<span class="variable">$LOG_FILE</span>&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -A ip_counts</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> -r line; <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># 从日志中提取 IP</span></span><br><span class="line">  ip=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$line</span>&quot;</span> | grep -oP <span class="string">&#x27;\b(?:[0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;\b&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$ip</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    ip_counts[<span class="string">&quot;<span class="variable">$ip</span>&quot;</span>]=$((ip_counts[&quot;<span class="variable">$ip</span>&quot;] + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span> &lt; <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历统计结果，筛选频率超过 $THRESHOLD 的 IP</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;筛选频率超过 <span class="variable">$THRESHOLD</span> 的 IP&quot;</span></span><br><span class="line">blacklist_ips=()</span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;!ip_counts[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="variable">$&#123;ip_counts[&quot;$ip&quot;]&#125;</span> -gt <span class="variable">$THRESHOLD</span> ]]; <span class="keyword">then</span></span><br><span class="line">    blacklist_ips+=(<span class="string">&quot;<span class="variable">$ip</span>&quot;</span>)</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 去重并添加到黑名单文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;将 IP 添加到黑名单文件并去重&quot;</span></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;blacklist_ips[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> ! grep -q <span class="string">&quot;^$ip$&quot;</span> <span class="string">&quot;<span class="variable">$BLACKLIST_FILE</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$ip</span>&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$BLACKLIST_FILE</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次性检查哪些 IP 已经在防火墙中，过滤掉已存在的 IP</span></span><br><span class="line">existing_ips=$(iptables -L <span class="variable">$CHAIN_NAME</span> -v -n | grep -oP <span class="string">&#x27;\b(?:[0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;\b&#x27;</span> | <span class="built_in">sort</span> -u | grep -v <span class="string">&#x27;^0\.0\.0\.0$&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历黑名单 IP，添加到防火墙中</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;更新防火墙黑名单规则&quot;</span></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;blacklist_ips[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$existing_ips</span>&quot;</span> | grep -wq <span class="string">&quot;^$ip$&quot;</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;IP 已在防火墙中：<span class="variable">$ip</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;添加黑名单规则：<span class="variable">$ip</span>&quot;</span></span><br><span class="line">    iptables -A <span class="variable">$CHAIN_NAME</span> -s <span class="string">&quot;<span class="variable">$ip</span>&quot;</span> -j DROP</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;防火墙规则更新完成！&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/10 * * * * bash /home/ubuntu/frp/blacklist.sh &gt;&gt; /home/ubuntu/frp/blacklist.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><blockquote><p><code>2&gt;&amp;1</code>：将标准错误（stderr）重定向到标准输出，这样标准错误也会被追加到同一个日志文件中。</p></blockquote><table><thead><tr><th>名称</th><th>代码</th><th>操作符</th></tr></thead><tbody><tr><td>标准输入(stdin)</td><td>0</td><td>&lt; 或 &lt;&lt;</td></tr><tr><td>标准输出(stdout)</td><td>1</td><td>&gt;,&gt;&gt;,1&gt; 或 1&gt;&gt;</td></tr><tr><td>标准错误输出(stderr)</td><td>2</td><td>2&gt; 或 2&gt;&gt;</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;过程&quot;&gt;&lt;a href=&quot;#过程&quot; class=&quot;headerlink&quot; title=&quot;过程&quot;&gt;&lt;/a&gt;过程&lt;/h2&gt;&lt;p&gt;又又又被攻击了，这次是通过stp挂在公网的rdp。方便我远程访问家里云。&lt;/p&gt;
&lt;p&gt;起初是看到了v站的一篇帖子：&lt;a class=&quot;li</summary>
      
    
    
    
    <category term="编程记录" scheme="https://cooooing.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="网络安全" scheme="https://cooooing.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="云服务器" scheme="https://cooooing.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="防火墙" scheme="https://cooooing.github.io/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>《Redis设计与实现》读书笔记-单机数据库的实现</title>
    <link href="https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-11-05T01:15:30.000Z</published>
    <updated>2024-11-05T01:15:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第九章-数据库"><a href="#第九章-数据库" class="headerlink" title="第九章 - 数据库"></a>第九章 - 数据库</h2><h3 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h3><p>Redis服务器将所有数据库都保存在服务器状态redis.h&#x2F;redisServer结构的db数组中，db数组的每个项都是一个redis.h&#x2F;redisDb结构，每个redisDb结构代表一个数据库：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 服务器的数据库数量</span></span><br><span class="line">    <span class="type">int</span> dbnum;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16，所以Redis服务器默认会创建16个数据库。</p><h3 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h3><p>每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。<br>默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。</p><p>在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 记录客户端当前正在使用的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库。<br>通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能——这就是SELECT命令的实现原理。</p><h3 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h3><p>Redis是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个redis.h&#x2F;redisDb结构表示。<br>其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>键空间和用户所见的数据库是直接对应的：</p><ul><li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li><li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。</li></ul><p>因为数据库的键空间是一个字典，所以所有针对数据库的操作，比如添加一个键值对到数据库，或者从数据库中删除一个键值对，又或者在数据库中获取某个键值对等，实际上都是通过对键空间字典进行操作来实现的。<br>除了这些针对之外，还有很多针对数据库本身的Redis命令，也可以通过对键空间的操作来实现。比如用于清空整个数据库的FLUSHDB命令，就是通过删除键空间中的所有键值对来实现的。</p><p><strong>读写键空间时的维护操作</strong><br>当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作，其中包括：</p><ul><li>在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</li><li>在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime命令可以查看键key的闲置时间。</li><li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作。</li><li>如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过。</li><li>服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。</li><li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。</li></ul><h3 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h3><p>通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。</p><p>SETEX命令可以在设置一个字符串键的同时为键设置过期时间（只能用于字符串键）。<br>与EXPIRE命令和PEXPIRE命令类似，客户端可以通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（expire time）。<br><strong>过期时间是一个UNIX时间戳</strong>，当键的过期时间来临时，服务器就会自动从数据库中删除这个键。</p><p>过期时间是一个UNIX时间戳，当键的过期时间来临时，服务器就会自动从数据库中删除这个键。</p><h4 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h4><p>Redis有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被删除）：</p><ul><li><code>EXPIRE &lt;key&gt; &lt;ttl&gt;</code>命令用于将键key的生存时间设置为ttl秒。</li><li><code>PEXPIRE &lt;key&gt; &lt;ttl&gt;</code>命令用于将键key的生存时间设置为ttl毫秒。</li><li><code>EXPIREAT &lt;key&gt; &lt;timestamp&gt;</code>命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。</li><li><code>PEXPIREAT &lt;key&gt; &lt;timestamp&gt;</code>命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。</li></ul><p>虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的：无论客户端执行的是以上四个命令中的哪一个，经过转换之后，最终的执行效果都和执行PEXPIREAT命令一样。</p><h4 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h4><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。</li><li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>以下是PEXPIREAT命令的伪代码定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">PEXPIREAT</span>(<span class="params">key, expire_time_in_ms</span>):</span><br><span class="line">    <span class="comment"># 如果给定的键不存在于键空间，那么不能设置过期时间</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> redisDb.<span class="built_in">dict</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 在过期字典中关联键和过期时间</span></span><br><span class="line">    redisDb.expires[key] = expire_time_in_ms</span><br><span class="line">    <span class="comment"># 过期时间设置成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h4><p>PERSIST命令可以移除一个键的过期时间。<br>PERSIST命令就是PEXPIREAT命令的反操作：PERSIST命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。</p><p>以下是PERSIST命令的伪代码定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">PERSIST</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 如果键不存在，或者键没有设置过期时间，那么直接返回</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> redisDb.expires:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 移除过期字典中给定键的键值对关联</span></span><br><span class="line">    redisDb.expires.remove(key)</span><br><span class="line">    <span class="comment"># 键的过期时间移除成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h4><p>TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间。</p><p>TTL和PTTL两个命令都是通过计算键的过期时间和当前时间之间的差来实现的，以下是这两个命令的伪代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">PTTL</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 键不存在于数据库</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> redisDb.<span class="built_in">dict</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">2</span></span><br><span class="line">    <span class="comment"># 尝试取得键的过期时间</span></span><br><span class="line">    <span class="comment"># 如果键没有设置过期时间，那么 expire_time_in_ms 将为 None</span></span><br><span class="line">    expire_time_in_ms = redisDb.expires.get(key)</span><br><span class="line">    <span class="comment"># 键没有设置过期时间</span></span><br><span class="line">    <span class="keyword">if</span> expire_time_in_ms <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 获得当前时间</span></span><br><span class="line">    now_ms = get_current_unix_timestamp_in_ms()</span><br><span class="line">    <span class="comment"># 过期时间减去当前时间，得出的差就是键的剩余生存时间</span></span><br><span class="line">    <span class="keyword">return</span> (expire_time_in_ms - now_ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">TTL</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 获取以毫秒为单位的剩余生存时间</span></span><br><span class="line">    ttl_in_ms = PTTL(key)</span><br><span class="line">    <span class="keyword">if</span> ttl_in_ms &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 处理返回值为-2和-1的情况</span></span><br><span class="line">        <span class="keyword">return</span> ttl_in_ms</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 将毫秒转换为秒</span></span><br><span class="line">        <span class="keyword">return</span> ms_to_sec(ttl_in_ms)</span><br></pre></td></tr></table></figure><h4 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h4><p>通过过期字典，程序可以用以下步骤检查一个给定键是否过期：</p><ol><li>检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间。</li><li>检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期。</li></ol><p>可以用伪代码来描述这一过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_expired</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 取得键的过期时间</span></span><br><span class="line">    expire_time_in_ms = redisDb.expires.get(key)</span><br><span class="line">    <span class="comment"># 键没有设置过期时间</span></span><br><span class="line">    <span class="keyword">if</span> expire_time_in_ms <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 取得当前时间的UNIX时间戳</span></span><br><span class="line">    now_ms = get_current_unix_timestamp_in_ms()</span><br><span class="line">    <span class="comment"># 检查当前时间是否大于键的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> now_ms &gt; expire_time_in_ms:</span><br><span class="line">        <span class="comment"># 是，键已经过期</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 否，键未过期</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>实现过期键判定的另一种方法是使用TTL命令或者PTTL命令，比如说，如果对某个键执行TTL命令，并且命令返回的值大于等于0，那么说明该键未过期。<br>在实际中，Redis检查键是否过期的方法和is_expired函数所描述的方法一致，因为直接访问字典比执行一个命令稍微快一些。</p><h3 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h3><p>如果一个键过期了，那么它什么时候会被删除呢？</p><p>这个问题有三种可能的答案，它们分别代表了三种不同的删除策略：</p><ul><li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</li><li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li></ul><p>在这三种策略中，第一种和第三种为主动删除策略，而第二种则为被动删除策略。</p><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><p>定时删除策略对内存是最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。<br>另一方面，定时删除策略的缺点是，它对CPU时间是最不友好的：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。</p><p>例如，如果正有大量的命令请求在等待服务器处理，并且服务器当前不缺少内存，那么服务器应该优先将CPU时间用在处理客户端的命令请求上面，而不是用在删除过期键上面。<br>除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为O（N）——并不能高效地处理大量时间事件。<br>因此，要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段来说并不现实。</p><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>惰性删除策略对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。<br>惰性删除策略的缺点是，它对内存是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。<br>在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行FLUSHDB），我们甚至可以将这种情况看作是一种内存泄漏——无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。</p><p>举个例子，对于一些和时间有关的数据，比如日志（log），在某个时间点之后，对它们的访问就会大大减少，甚至不再访问，如果这类过期数据大量地积压在数据库中，用户以为服务器已经自动将它们删除了，但实际上这些键仍然存在，而且键所占用的内存也没有释放，那么造成的后果肯定是非常严重的。</p><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>从上面对定时删除和惰性删除的讨论来看，这两种删除方式在单一使用时都有明显的缺陷：</p><ul><li>惰性删除浪费太多内存，有内存泄漏的危险。</li><li>定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。</li></ul><p>定期删除策略是前两种策略的一种整合和折中：</p><ul><li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li><li>除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。</li></ul><p>定期删除策略的难点是确定删除操作执行的时长和频率：</p><ul><li>如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。</li><li>如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。</li></ul><p>因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。<br><strong>任何单一的方案都有各自的优势和不足，因此，通常情况都是将不同的方案组合，以尽可能的利用他们的优势，降低劣势。同时可以根据实际业务需要、服务器性能等实际情况进行调整。</strong></p><h3 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h3><p>Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p><h4 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h4><p>过期键的惰性删除策略由db.c&#x2F;expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：</p><ul><li>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除。</li><li>如果输入键未过期，那么expireIfNeeded函数不做动作。</li></ul><p>expireIfNeeded函数就像一个过滤器，它可以在命令真正执行之前，过滤掉过期的输入键，从而避免命令接触到过期键。</p><p>另外，因为每个被访问的键都可能因为过期而被expireIfNeeded函数删除，所以每个命令的实现函数都必须能同时处理键存在以及键不存在这两种情况：</p><ul><li>当键存在时，命令按照键存在的情况执行。</li><li>当键不存在或者键因为过期而被expireIfNeeded函数删除时，命令按照键不存在的情况执行。</li></ul><h4 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a>定期删除策略的实现</h4><p>过期键的定期删除策略由redis.c&#x2F;activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c&#x2F;serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p><p>整个过程可以用伪代码描述如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认每次检查的数据库数量</span></span><br><span class="line">DEFAULT_DB_NUMBERS = <span class="number">16</span></span><br><span class="line"><span class="comment"># 默认每个数据库检查的键数量</span></span><br><span class="line">DEFAULT_KEY_NUMBERS = <span class="number">20</span></span><br><span class="line"><span class="comment"># 全局变量，记录检查进度</span></span><br><span class="line">current_db = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">activeExpireCycle</span>():</span><br><span class="line">    <span class="comment"># 初始化要检查的数据库数量</span></span><br><span class="line">    <span class="comment"># 如果服务器的数据库数量比 DEFAULT_DB_NUMBERS 要小</span></span><br><span class="line">    <span class="comment"># 那么以服务器的数据库数量为准</span></span><br><span class="line">    <span class="keyword">if</span> server.dbnum &lt; DEFAULT_DB_NUMBERS:</span><br><span class="line">        db_numbers = server.dbnum</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        db_numbers = DEFAULT_DB_NUMBERS</span><br><span class="line">    <span class="comment"># 遍历各个数据库</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(db_numbers):</span><br><span class="line">        <span class="comment"># 如果current_db的值等于服务器的数据库数量</span></span><br><span class="line">        <span class="comment"># 这表示检查程序已经遍历了服务器的所有数据库一次</span></span><br><span class="line">        <span class="comment"># 将current_db重置为0，开始新的一轮遍历</span></span><br><span class="line">        <span class="keyword">if</span> current_db == server.dbnum:</span><br><span class="line">            current_db = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 获取当前要处理的数据库</span></span><br><span class="line">        redisDb = server.db[current_db]</span><br><span class="line">        <span class="comment"># 将数据库索引增1，指向下一个要处理的数据库</span></span><br><span class="line">        current_db += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 检查数据库键</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(DEFAULT_KEY_NUMBERS):</span><br><span class="line">            <span class="comment"># 如果数据库中没有一个键带有过期时间，那么跳过这个数据库</span></span><br><span class="line">            <span class="keyword">if</span> redisDb.expires.size() == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 随机获取一个带有过期时间的键</span></span><br><span class="line">            key_with_ttl = redisDb.expires.get_random_key()</span><br><span class="line">            <span class="comment"># 检查键是否过期，如果过期就删除它</span></span><br><span class="line">            <span class="keyword">if</span> is_expired(key_with_ttl):</span><br><span class="line">                delete_key(key_with_ttl)</span><br><span class="line">            <span class="comment"># 已达到时间上限，停止处理</span></span><br><span class="line">            <span class="keyword">if</span> reach_time_limit(): <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>activeExpireCycle函数的工作模式可以总结如下：</p><ul><li>函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。</li><li>全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。比如说，如果当前activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数执行时，将从11号数据库开始查找并删除过期键。</li><li>随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。</li></ul><h3 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h3><p>看看过期键对Redis服务器中其他模块的影响，看看RDB持久化功能、AOF持久化功能以及复制功能是如何处理数据库中的过期键的。</p><h4 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h4><p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。<br>数据库中包含过期键不会对生成新的RDB文件造成影响。</p><h4 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h4><p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：</p><ul><li>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li><li>如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。</li></ul><h4 id="AOF文件写入"><a href="#AOF文件写入" class="headerlink" title="AOF文件写入"></a>AOF文件写入</h4><p>当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。<br>当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。</p><p>举个例子，如果客户端使用GET message命令，试图访问过期的message键，那么服务器将执行以下三个动作：</p><ol><li>从数据库中删除message键。</li><li>追加一条DEL message命令到AOF文件。</li><li>向执行GET命令的客户端返回空回复。</li></ol><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。<br>数据库中包含过期键不会对AOF重写造成影响。</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：</p><ul><li>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li><li>从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</li></ul><p>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。</p><p><strong>在主从复制中，数据一致性至关重要。</strong> 主从服务器常用于读写分离，允许从服务器延迟一定的状态同步来提升读性能。</p><h3 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h3><p>数据库通知是Redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。</p><p>关注“某个键执行了什么命令”的通知称为<strong>键空间通知（key-space notification）</strong>，<br>除此之外，还有另一类称为<strong>键事件通知（key-event notification）</strong> 的通知，它们关注的是“某个命令被什么键执行了”。</p><p>服务器配置的 <code>notify-keyspace-events</code> 选项决定了服务器所发送通知的类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span><br><span class="line">E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span><br><span class="line">g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span><br><span class="line">$     String commands</span><br><span class="line">l     List commands</span><br><span class="line">s     Set commands</span><br><span class="line">h     Hash commands</span><br><span class="line">z     Sorted set commands</span><br><span class="line">t     Stream commands</span><br><span class="line">d     Module key type events</span><br><span class="line">x     Expired events (events generated every time a key expires)</span><br><span class="line">e     Evicted events (events generated when a key is evicted for maxmemory)</span><br><span class="line">m     Key miss events (events generated when a key that doesn&#x27;t exist is accessed)</span><br><span class="line">n     New key events (Note: not included in the &#x27;A&#x27; class)</span><br><span class="line">A     Alias for &quot;g$lshztxed&quot;, so that the &quot;AKE&quot; string means all the events except &quot;m&quot; and &quot;n&quot;.</span><br></pre></td></tr></table></figure><p>更多设置信息，可以参考官方文档：<a class="link"   href="https://redis.io/docs/latest/develop/use/keyspace-notifications/" >Redis keyspace notifications<i class="fas fa-external-link-alt"></i></a>。</p><h4 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h4><p>发送数据库通知的功能是由notify.c&#x2F;notifyKeyspaceEvent函数实现的： <code>void notifyKeyspaceEvent(int type,char *event,robj *key,int dbid);</code></p><p>函数的 type 参数是当前想要发送的通知的类型，程序会根据这个值来判断通知是否就是服务器配置 notify-keyspace-events 选项所选定的通知类型，从而决定是否发送通知。<br>event、keys 和 dbid 分别是事件的名称、产生事件的键，以及产生事件的数据库号码，函数会根据 type 参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名。<br>每当一个Redis命令需要发送数据库通知的时候，该命令的实现函数就会调用 notify-KeyspaceEvent 函数，并向函数传递传递该命令所引发的事件的相关信息。</p><h4 id="发送通知的实现"><a href="#发送通知的实现" class="headerlink" title="发送通知的实现"></a>发送通知的实现</h4><p>以下是notifyKeyspaceEvent函数的伪代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">notifyKeyspaceEvent</span>(<span class="params"><span class="built_in">type</span>, event, key, dbid</span>):</span><br><span class="line">    <span class="comment"># 如果给定的通知不是服务器允许发送的通知，那么直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (server.notify_keyspace_events &amp; <span class="built_in">type</span>):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 发送键空间通知</span></span><br><span class="line">    <span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYSPACE:</span><br><span class="line">        <span class="comment"># 将通知发送给频道__keyspace@&lt;dbid&gt;__:&lt;key&gt;</span></span><br><span class="line">        <span class="comment"># 内容为键所发生的事件 &lt;event&gt;</span></span><br><span class="line">        <span class="comment"># 构建频道名字</span></span><br><span class="line">        chan = <span class="string">&quot;__keyspace@&#123;dbid&#125;__:&#123;key&#125;&quot;</span>.<span class="built_in">format</span>(dbid=dbid, key=key)</span><br><span class="line">        <span class="comment"># 发送通知</span></span><br><span class="line">        pubsubPublishMessage(chan, event)</span><br><span class="line">    <span class="comment"># 发送键事件通知</span></span><br><span class="line">    <span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYEVENT:</span><br><span class="line">        <span class="comment"># 将通知发送给频道__keyevent@&lt;dbid&gt;__:&lt;event&gt;</span></span><br><span class="line">        <span class="comment"># 内容为发生事件的键 &lt;key&gt;</span></span><br><span class="line">        <span class="comment"># 构建频道名字</span></span><br><span class="line">        chan = <span class="string">&quot;__keyevent@&#123;dbid&#125;__:&#123;event&#125;&quot;</span>.<span class="built_in">format</span>(dbid=dbid, event=event)</span><br><span class="line">        <span class="comment"># 发送通知</span></span><br><span class="line">        pubsubPublishMessage(chan, key)</span><br></pre></td></tr></table></figure><p>notifyKeyspaceEvent 函数执行以下操作：</p><ol><li>server.notify_keyspace_events 属性就是服务器配置 notify-keyspace-events 选项所设置的值，如果给定的通知类型type不是服务器允许发送的通知类型，那么函数会直接返回，不做任何动作。</li><li>如果给定的通知是服务器允许发送的通知，那么下一步函数会检测服务器是否允许发送键空间通知，如果允许的话，程序就会构建并发送事件通知。</li><li>最后，函数检测服务器是否允许发送键事件通知，如果允许的话，程序就会构建并发送事件通知。</li></ol><p>另外，pubsubPublishMessage 函数是 PUBLISH 命令的实现函数，执行这个函数等同于执行PUBLISH命令，订阅数据库通知的客户端收到的信息就是由这个函数发出的。</p><h2 id="第十章-RDB持久化"><a href="#第十章-RDB持久化" class="headerlink" title="第十章 - RDB持久化"></a>第十章 - RDB持久化</h2><p>Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，而每个非空数据库中又可以包含任意个键值对，为了方便起见，我们将服务器中的非空数据库以及它们的键值对统称为数据库状态。</p><p>下面展示了一个包含三个非空数据库的Redis服务器，这三个数据库以及数据库中的键值对就是该服务器的数据库状态。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8A%B6%E6%80%81%E7%A4%BA%E4%BE%8B.png"                        alt="数据库状态示例.png"                 ></p><p>因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。<br>为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p><p>RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中。<br>RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。</p><p>因为RDB文件是保存在硬盘里面的，所以即使Redis服务器进程退出，甚至运行Redis服务器的计算机停机，但只要RDB文件仍然存在，Redis服务器就可以用它来还原数据库状态。</p><h3 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h3><p>有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。</p><p><strong>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止</strong>，在服务器进程阻塞期间，服务器不能处理任何命令请求。<br>和SAVE命令直接阻塞服务器进程的做法不同，<strong>BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</strong></p><p>创建RDB文件的实际工作由rdb.c&#x2F;rdbSave函数完成，SAVE命令和BGSAVE命令会以不同的方式调用这个函数，通过以下伪代码可以明显地看出这两个命令之间的区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">SAVE</span>():</span><br><span class="line">    <span class="comment"># 创建RDB文件</span></span><br><span class="line">    rdbSave()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BGSAVE</span>():</span><br><span class="line">    <span class="comment"># 创建子进程</span></span><br><span class="line">    pid = fork()</span><br><span class="line">    <span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 子进程负责创建RDB文件</span></span><br><span class="line">        rdbSave()</span><br><span class="line">        <span class="comment"># 完成之后向父进程发送信号</span></span><br><span class="line">        signal_parent()</span><br><span class="line">    <span class="keyword">elif</span> pid &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 父进程继续处理命令请求，并通过轮询等待子进程的信号</span></span><br><span class="line">        handle_request_and_wait_signal()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 处理出错情况</span></span><br><span class="line">        handle_fork_error()</span><br></pre></td></tr></table></figure><p>和使用SAVE命令或者BGSAVE命令创建RDB文件不同，RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。</p><p>另外值得一提的是，因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：</p><ul><li>如果服务器开启了AOF持久化功能，那么服务器会<strong>优先使用AOF文件</strong>来还原数据库状态。</li><li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</li></ul><h4 id="SAVE命令执行时的服务器状态"><a href="#SAVE命令执行时的服务器状态" class="headerlink" title="SAVE命令执行时的服务器状态"></a>SAVE命令执行时的服务器状态</h4><p>前面提到过，当SAVE命令执行时，Redis服务器会被阻塞，所以当SAVE命令正在执行时，客户端发送的所有命令请求都会被拒绝。<br>只有在服务器执行完SAVE命令、重新开始接受命令请求之后，客户端发送的命令才会被处理。</p><h4 id="BGSAVE命令执行时的服务器状态"><a href="#BGSAVE命令执行时的服务器状态" class="headerlink" title="BGSAVE命令执行时的服务器状态"></a>BGSAVE命令执行时的服务器状态</h4><p>因为 BGSAVE 命令的保存工作是由子进程执行的，所以在子进程创建 RDB 文件的过程中， Redis 服务器仍然可以继续处理客户端的命令请求。<br>但是，在 BGSAVE 命令执行期间，服务器处理 SAVE 、 BGSAVE 、 BGREWRITEAOF 三个命令的方式会和平时有所不同。</p><p>首先，在 BGSAVE 命令执行期间，客户端发送的 SAVE 命令会被服务器拒绝，服务器禁止 SAVE 命令和 BGSAVE 命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个 rdbSave 调用，防止产生竞争条件。<br>其次，在 BGSAVE 命令执行期间，客户端发送的 BGSAVE 命令会被服务器拒绝，因为同时执行两个 BGSAVE 命令也会产生竞争条件。<br>最后， BGREWRITEAOF 和 BGSAVE 两个命令不能同时执行：</p><ul><li>如果 BGSAVE 命令正在执行，那么客户端发送的 BGREWRITEAOF 命令会被延迟到 BGSAVE 命令执行完毕之后执行。</li><li>如果 BGREWRITEAOF 命令正在执行，那么客户端发送的 BGSAVE 命令会被服务器拒绝。</li></ul><p>因为 BGREWRITEAOF 和 BGSAVE 两个命令的实际工作都由子进程执行，所以这两个命令在操作方面并没有什么冲突的地方。<br>不能同时执行它们只是一个性能方面的考虑——并发出两个子进程，并且这两个子进程都同时执行大量的磁盘写入操作，这怎么想都不会是一个好主意。</p><h4 id="RDB文件载入时的服务器状态"><a href="#RDB文件载入时的服务器状态" class="headerlink" title="RDB文件载入时的服务器状态"></a>RDB文件载入时的服务器状态</h4><p><strong>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。</strong></p><h3 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h3><p>SAVE命令由服务器进程执行保存工作，BGSAVE命令则由子进程执行保存工作，所以SAVE命令会阻塞服务器，而BGSAVE命令则不会。</p><p>因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。<br>用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。</p><h4 id="设置保存条件"><a href="#设置保存条件" class="headerlink" title="设置保存条件"></a>设置保存条件</h4><p>当Redis服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，如果用户没有主动设置save选项，那么服务器会为save选项设置默认条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><ul><li>服务器在900秒之内，对数据库进行了至少1次修改。</li><li>服务器在300秒之内，对数据库进行了至少10次修改。</li><li>服务器在60秒之内，对数据库进行了至少10000次修改。</li></ul><p>接着，服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 记录了保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> &#123;</span></span><br><span class="line">    <span class="comment">// 秒数</span></span><br><span class="line">    <span class="type">time_t</span> seconds;</span><br><span class="line">    <span class="comment">// 修改数</span></span><br><span class="line">    <span class="type">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="dirty-计数器和-lastsave-属性"><a href="#dirty-计数器和-lastsave-属性" class="headerlink" title="dirty 计数器和 lastsave 属性"></a>dirty 计数器和 lastsave 属性</h4><p>除了 saveparams 数组之外，服务器状态还维持着一个 dirty 计数器，以及一个 lastsave 属性：</p><ul><li>dirty 计数器记录距离上一次成功执行 SAVE 命令或者 BGSAVE 命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。</li><li>lastsave 属性是一个 UNIX 时间戳，记录了服务器上一次成功执行 SAVE 命令或者 BGSAVE 命令的时间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 修改计数器</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dirty;</span><br><span class="line">    <span class="comment">// 上一次执行保存的时间</span></span><br><span class="line">    <span class="type">time_t</span> lastsave;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当服务器成功执行一个数据库修改命令之后，程序就会对dirty计数器进行更新：命令修改了多少次数据库，dirty计数器的值就增加多少。</p><h4 id="检查保存条件是否满足"><a href="#检查保存条件是否满足" class="headerlink" title="检查保存条件是否满足"></a>检查保存条件是否满足</h4><p>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。</p><p>以下伪代码展示了serverCron函数检查保存条件的过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">serverCron</span>():</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># 遍历所有保存条件</span></span><br><span class="line">    <span class="keyword">for</span> saveparam <span class="keyword">in</span> server.saveparams:</span><br><span class="line">        <span class="comment"># 计算距离上次执行保存操作有多少秒</span></span><br><span class="line">        save_interval = unixtime_now() - server.lastsave</span><br><span class="line">        <span class="comment"># 如果数据库状态的修改次数超过条件所设置的次数</span></span><br><span class="line">        <span class="comment"># 并且距离上次保存的时间超过条件所设置的时间</span></span><br><span class="line">        <span class="comment"># 那么执行保存操作</span></span><br><span class="line">        <span class="keyword">if</span> server.dirty &gt;= saveparam.changes <span class="keyword">and</span> save_interval &gt; saveparam.seconds:</span><br><span class="line">            BGSAVE()</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>程序会遍历并检查saveparams数组中的所有保存条件，只要有任意一个条件被满足，那么服务器就会执行BGSAVE命令。</p><h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><p>RDB文件结构如下：</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/RDB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png"                        alt="RDB文件结构.png"                 ></p><p>RDB文件的最开头是REDIS部分，这个部分的长度为5字节，保存着“REDIS”五个字符。通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否RDB文件。<br>因为RDB文件保存的是二进制数据，而不是C字符串，为了简便起见，我们用”REDIS”符号代表’R’、’E’、’D’、’I’、’S’五个字符，而不是带’\0’结尾符号的C字符串’R’、’E’、’D’、’I’、’S’、’\0’。后续关于RDB文件的结构都是这样。</p><p>db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号，比如”0006”就代表RDB文件的版本为第六版。这里介绍的也是第六版RDB文件的结构。（虽然我看这本书的时候，redis最新版本已经是7.4.1了。）<br>databases部分包含着零个或任意多个数据库，以及各个数据库中的键值对数据：</p><ul><li>如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分也为空，长度为0字节。</li><li>如果服务器的数据库状态为非空（有至少一个数据库非空），那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同。</li></ul><p>EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了。<br>check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录的校验和进行对比，以此来检查RDB文件是否有出错或者损坏的情况出现。</p><h4 id="databases部分"><a href="#databases部分" class="headerlink" title="databases部分"></a>databases部分</h4><p>一个RDB文件的databases部分可以保存任意多个非空数据库。</p><p>例如，如果服务器的0号数据库和3号数据库非空，那么服务器将创建一个如图所示的RDB文件，图中的database 0代表0号数据库中的所有键值对数据，而database 3则代表3号数据库中的所有键值对数据。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%B8%A6%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%9D%9E%E7%A9%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84RDB%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B.png"                        alt="带有两个非空数据库的RDB文件示例.png"                 ></p><p>每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/RDB%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84.png"                        alt="RDB文件中的数据库结构.png"                 ></p><p>SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读入的将是一个数据库号码。<br>db_number保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节、2字节或者5字节。当程序读入db_number部分之后，服务器会调用SELECT命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中。<br>key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过期时间等条件的不同，key_value_pairs部分的长度也会有所不同。</p><h4 id="key-value-pairs部分"><a href="#key-value-pairs部分" class="headerlink" title="key_value_pairs部分"></a>key_value_pairs部分</h4><p>RDB文件中的每个key_value_pairs部分都保存了一个或以上数量的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存在内。</p><p>不带过期时间的键值对在RDB文件中由<strong>TYPE、key、value</strong>三部分组成。</p><p>TYPE记录了value的类型，长度为1字节，值可以是以下常量的其中一个：</p><ul><li>REDIS_RDB_TYPE_STRING</li><li>REDIS_RDB_TYPE_LIST</li><li>REDIS_RDB_TYPE_SET</li><li>REDIS_RDB_TYPE_ZSET</li><li>REDIS_RDB_TYPE_HASH</li><li>REDIS_RDB_TYPE_LIST_ZIPLIST</li><li>REDIS_RDB_TYPE_SET_INTSET</li><li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li><li>REDIS_RDB_TYPE_HASH_ZIPLIST</li></ul><p>以上列出的每个TYPE常量都代表了一种对象类型或者底层编码，当服务器读入RDB文件中的键值对数据时，程序会根据TYPE的值来决定如何读入和解释value的数据。key和value分别保存了键值对的键对象和值对象：</p><ul><li>其中key总是一个字符串对象，它的编码方式和REDIS_RDB_TYPE_STRING类型的value一样。根据内容长度的不同，key的长度也会有所不同。</li><li>根据TYPE类型的不同，以及保存内容长度的不同，保存value的结构和长度也会有所不同，稍后会详细说明每种TYPE类型的value结构保存方式。</li></ul><p>带有过期时间的键值对在RDB文件中由<strong>EXPIRETIME_MS、ms、TYPE、key、value</strong>五部分组成。</p><ul><li>EXPIRETIME_MS常量的长度为1字节，它告知读入程序，接下来要读入的将是一个以毫秒为单位的过期时间。</li><li>ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间。</li></ul><h4 id="value的编码"><a href="#value的编码" class="headerlink" title="value的编码"></a>value的编码</h4><p>RDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录，根据类型的不同，value部分的结构、长度也会有所不同。</p><h5 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h5><p>如果TYPE的值为REDIS_RDB_TYPE_STRING，那么value保存的就是一个字符串对象，字符串对象的编码可以是REDIS_ENCODING_INT或者REDIS_ENCODING_RAW。</p><p>如果字符串对象的编码为REDIS_ENCODING_INT，那么说明对象中保存的是长度不超过32位的整数。<br>其中，ENCODING的值可以是REDIS_RDB_ENC_INT8、REDIS_RDB_ENC_INT16或者REDIS_RDB_ENC_INT32三个常量的其中一个，它们分别代表RDB文件使用8位（bit）、16位或者32位来保存整数值integer。</p><p>INT编码字符串对象的保存结构<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/INT%E7%BC%96%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png"                        alt="INT编码字符串对象的保存结构.png"                 ></p><p>如果字符串对象的编码为REDIS_ENCODING_RAW，那么说明对象所保存的是一个字符串值，根据字符串长度的不同，有压缩和不压缩两种方法来保存这个字符串：</p><ul><li>如果字符串的长度小于等于20字节，那么这个字符串会直接被原样保存。</li><li>如果字符串的长度大于20字节，那么这个字符串会被压缩之后再保存。</li></ul><p>以上两个条件是在假设服务器打开了RDB文件压缩功能的情况下进行的，如果服务器关闭了RDB文件压缩功能，那么RDB程序总以无压缩的方式保存字符串值。<br>具体信息可以参考redis.conf文件中关于rdbcompression选项的说明。</p><p>对于没有被压缩的字符串，RDB程序会以下图所示的结构来保存该字符串。<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E6%97%A0%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png"                        alt="无压缩字符串的保存结构.png"                 ></p><p>其中，string部分保存了字符串值本身，而len保存了字符串值的长度。<br>对于压缩后的字符串，RDB程序会以下图所示的结构来保存该字符串。<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%8E%8B%E7%BC%A9%E5%90%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png"                        alt="压缩后字符串的保存结构.png"                 ></p><p>其中，REDIS_RDB_ENC_LZF常量标志着字符串已经被<a class="link"   href="http://liblzf.plan9.de/" >LZF算法<i class="fas fa-external-link-alt"></i></a>压缩过了，读入程序在碰到这个常量时，会根据之后的compressed_len、origin_len和compressed_string三部分，对字符串进行解压缩：<br>其中compressed_len记录的是字符串被压缩之后的长度，而origin_len记录的是字符串原来的长度，compressed_string记录的则是被压缩之后的字符串。</p><h5 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h5><p>如果TYPE的值为REDIS_RDB_TYPE_LIST，那么value保存的就是一个REDIS_ENCODING_LINKEDLIST编码的列表对象，RDB文件保存这种对象的结构如下图所示。<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/LINKEDLIST%E7%BC%96%E7%A0%81%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png"                        alt="LINKEDLIST编码列表对象的保存结构.png"                 ></p><p>list_length记录了列表的长度，它记录列表保存了多少个项（item），读入程序可以通过这个长度知道自己应该读入多少个列表项。<br>图中以item开头的部分代表列表的项，因为每个列表项都是一个字符串对象，所以程序会以处理字符串对象的方式来保存和读入列表项。</p><h5 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h5><p>如果TYPE的值为REDIS_RDB_TYPE_SET，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象，RDB文件保存这种对象的结构如下图所示。<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/HT%E7%BC%96%E7%A0%81%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png"                        alt="HT编码集合对象的保存结构.png"                 ></p><p>其中，set_size是集合的大小，它记录集合保存了多少个元素，读入程序可以通过这个大小知道自己应该读入多少个集合元素。<br>图中以elem开头的部分代表集合的元素，因为每个集合元素都是一个字符串对象，所以程序会以处理字符串对象的方式来保存和读入集合元素。</p><h5 id="哈希表对象"><a href="#哈希表对象" class="headerlink" title="哈希表对象"></a>哈希表对象</h5><p>如果TYPE的值为REDIS_RDB_TYPE_HASH，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象，RDB文件保存这种对象的结构下图所示：</p><ul><li>hash_size记录了哈希表的大小，也即是这个哈希表保存了多少键值对，读入程序可以通过这个大小知道自己应该读入多少个键值对。</li><li>以key_value_pair开头的部分代表哈希表中的键值对，键值对的键和值都是字符串对象，所以程序会以处理字符串对象的方式来保存和读入键值对。</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/HT%E7%BC%96%E7%A0%81%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png"                        alt="HT编码哈希表对象的保存结构.png"                 ></p><p>结构中的每个键值对（key_value_pair）都以键紧挨着值的方式排列在一起。</p><h5 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h5><p>如果TYPE的值为REDIS_RDB_TYPE_ZSET，那么value保存的就是一个REDIS_ENCODING_SKIPLIST编码的有序集合对象，RDB文件保存这种对象的结构如图10-34所示。<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/SKIPLIST%E7%BC%96%E7%A0%81%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png"                        alt="SKIPLIST编码有序集合对象的保存结构.png"                 ></p><p>sorted_set_size记录了有序集合的大小，也即是这个有序集合保存了多少元素，读入程序需要根据这个值来决定应该读入多少有序集合元素。<br>以element开头的部分代表有序集合中的元素，每个元素又分为成员（member）和分值（score）两部分，成员是一个字符串对象，分值则是一个double类型的浮点数，程序在保存RDB文件时会先将分值转换成字符串对象，然后再用保存字符串对象的方法将分值保存起来。</p><h5 id="INTSET编码的集合"><a href="#INTSET编码的集合" class="headerlink" title="INTSET编码的集合"></a>INTSET编码的集合</h5><p>如果TYPE的值为REDIS_RDB_TYPE_SET_INTSET，那么value保存的就是一个整数集合对象，RDB文件保存这种对象的方法是，先将整数集合转换为字符串对象，然后将这个字符串对象保存到RDB文件里面。<br>如果程序在读入RDB文件的过程中，碰到由整数集合对象转换成的字符串对象，那么程序会根据TYPE值的指示，先读入字符串对象，再将这个字符串对象转换成原来的整数集合对象。</p><h5 id="ZIPLIST编码的列表、哈希表或者有序集合"><a href="#ZIPLIST编码的列表、哈希表或者有序集合" class="headerlink" title="ZIPLIST编码的列表、哈希表或者有序集合"></a>ZIPLIST编码的列表、哈希表或者有序集合</h5><p>如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST或者REDIS_RDB_TYPE_ZSET_ZIPLIST，那么value保存的就是一个压缩列表对象，RDB文件保存这种对象的方法是：</p><ol><li>将压缩列表转换成一个字符串对象。</li><li>将转换所得的字符串对象保存到RDB文件。</li></ol><p>如果程序在读入RDB文件的过程中，碰到由压缩列表对象转换成的字符串对象，那么程序会根据TYPE值的指示，执行以下操作：</p><ol><li>读入字符串对象，并将它转换成原来的压缩列表对象。</li><li>根据TYPE的值，设置压缩列表对象的类型：如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST，那么压缩列表对象的类型为列表；如果TYPE的值为REDIS_RDB_TYPE_HASH_ZIPLIST，那么压缩列表对象的类型为哈希表；如果TYPE的值为REDIS_RDB_TYPE_ZSET_ZIPLIST，那么压缩列表对象的类型为有序集合。</li></ol><p>从步骤2可以看出，由于TYPE的存在，即使列表、哈希表和有序集合三种类型都使用压缩列表来保存，RDB读入程序也总可以将读入并转换之后得出的压缩列表设置成原来的类型。</p><h3 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h3><p>使用od命令来分析Redis服务器产生的RDB文件，该命令可以用给定的格式转存（dump）并打印输入文件。<br>比如说，给定-c参数可以以ASCII编码的方式打印输入文件，给定-x参数可以以十六进制的方式打印输入文件，诸如此类，具体的信息可以参考od命令的文档。</p><h4 id="不包含任何键值对的RDB文件"><a href="#不包含任何键值对的RDB文件" class="headerlink" title="不包含任何键值对的RDB文件"></a>不包含任何键值对的RDB文件</h4><p>使用 <code>FLUSHALL</code> 清空数据库，使用 <code>SAVE</code> 创建一个数据库状态为空的RDB文件。<br>使用od命令，打印RDB文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@b9283e6096c1:/data# od -c dump.rdb</span><br><span class="line">0000000   R   E   D   I   S   0   0   1   2 372  \t   r   e   d   i   s</span><br><span class="line">0000020   -   v   e   r 005   7   .   4   .   1 372  \n   r   e   d   i</span><br><span class="line">0000040   s   -   b   i   t   s 300   @ 372 005   c   t   i   m   e 302</span><br><span class="line">0000060   g   d   1   g 372  \b   u   s   e   d   -   m   e   m 302   X</span><br><span class="line">0000100 316 021  \0 372  \b   a   o   f   -   b   a   s   e 300  \0 377</span><br><span class="line">0000120 272 257 332 306 334 330 026   w</span><br><span class="line">0000130</span><br></pre></td></tr></table></figure><p>第 7 版中新增加的操作符，以 0xFA （372 8进制） 作为标志。<br>可以存放多组 key-value，用来表示对应元信息。<br>每一对 key-value，都以0xFA 开头。key 和 value 均采用 rdb 字符串编码方法。 默认元信息列表：</p><ul><li>redis-ver：redis 版本信息。</li><li>redis-bits：输出 rdb 文件机器的位数，64bit 或 32 bit。</li><li>ctime：rdb 文件创建时间。</li><li>used-mem：rdb 加载到内存中的内存使用量。</li></ul><h4 id="包含字符串键的RDB文件"><a href="#包含字符串键的RDB文件" class="headerlink" title="包含字符串键的RDB文件"></a>包含字符串键的RDB文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@b9283e6096c1:/data# od -c dump.rdb</span><br><span class="line">0000000   R   E   D   I   S   0   0   1   2 372  \t   r   e   d   i   s</span><br><span class="line">0000020   -   v   e   r 005   7   .   4   .   1 372  \n   r   e   d   i</span><br><span class="line">0000040   s   -   b   i   t   s 300   @ 372 005   c   t   i   m   e 302</span><br><span class="line">0000060   /   r   1   g 372  \b   u   s   e   d   -   m   e   m 302   H</span><br><span class="line">0000100 220 022  \0 372  \b   a   o   f   -   b   a   s   e 300  \0 376</span><br><span class="line">0000120  \0 373 001  \0  \0 003   m   s   g 005   h   e   l   l   o 377</span><br><span class="line">0000140   g 270   o   c 003 235   ~   f</span><br><span class="line">0000150</span><br></pre></td></tr></table></figure><p>这里由于每个版本的格式并不一致，所以就不详细解读了。（书中版本较老，新版本加了很多东西）<br>可以参考这篇文章：<a class="link"   href="https://github.com/dalei2019/redis-study/blob/main/docs/redis-rdb-format.md" >Redis RDB 文件格式解析<i class="fas fa-external-link-alt"></i></a></p><h2 id="第十一章-AOF持久化"><a href="#第十一章-AOF持久化" class="headerlink" title="第十一章 - AOF持久化"></a>第十一章 - AOF持久化</h2><p>除了RDB持久化功能之外，Redis还提供了AOF（Append Only File）持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p><p>RDB持久化保存数据库状态的方法是将msg、fruits、numbers三个键的键值对保存到RDB文件中。<br>而AOF持久化保存数据库状态的方法则是将服务器执行的SET、SADD、RPUSH三个命令保存到AOF文件中。</p><p>被写入AOF文件的所有命令都是以Redis的命令请求协议格式（纯文本格式）保存的。</p><h3 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h3><p>AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p><h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。</p><h4 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h4><p>Redis的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。</p><p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面，这个过程可以用以下伪代码表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">eventLoop</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 处理文件事件，接收命令请求以及发送命令回复</span></span><br><span class="line">        <span class="comment"># 处理命令请求时可能会有新内容被追加到 aof_buf 缓冲区中</span></span><br><span class="line">        processFileEvents()</span><br><span class="line">        <span class="comment"># 处理时间事件</span></span><br><span class="line">        processTimeEvents()</span><br><span class="line">        <span class="comment"># 考虑是否要将 aof_buf 中的内容写入和保存到 AOF 文件里面</span></span><br><span class="line">        flushAppendOnlyFile()</span><br></pre></td></tr></table></figure><p>flushAppendOnlyFile 函数的行为由服务器配置的 appendfsync 选项的值来决定，各个不同值产生的行为。</p><table><thead><tr><th><code>appendonly</code> 选项的值</th><th><code>flushAppendonlyFile</code> 函数的行为</th></tr></thead><tbody><tr><td><code>always</code></td><td>将 <code>aof_buf</code> 缓冲区中的所有内容写入并同步到 AOF 文件，确保数据实时持久化。</td></tr><tr><td><code>everysec</code></td><td>将 <code>aof_buf</code> 缓冲区中的所有内容写入 AOF 文件，每隔一秒钟检查上次同步时间，如果超过一秒则再次同步。同步由一个独立线程负责执行，以减少阻塞。</td></tr><tr><td><code>no</code></td><td>将 <code>aof_buf</code> 缓冲区中的所有内容写入 AOF 文件，但不立即同步，何时同步由操作系统决定，可能在后台缓冲区写满或其他条件下触发。</td></tr></tbody></table><p>如果用户没有主动为appendfsync选项设置值，那么appendfsync选项的默认值为everysec，关于appendfsync选项的更多信息，请参考Redis项目附带的示例配置文件redis.conf。</p><p><strong>文件的写入和同步</strong><br>为了提高文件的写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。<br>这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。<br>为此，系统提供了fsync和fdatasync两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p><p><strong>AOF持久化的效率和安全性</strong><br>服务器配置appendfsync选项的值直接决定AOF持久化功能的效率和安全性。</p><ul><li>当appendfsync的值为always时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且同步AOF文件，所以always的效率是appendfsync选项三个值当中最慢的一个，但从安全性来说，always也是最安全的，因为即使出现故障停机，AOF持久化也只会丢失一个事件循环中所产生的命令数据。</li><li>当appendfsync的值为everysec时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。<br>从效率上来讲，everysec模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据。</li><li>当appendfsync的值为no时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。<br>因为处于no模式下的flushAppendOnlyFile调用无须执行同步操作，所以该模式下的AOF文件写入速度总是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看，no模式和everysec模式的效率类似，当出现故障停机时，使用no模式的服务器将丢失上次同步AOF文件之后的所有写命令数据。</li></ul><h3 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h3><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。</p><p>Redis读取AOF文件并还原数据库状态的详细步骤如下：</p><ol><li>创建一个不带网络连接的伪客户端（fake client）：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。</li><li>从AOF文件中分析并读取出一条写命令。</li><li>使用伪客户端执行被读出的写命令。</li><li>一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。</li></ol><h3 id="AOF重写-1"><a href="#AOF重写-1" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大。<br>如果不加以控制的话，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。</p><p>为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写（rewrite）功能。<br>通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小得多。</p><h4 id="AOF文件重写的实现"><a href="#AOF文件重写的实现" class="headerlink" title="AOF文件重写的实现"></a>AOF文件重写的实现</h4><p>虽然Redis将生成新AOF文件替换旧AOF文件的功能命名为“AOF文件重写”，但实际上，AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。<br>AOF重写功能的实现原理是 从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。从而减少新AOF文件的体积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">aof_rewrite</span>(<span class="params">new_aof_file_name</span>):</span><br><span class="line">    <span class="comment"># 创建新 AOF 文件</span></span><br><span class="line">    f = create_file(new_aof_file_name)</span><br><span class="line">    <span class="comment"># 遍历数据库</span></span><br><span class="line">    <span class="keyword">for</span> db <span class="keyword">in</span> redisServer.db:</span><br><span class="line">        <span class="comment"># 忽略空数据库</span></span><br><span class="line">        <span class="keyword">if</span> db.is_empty(): <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 写入SELECT命令，指定数据库号码</span></span><br><span class="line">        f.write_command(<span class="string">&quot;SELECT&quot;</span> + db.<span class="built_in">id</span>)</span><br><span class="line">        <span class="comment"># 遍历数据库中的所有键</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> db:</span><br><span class="line">            <span class="comment"># 忽略已过期的键</span></span><br><span class="line">            <span class="keyword">if</span> key.is_expired(): <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 根据键的类型对键进行重写</span></span><br><span class="line">            <span class="keyword">if</span> key.<span class="built_in">type</span> == String:</span><br><span class="line">                rewrite_string(key)</span><br><span class="line">            <span class="keyword">elif</span> key.<span class="built_in">type</span> == <span class="type">List</span>:</span><br><span class="line">                rewrite_list(key)</span><br><span class="line">            <span class="keyword">elif</span> key.<span class="built_in">type</span> == Hash:</span><br><span class="line">                rewrite_hash(key)</span><br><span class="line">            <span class="keyword">elif</span> key.<span class="built_in">type</span> == <span class="type">Set</span>:</span><br><span class="line">                rewrite_set(key)</span><br><span class="line">            <span class="keyword">elif</span> key.<span class="built_in">type</span> == SortedSet:</span><br><span class="line">                rewrite_sorted_set(key)</span><br><span class="line">            <span class="comment"># 如果键带有过期时间，那么过期时间也要被重写</span></span><br><span class="line">            <span class="keyword">if</span> key.have_expire_time():</span><br><span class="line">                rewrite_expire_time(key)</span><br><span class="line">    <span class="comment"># 写入完毕，关闭文件</span></span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rewrite_string</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 使用GET命令获取字符串键的值</span></span><br><span class="line">    value = GET(key)</span><br><span class="line">    <span class="comment"># 使用SET命令重写字符串键</span></span><br><span class="line">    f.write_command(SET, key, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rewrite_list</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 使用LRANGE命令获取列表键包含的所有元素</span></span><br><span class="line">    item1, item2, ..., itemN = LRANGE(key, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 使用RPUSH命令重写列表键</span></span><br><span class="line">    f.write_command(RPUSH, key, item1, item2, ..., itemN)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rewrite_hash</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 使用HGETALL命令获取哈希键包含的所有键值对</span></span><br><span class="line">    field1, value1, field2, value2, ..., fieldN, valueN = HGETALL(key)</span><br><span class="line">    <span class="comment"># 使用HMSET命令重写哈希键</span></span><br><span class="line">    f.write_command(HMSET, key, field1, value1, field2, value2, ..., fieldN, valueN)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rewrite_set</span>(<span class="params">key</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用SMEMBERS命令获取集合键包含的所有元素</span></span><br><span class="line">elem1, elem2, ..., elemN = SMEMBERS(key)</span><br><span class="line"><span class="comment"># 使用SADD命令重写集合键</span></span><br><span class="line">f.write_command(SADD, key, elem1, elem2, ..., elemN)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rewrite_sorted_set</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 使用ZRANGE命令获取有序集合键包含的所有元素</span></span><br><span class="line">    member1, score1, member2, score2, ..., memberN, scoreN = ZRANGE(key, <span class="number">0</span>, -<span class="number">1</span>, <span class="string">&quot;WITHSCORES&quot;</span>)</span><br><span class="line">    <span class="comment"># 使用ZADD命令重写有序集合键</span></span><br><span class="line">    f.write_command(ZADD, key, score1, member1, score2, member2, ..., scoreN, memberN)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rewrite_expire_time</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 获取毫秒精度的键过期时间戳</span></span><br><span class="line">    timestamp = get_expire_time_in_unixstamp(key)</span><br><span class="line">    <span class="comment"># 使用PEXPIREAT命令重写键的过期时间</span></span><br><span class="line">    f.write_command(PEXPIREAT, key, timestamp)</span><br></pre></td></tr></table></figure><p>因为aof_rewrite函数生成的新AOF文件只包含还原当前数据库状态所必须的命令，所以新AOF文件不会浪费任何硬盘空间。</p><p>在实际中，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果元素的数量超过了redis.h&#x2F;REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令。</p><h4 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h4><p>上面介绍的AOF重写程序aof_rewrite函数可以很好地完成创建一个新AOF文件的任务，但是，因为这个函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞。<br>因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务期将无法处理客户端发来的命令请求。</p><p>很明显，作为一种辅佐性的维护手段，Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放到子进程里执行，这样做可以同时达到两个目的：</p><ul><li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul><p>不过，使用子进程也有一个问题需要解决，因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。<br>为了解决这种数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。</p><p>这也就是说，在子进程执行AOF重写期间，服务器进程需要执行以下三个工作：</p><ol><li>执行客户端发来的命令。</li><li>将执行后的写命令追加到AOF缓冲区。</li><li>将执行后的写命令追加到AOF重写缓冲区。</li></ol><p>这样一来可以保证：</p><ul><li>AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行。</li><li>从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面。</li></ul><p>当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：</p><ol><li>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。</li><li>对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li></ol><p>这个信号处理函数执行完毕之后，父进程就可以继续像往常一样接受命令请求了。<br><strong>在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。</strong></p><h2 id="第十二章-事件"><a href="#第十二章-事件" class="headerlink" title="第十二章 - 事件"></a>第十二章 - 事件</h2><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p><ul><li>文件事件（file event）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ul><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）：</p><ul><li>文件事件处理器使用I&#x2F;O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>虽然文件事件处理器以单线程方式运行，但通过使用I&#x2F;O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p><h4 id="文件事件处理器的构成"><a href="#文件事件处理器的构成" class="headerlink" title="文件事件处理器的构成"></a>文件事件处理器的构成</h4><p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。<br>I&#x2F;O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。<br>尽管多个文件事件可能会并发地出现，但I&#x2F;O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。<br>当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕），I&#x2F;O多路复用程序才会继续向文件事件分派器传送下一个套接字。</p><p>文件事件分派器接收I&#x2F;O多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。<br>服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数，它们定义了某个事件发生时，服务器应该执行的动作。</p><h4 id="I-O多路复用程序的实现"><a href="#I-O多路复用程序的实现" class="headerlink" title="I&#x2F;O多路复用程序的实现"></a>I&#x2F;O多路复用程序的实现</h4><p>Redis的I&#x2F;O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I&#x2F;O多路复用函数库来实现的。<br>每个I&#x2F;O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c，诸如此类。</p><p>因为Redis为每个I&#x2F;O多路复用函数库都实现了相同的API，所以I&#x2F;O多路复用程序的底层实现是可以互换的</p><p>Redis在I&#x2F;O多路复用程序的实现源码中用#include宏定义了相应的规则，程序会在编译时自动选择系统中性能最高的I&#x2F;O多路复用函数库来作为Redis的I&#x2F;O多路复用程序的底层实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Include the best multiplexing layer supported by this system.</span></span><br><span class="line"><span class="comment">  * The following should be ordered by performances, descending. */</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> HAVE_EVPORT</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;ae_evport.c&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">    <span class="meta"># <span class="keyword">ifdef</span> HAVE_EPOLL</span></span><br><span class="line">    <span class="meta"># <span class="keyword">include</span> <span class="string">&quot;ae_epoll.c&quot;</span></span></span><br><span class="line">    <span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">        <span class="meta"># <span class="keyword">ifdef</span> HAVE_KQUEUE</span></span><br><span class="line">        <span class="meta"># <span class="keyword">include</span> <span class="string">&quot;ae_kqueue.c&quot;</span></span></span><br><span class="line">        <span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">        <span class="meta"># <span class="keyword">include</span> <span class="string">&quot;ae_select.c&quot;</span></span></span><br><span class="line">        <span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h4><p>I&#x2F;O多路复用程序可以监听多个套接字的ae.h&#x2F;AE_READABLE事件和ae.h&#x2F;AE_WRITABLE事件，这两类事件和套接字操作之间的对应关系如下：</p><ul><li>当套接字变得可读时（客户端对套接字执行write操作，或者执行close操作），或者有新的可应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行connect操作），套接字产生AE_READABLE事件。</li><li>当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件。</li></ul><p>I&#x2F;O多路复用程序允许服务器同时监听套接字的AE_READABLE事件和AE_WRITABLE事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理AE_READABLE事件，等到AE_READABLE事件处理完之后，才处理AE_WRITABLE事件。<br>这也就是说，如果一个套接字又可读又可写的话，那么服务器将先读套接字，后写套接字。</p><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>ae.c&#x2F;aeCreateFileEvent函数接受一个套接字描述符、一个事件类型，以及一个事件处理器作为参数，将给定套接字的给定事件加入到I&#x2F;O多路复用程序的监听范围之内，并对事件和事件处理器进行关联。<br>ae.c&#x2F;aeDeleteFileEvent函数接受一个套接字描述符和一个监听事件类型作为参数，让I&#x2F;O多路复用程序取消对给定套接字的给定事件的监听，并取消事件和事件处理器之间的关联。<br>ae.c&#x2F;aeGetFileEvents函数接受一个套接字描述符，返回该套接字正在被监听的事件类型：</p><ul><li>如果套接字没有任何事件被监听，那么函数返回AE_NONE。</li><li>如果套接字的读事件正在被监听，那么函数返回AE_READABLE。</li><li>如果套接字的写事件正在被监听，那么函数返回AE_WRITABLE。</li><li>如果套接字的读事件和写事件正在被监听，那么函数返回AE_READABLE|AE_WRITABLE。</li></ul><p>ae.c&#x2F;aeWait函数接受一个套接字描述符、一个事件类型和一个毫秒数为参数，在给定的时间内阻塞并等待套接字的给定类型事件产生，当事件成功产生，或者等待超时之后，函数返回。<br>ae.c&#x2F;aeApiPoll函数接受一个sys&#x2F;time.h&#x2F;struct timeval结构为参数，并在指定的时间內，阻塞并等待所有被aeCreateFileEvent函数设置为监听状态的套接字产生文件事件，当有至少一个事件产生，或者等待超时后，函数返回。<br>ae.c&#x2F;aeProcessEvents函数是文件事件分派器，它先调用aeApiPoll函数来等待事件产生，然后遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件。<br>ae.c&#x2F;aeGetApiName函数返回I&#x2F;O多路复用程序底层所使用的I&#x2F;O多路复用函数库的名称：返回”epoll”表示底层为epoll函数库，返回”select”表示底层为select函数库，诸如此类。</p><h4 id="文件事件的处理器"><a href="#文件事件的处理器" class="headerlink" title="文件事件的处理器"></a>文件事件的处理器</h4><p>Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求，比如说：</p><ul><li>为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器。</li><li>为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器。</li><li>为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器。</li><li>当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器。</li></ul><p>在这些事件处理器里面，服务器最常用的要数与客户端进行通信的连接应答处理器、命令请求处理器和命令回复处理器。</p><p><strong>连接应答处理器</strong><br>networking.c&#x2F;acceptTcpHandler函数是Redis的连接应答处理器，这个处理器用于对连接服务器监听套接字的客户端进行应答，具体实现为sys&#x2F;socket.h&#x2F;accept函数的包装。<br>当Redis服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字的AE_READABLE事件关联起来，当有客户端用sys&#x2F;socket.h&#x2F;connect函数连接服务器监听套接字的时候，套接字就会产生AE_READABLE事件，引发连接应答处理器执行，并执行相应的套接字应答操作。</p><p><strong>命令请求处理器</strong><br>networking.c&#x2F;readQueryFromClient函数是Redis的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令请求内容，具体实现为unistd.h&#x2F;read函数的包装。<br>当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生AE_READABLE事件，引发命令请求处理器执行，并执行相应的套接字读入操作。</p><p><strong>命令回复处理器</strong><br>networking.c&#x2F;sendReplyToClient函数是Redis的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令回复通过套接字返回给客户端，具体实现为unistd.h&#x2F;write函数的包装。<br>当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的AE_WRITABLE事件和命令回复处理器关联起来，当客户端准备好接收服务器传回的命令回复时，就会产生AE_WRITABLE事件，引发命令回复处理器执行，并执行相应的套接字写入操作。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png"                        alt="客户端和服务器的通信过程.png"                 ></p><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>Redis的时间事件分为以下两类：</p><ul><li>定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次。</li><li>周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次。</li></ul><p>一个时间事件主要由以下三个属性组成：</p><ul><li>id：服务器为时间事件创建的全局唯一ID（标识号）。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。</li><li>when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间。</li><li>timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：</p><ul><li>如果事件处理器返回ae.h&#x2F;AE_NOMORE，那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再到达。</li><li>如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。比如说，如果一个时间事件的处理器返回整数值30，那么服务器应该对这个时间事件进行更新，让这个事件在30毫秒之后再次到达。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p><blockquote><p>这里说保存时间事件的链表为无序链表，指的不是链表不按ID排序，而是说，该链表不按when属性的大小排序。正因为链表没有按when属性进行排序，所以当时间事件执行器运行的时候，它必须遍历链表中的所有时间事件，这样才能确保服务器中所有已到达的时间事件都会被处理。<br><strong>无序链表并不影响时间事件处理器的性能</strong></p></blockquote><h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><p>ae.c&#x2F;aeCreateTimeEvent函数接受一个毫秒数milliseconds和一个时间事件处理器proc作为参数。<br>将一个新的时间事件添加到服务器，这个新的时间事件将在当前时间的milliseconds毫秒之后到达，而事件的处理器为proc。</p><p>ae.c&#x2F;aeDeleteFileEvent函数接受一个时间事件ID作为参数，然后从服务器中删除该ID所对应的时间事件。</p><p>ae.c&#x2F;aeSearchNearestTimer函数返回到达时间距离当前时间最接近的那个时间事件。</p><p>ae.c&#x2F;processTimeEvents函数是时间事件的执行器，这个函数会遍历所有已到达的时间事件，并调用这些事件的处理器。<br>已到达指的是，时间事件的when属性记录的UNIX时间戳等于或小于当前时间的UNIX时间戳。</p><h4 id="时间事件应用实例：serverCron函数"><a href="#时间事件应用实例：serverCron函数" class="headerlink" title="时间事件应用实例：serverCron函数"></a>时间事件应用实例：serverCron函数</h4><p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由redis.c&#x2F;serverCron函数负责执行，它的主要工作包括：</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li><li>清理数据库中的过期键值对。</li><li>关闭和清理连接失效的客户端。</li><li>尝试进行AOF或RDB持久化操作。</li><li>如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><p>Redis服务器以周期性事件的方式来运行serverCron函数，在服务器运行期间，每隔一段时间，serverCron就会执行一次，直到服务器关闭为止。</p><p>在Redis2.6版本，服务器默认规定serverCron每秒运行10次，平均每间隔100毫秒运行一次。<br>从Redis2.8开始，用户可以通过修改hz选项来调整serverCron的每秒执行次数，具体信息请参考示例配置文件redis.conf关于hz选项的说明。</p><h3 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h3><p>因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理文件事件，何时又应该处理时间事件，以及花多少时间来处理它们等等。</p><p>事件的调度和执行由ae.c&#x2F;aeProcessEvents函数负责，以下是该函数的伪代码表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">aeProcessEvents</span>():</span><br><span class="line">    <span class="comment"># 获取到达时间离当前时间最接近的时间事件</span></span><br><span class="line">    time_event = aeSearchNearestTimer()</span><br><span class="line">    <span class="comment"># 计算最接近的时间事件距离到达还有多少毫秒</span></span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line">    <span class="comment"># 如果事件已到达，那么remaind_ms的值可能为负数，将它设定为0</span></span><br><span class="line">    <span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">        remaind_ms = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 根据remaind_ms的值，创建timeval结构</span></span><br><span class="line">    timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line">    <span class="comment"># 阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定</span></span><br><span class="line">    <span class="comment"># 如果remaind_ms的值为0，那么aeApiPoll调用之后马上返回，不阻塞</span></span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line">    <span class="comment"># 处理所有已产生的文件事件</span></span><br><span class="line">    processFileEvents()</span><br><span class="line">    <span class="comment"># 处理所有已到达的时间事件</span></span><br><span class="line">    processTimeEvents()</span><br></pre></td></tr></table></figure><p>前面在介绍文件事件API的时候，并没有讲到processFileEvents这个函数，因为它并不存在，在实际中，处理已产生文件事件的代码是直接写在aeProcessEvents函数里面的，这里为了方便讲述，才虚构了processFileEvents函数。</p><p>将aeProcessEvents函数置于一个循环里面，加上初始化和清理函数，这就构成了Redis服务器的主函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 初始化服务器</span></span><br><span class="line">    init_server()</span><br><span class="line">    <span class="comment"># 一直处理事件，直到服务器关闭为止</span></span><br><span class="line">    <span class="keyword">while</span> server_is_not_shutdown():</span><br><span class="line">        aeProcessEvents()</span><br><span class="line">    <span class="comment"># 服务器关闭，执行清理操作</span></span><br><span class="line">    clean_server()</span><br></pre></td></tr></table></figure><p>以下是事件的调度和执行规则：</p><ol><li>aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这个方法既可以避免服务器对时间事件进行频繁的轮询（忙等待），也可以确保aeApiPoll函数不会阻塞过长时间。</li><li>因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件了。</li><li>对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。<br>比如说，在命令回复处理器将一个命令回复写入到客户端套接字时，如果写入字节数超过了一个预设常量的话，命令回复处理器就会主动用break跳出写入循环，将余下的数据留到下次再写；另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。</li><li>因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间稍晚一些。</li></ol><h2 id="第十三章-客户端"><a href="#第十三章-客户端" class="headerlink" title="第十三章 - 客户端"></a>第十三章 - 客户端</h2><p>Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，并向客户端返回命令回复。<br>通过使用由I&#x2F;O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。</p><p>对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis.h&#x2F;redisClient结构（客户端状态），这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构，其中包括：</p><ul><li>客户端的套接字描述符。</li><li>客户端的名字。</li><li>客户端的标志值（flag）。</li><li>指向客户端正在使用的数据库的指针，以及该数据库的号码。</li><li>客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针。</li><li>客户端的输入缓冲区和输出缓冲区。</li><li>客户端的复制状态信息，以及进行复制所需的数据结构。</li><li>客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构。</li><li>客户端的事务状态，以及执行WATCH命令时用到的数据结构。</li><li>客户端执行发布与订阅功能时用到的数据结构。</li><li>客户端的身份验证标志。</li><li>客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制（soft limit）的时间。</li></ul><p>Redis服务器状态结构的clients属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批量操作，或者查找某个指定的客户端，都可以通过遍历clients链表来完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 一个链表，保存了所有客户端状态</span></span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h3><p>客户端状态包含的属性可以分为两类：</p><ul><li>一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，它们都要用到这些属性。</li><li>另外一类是和特定功能相关的属性，比如操作数据库时需要用到的db属性和dictid属性，执行事务时需要用到的mstate属性，以及执行WATCH命令时需要用到的watched_keys属性等等。</li></ul><p>执行<a class="link"   href="https://redis.io/docs/latest/commands/client-list/" >CLIENT list<i class="fas fa-external-link-alt"></i></a>命令可以列出目前所有连接到服务器的普通客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CLIENT list</span><br><span class="line">id=3 addr=172.17.0.1:47759 laddr=172.17.0.2:6379 fd=11 name= age=0 idle=0 flags=N db=0 sub=0 psub=0 ssub=0 multi=-1 watch=0 qbuf=26 qbuf-free=20448 argv-mem=10 multi-mem=0 rbs=1024 rbp=673 obl=0 oll=0 omem=0 tot-mem=22426 events=r cmd=client|list user=default redir=-1 resp=2 lib-name=jedis lib-ver=4.4.3</span><br></pre></td></tr></table></figure><ul><li><strong>id</strong>: 客户端的唯一标识符。</li><li><strong>addr</strong>: 客户端的 IP 地址和端口号。</li><li><strong>laddr</strong>: Redis 服务器本地的 IP 地址和端口号，用于此连接。</li><li><strong>fd</strong>: 客户端连接的文件描述符。</li><li><strong>name</strong>: 客户端名称，默认空白，可通过 <code>CLIENT SETNAME</code> 设置。</li><li><strong>age</strong>: 该连接的持续时间（以秒为单位）。</li><li><strong>idle</strong>: 客户端自上次发出命令后空闲的时间（以秒为单位）。</li><li><strong>flags</strong>: 客户端的标志位。这里的 <code>N</code> 表示普通客户端，未设置特殊标志。</li><li><strong>db</strong>: 客户端正在使用的数据库编号。</li><li><strong>sub</strong>: 该客户端的频道订阅数量。</li><li><strong>psub</strong>: 该客户端的模式订阅数量（订阅模式匹配的通配符频道）。</li><li><strong>ssub</strong>: 共享订阅数量，用于集群环境下的连接共享。</li><li><strong>multi</strong>: 当前事务队列中的命令数量。如果客户端未使用事务，则显示为 <code>-1</code>。</li><li><strong>watch</strong>: 客户端监视的键的数量（事务监视机制）。</li><li><strong>qbuf</strong>: 查询缓冲区的当前长度（字节数）。</li><li><strong>qbuf-free</strong>: 查询缓冲区的空闲空间（字节数）。</li><li><strong>argv-mem</strong>: 命令参数占用的内存量（字节数）。</li><li><strong>multi-mem</strong>: 事务命令队列所占用的内存量（字节数）。</li><li><strong>rbs</strong>: 该客户端的复制缓冲区大小。</li><li><strong>rbp</strong>: 复制缓冲区中的偏移量。</li><li><strong>obl</strong>: 输出缓冲区的长度。</li><li><strong>oll</strong>: 输出缓冲区的链表长度。</li><li><strong>omem</strong>: 输出缓冲区占用的内存量。</li><li><strong>tot-mem</strong>: 客户端连接总占用的内存量。</li><li><strong>events</strong>: 事件标志，<code>r</code> 表示客户端可读。</li><li><strong>cmd</strong>: 客户端最后执行的命令。</li><li><strong>user</strong>: 客户端认证的用户名（这里为 <code>default</code>）。</li><li><strong>redir</strong>: 当前客户端重定向的目标（<code>-1</code> 表示未重定向）。</li><li><strong>resp</strong>: 客户端使用的 RESP 协议版本。</li><li><strong>lib-name</strong>: 客户端连接库的名称（例如 <code>jedis</code>）。</li><li><strong>lib-ver</strong>: 客户端库的版本（例如 <code>4.4.3</code>）。</li></ul><p>下面就不放书中所列举的各属性的含义了，只取部分解释，因为书中使用的Redis版本较老，部分已经更改或弃用了。需要最新的还是得看官方文档（很全）。</p><p>其中，客户端标识 flags 可以是以下组合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A: connection to be closed ASAP</span><br><span class="line">b: the client is waiting in a blocking operation</span><br><span class="line">c: connection to be closed after writing entire reply</span><br><span class="line">d: a watched keys has been modified - EXEC will fail</span><br><span class="line">e: the client is excluded from the client eviction mechanism</span><br><span class="line">i: the client is waiting for a VM I/O (deprecated)</span><br><span class="line">M: the client is a master</span><br><span class="line">N: no specific flag set</span><br><span class="line">O: the client is a client in MONITOR mode</span><br><span class="line">P: the client is a Pub/Sub subscriber</span><br><span class="line">r: the client is in readonly mode against a cluster node</span><br><span class="line">S: the client is a replica node connection to this instance</span><br><span class="line">u: the client is unblocked</span><br><span class="line">U: the client is connected via a Unix domain socket</span><br><span class="line">x: the client is in a MULTI/EXEC context</span><br><span class="line">t: the client enabled keys tracking in order to perform client side caching</span><br><span class="line">T: the client will not touch the LRU/LFU of the keys it accesses</span><br><span class="line">R: the client tracking target client is invalid</span><br><span class="line">B: the client enabled broadcast tracking mode </span><br></pre></td></tr></table></figure><p><strong><code>PUBSUB</code>命令和<code>SCRIPT LOAD</code>命令的特殊性</strong><br>通常情况下，Redis只会将那些对数据库进行了修改的命令写入到AOF文件，并复制到各个从服务器。<strong>如果一个命令没有对数据库进行任何修改，那么它就会被认为是只读命令，这个命令不会被写入到AOF文件，也不会被复制到从服务器。</strong></p><p>以上规则适用于绝大部分Redis命令，但<code>PUBSUB</code>命令和<code>SCRIPT LOAD</code>命令是其中的例外。<br>PUBSUB命令虽然没有修改数据库，但PUBSUB命令向频道的所有订阅者发送消息这一行为带有副作用，接收到消息的所有客户端的状态都会因为这个命令而改变。<br>因此，在<strong>早期版本</strong>服务器需要使用<code>REDIS_FORCE_AOF</code>标志，强制将这个命令写入AOF文件，这样在将来载入AOF文件时，服务器就可以再次执行相同的PUBSUB命令，并产生相同的副作用。<br><code>SCRIPT LOAD</code>命令的情况与<code>PUBSUB</code>命令类似：虽然<code>SCRIPT LOAD</code>命令没有修改数据库，但它修改了服务器状态，所以它是一个带有副作用的命令，服务器需要使用<code>REDIS_FORCE_AOF</code>标志，强制将这个命令写入AOF文件，使得将来在载入AOF文件时，服务器可以产生相同的副作用。<br>另外，为了让主服务器和从服务器都可以正确地载入<code>SCRIPT LOAD</code>命令指定的脚本，服务器需要使用<code>REDIS_FORCE_REPL</code>标志，强制将<code>SCRIPT LOAD</code>命令复制给所有从服务器。</p><p>关于Redis主从复制可以参考这几篇文章：<br><a class="link"   href="https://redis.io/docs/latest/operate/oss_and_stack/management/replication" >Redis replication<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://blog.csdn.net/Seky_fei/article/details/106877329" >Redis主从同步原理、及SYNC和PSYNC同步区别<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://cloud.tencent.com/developer/article/2297090" >Redis:发布订阅(pub&#x2F;sub)的实现原理及避坑场景<i class="fas fa-external-link-alt"></i></a></p><h3 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h3><p>服务器使用不同的方式来创建和关闭不同类型的客户端。</p><h4 id="创建普通客户端"><a href="#创建普通客户端" class="headerlink" title="创建普通客户端"></a>创建普通客户端</h4><p>如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾。</p><h4 id="关闭普通客户端"><a href="#关闭普通客户端" class="headerlink" title="关闭普通客户端"></a>关闭普通客户端</h4><p>一个普通客户端可以因为多种原因而被关闭：</p><ul><li>如果客户端进程退出或者被杀死，那么客户端与服务器之间的网络连接将被关闭，从而造成客户端被关闭。</li><li>如果客户端向服务器发送了带有不符合协议格式的命令请求，那么这个客户端也会被服务器关闭。</li><li>如果客户端成为了<code>CLIENT KILL</code>命令的目标，那么它也会被关闭。</li><li>如果用户为服务器设置了timeout配置选项，那么当客户端的空转时间超过timeout选项设置的值时，客户端将被关闭。<br>不过timeout选项有一些例外情况：如果客户端是主服务器（打开了REDIS_MASTER标志），从服务器（打开了REDIS_SLAVE标志），正在被<code>BLPOP</code>等命令阻塞（打开了REDIS_BLOCKED标志），或者正在执行<code>SUBSCRIBE</code>、<code>PSUBSCRIBE</code>等订阅命令，那么即使客户端的空转时间超过了timeout选项的值，客户端也不会被服务器关闭。</li><li>如果客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为1 GB），那么这个客户端会被服务器关闭。</li><li>如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小，那么这个客户端会被服务器关闭。</li></ul><p>前面介绍输出缓冲区的时候提到过，可变大小缓冲区由一个链表和任意多个字符串对象组成，理论上来说，这个缓冲区可以保存任意长的命令回复。<br>但是，为了避免客户端的回复过大，占用过多的服务器资源，服务器会时刻检查客户端的输出缓冲区的大小，并在缓冲区的大小超出范围时，执行相应的限制操作。</p><p>服务器使用两种模式来限制客户端输出缓冲区的大小：</p><ul><li>硬性限制（hard limit）：如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。</li><li>软性限制（soft limit）：如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制，那么服务器将使用客户端状态结构的obuf_soft_limit_reached_time属性记录下客户端到达软性限制的起始时间；<br>之后服务器会继续监视客户端，如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端；相反地，如果输出缓冲区的大小在指定时间之内，不再超出软性限制，那么客户端就不会被关闭，并且obuf_soft_limit_reached_time属性的值也会被清零。</li></ul><p>使用<a class="link"   href="https://redis.io/docs/latest/develop/reference/clients/" >client-output-buffer-limit<i class="fas fa-external-link-alt"></i></a>选项可以为普通客户端、从服务器客户端、执行发布与订阅功能的客户端分别设置不同的软性限制和硬性限制。<br><code>client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</code></p><h4 id="Lua脚本的伪客户端"><a href="#Lua脚本的伪客户端" class="headerlink" title="Lua脚本的伪客户端"></a>Lua脚本的伪客户端</h4><p>服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    redisClient *lua_client;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>lua_client伪客户端在服务器运行的整个生命期中会一直存在，只有服务器被关闭时，这个客户端才会被关闭。</p><h4 id="AOF文件的伪客户端"><a href="#AOF文件的伪客户端" class="headerlink" title="AOF文件的伪客户端"></a>AOF文件的伪客户端</h4><p>服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端。</p><h2 id="第十四章-服务器"><a href="#第十四章-服务器" class="headerlink" title="第十四章 - 服务器"></a>第十四章 - 服务器</h2><p>Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。</p><h3 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h3><p>从客户端发送SET KEY VALUE命令到获得回复OK期间，客户端和服务器共需要执行以下操作：</p><ol><li>客户端向服务器发送命令请求SET KEY VALUE。<br>Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器。</li><li>服务器接收并处理客户端发来的命令请求<code>SET KEY VALUE</code>，在数据库中进行设置操作，并产生命令回复OK。<br>当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作：<ol><li>读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。</li><li>对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。</li><li>调用命令执行器，执行客户端指定的命令。<ol><li>命令执行器（1）：查找命令实现<br>命令执行器要做的第一件事就是根据客户端状态的<code>argv[0]</code>参数，在命令表（command table）中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里面。<br>命令表是一个字典，字典的键是一个个命令名字，比如”set”、”get”、”del”等等；而字典的值则是一个个redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息。</li><li>命令执行器（2）：执行预备操作<br>到目前为止，服务器已经将执行命令所需的命令实现函数（保存在客户端状态的cmd属性）、参数（保存在客户端状态的argv属性）、参数个数（保存在客户端状态的argc属性）都收集齐了，但是在真正执行命令之前，程序还需要进行一些预备操作，从而确保命令可以正确、顺利地被执行，这些操作包括：<ul><li>检查客户端状态的cmd指针是否指向NULL，如果是的话，那么说明用户输入的命令名字找不到相应的命令实现，服务器不再执行后续步骤，并向客户端返回一个错误。</li><li>根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确，当参数个数不正确时，不再执行后续步骤，直接向客户端返回一个错误。比如说，如果redisCommand结构的arity属性的值为-3，那么用户输入的命令参数个数必须大于等于3个才行。</li><li>检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行AUTH命令，如果未通过身份验证的客户端试图执行除AUTH命令之外的其他命令，那么服务器将向客户端返回一个错误。</li><li>如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行。如果内存回收失败，那么不再执行后续步骤，向客户端返回一个错误。</li><li>如果服务器上一次执行BGSAVE命令时出错，并且服务器打开了stop-writes-on-bgsave-error功能，而且服务器即将要执行的命令是一个写命令，那么服务器将拒绝执行这个命令，并向客户端返回一个错误。</li><li>如果客户端当前正在用SUBSCRIBE命令订阅频道，或者正在用PSUBSCRIBE命令订阅模式，那么服务器只会执行客户端发来的SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE四个命令，其他命令都会被服务器拒绝。</li><li>如果服务器正在进行数据载入，那么客户端发送的命令必须带有l标识（比如INFO、SHUTDOWN、PUBLISH等等）才会被服务器执行，其他命令都会被服务器拒绝。</li><li>如果服务器因为执行Lua脚本而超时并进入阻塞状态，那么服务器只会执行客户端发来的SHUTDOWN nosave命令和SCRIPT KILL命令，其他命令都会被服务器拒绝。</li><li>如果客户端正在执行事务，那么服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH四个命令，其他命令都会被放进事务队列中。</li><li>如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器。当完成了以上预备操作之后，服务器就可以开始真正执行命令了。</li></ul></li><li>命令执行器（3）：调用命令的实现函数<br>服务器已经将要执行命令的实现保存到了客户端状态的cmd属性里面，并将命令的参数和参数个数分别保存到了客户端状态的argv属性和argv属性里面，当服务器决定要执行命令时，只需要调用cmd指针的proc(client)函数即可。<br>因为执行命令所需的实际参数都已经保存到客户端状态的argv属性里面了，所以命令的实现函数只需要一个指向客户端状态的指针作为参数即可。<br>被调用的命令实现函数会执行指定的操作，并产生相应的命令回复，这些回复会被保存在客户端状态的输出缓冲区里面（buf属性和reply属性），之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将命令回复返回给客户端。<br>对于前面SET命令的例子来说，函数调用setCommand（client）将产生一个”+OK\r\n”回复，这个回复会被保存到客户端状态的buf属性里面。</li><li>命令执行器（4）：执行后续工作<br>在执行完实现函数之后，服务器还需要执行一些后续工作：<ul><li>如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。</li><li>根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。</li><li>如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里面。</li><li>如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。</li></ul></li></ol></li></ol></li><li>将命令回复发送给客户端。<br>命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端。</li><li>客户端接收并打印命令回复。<br>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户观看（假设我们使用的是Redis自带的redis-cli客户端。</li></ol><h3 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h3><p>Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。</p><p><code>serverCron</code> 是 Redis 的核心函数之一，它负责定期执行一系列后台任务来确保 Redis 服务器的正常运行。这个函数通常每 100 毫秒执行一次，由 Redis 的事件处理机制触发。它在 Redis 的主事件循环中扮演着关键角色。<br><code>serverCron</code> 函数的设计目标是将服务器的维护任务和客户请求的处理分开，并通过定时任务来管理服务器的内部状态。</p><p>a) 客户端超时管理 (<code>clientTimeout</code>)</p><ul><li>Redis 会检查每个客户端的空闲时间 (<code>idle</code>)，如果客户端空闲超过指定的超时时间（通常是 0 表示不限制），则关闭这些连接，释放资源。这可以防止大量的空闲连接消耗内存和资源。</li><li>例如，Redis 会定期扫描所有客户端，关闭超时的连接。客户端的状态被记录在 <code>client</code> 结构体中，包括它的活动时间等。</li></ul><p>b) 过期键处理</p><ul><li>Redis 通过扫描数据库中的键来检查和删除过期的键。<code>serverCron</code> 会定期触发过期键的清理操作，尤其是检查那些通过 <code>EXPIRE</code> 设置了过期时间的键。</li><li>Redis 采用两种过期处理方式：<ol><li>惰性删除：每次访问键时检查是否过期，如果过期则删除。</li><li>定期删除：定期触发 <code>serverCron</code> 扫描所有数据库，删除过期的键。</li></ol></li></ul><p>c) 主从复制管理</p><ul><li><code>serverCron</code> 还会管理主从复制的相关操作，如检查主服务器与从服务器的状态、处理复制偏移量等。若发生故障，它也会发起故障切换操作。</li><li>在哨兵模式下，它还负责与哨兵协调，检查主节点是否宕机，是否需要执行故障转移。</li></ul><p>d) 内存管理</p><ul><li>Redis 允许配置内存限制，当 Redis 使用的内存超过限制时，它会尝试执行内存回收操作。<code>serverCron</code> 会定期触发内存逐出操作（如 LRU，LFU 策略）。</li><li>它会定期检查当前的内存使用情况，并触发后台的内存清理过程，按照配置的逐出策略删除不再需要的键。</li></ul><p>e) AOF 和 RDB 持久化</p><ul><li><code>serverCron</code> 还负责触发 AOF 文件的同步、AOF 重写（如果开启了 <code>appendonly</code> 配置）和 RDB 快照保存（如果开启了 <code>save</code> 配置）。</li><li>在每次 <code>serverCron</code> 执行时，它会检查是否需要进行 AOF 和 RDB 的操作。例如，如果上次 AOF 重写时间间隔太长，或是内存达到一定阈值时，可能会触发 AOF 文件的重写操作。</li></ul><p>f) 集群维护</p><ul><li>在 Redis 集群模式下，<code>serverCron</code> 会定期检查集群节点的状态。它会周期性地向集群中的其他节点发送心跳检测请求，确保节点间的连接是活跃的。</li><li>在集群环境下，<code>serverCron</code> 也负责检查各节点的分片数据，处理分片重分配等操作。</li></ul><p>g) 统计信息更新</p><ul><li>每次执行 <code>serverCron</code> 时，Redis 会更新一些运行时的统计信息，如内存使用情况、命令执行次数、客户端数量等。这些信息对运维监控和性能分析非常重要。</li></ul><p>h) Lua 脚本处理</p><ul><li>Redis 支持 Lua 脚本，<code>serverCron</code> 会检查当前正在执行的 Lua 脚本。如果脚本执行超时，它会中断脚本执行，并返回错误。</li></ul><h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>一个Redis服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程，比如初始化服务器状态，接受用户指定的服务器配置，创建相应的数据结构和网络连接等等。</p><h4 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h4><p>初始化服务器的第一步就是创建一个<code>struct redisServer</code>类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值。<br>初始化server变量的工作由redis.c&#x2F;initServerConfig函数完成</p><p>以下是initServerConfig函数完成的主要工作：</p><ul><li>设置服务器的运行ID。</li><li>设置服务器的默认运行频率。</li><li>设置服务器的默认配置文件路径。</li><li>设置服务器的运行架构。</li><li>设置服务器的默认端口号。</li><li>设置服务器的默认RDB持久化条件和AOF持久化条件。</li><li>初始化服务器的LRU时钟。</li><li>创建命令表。</li></ul><h4 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h4><p>在启动服务器时，用户可以通过给定配置参数或者指定配置文件来修改服务器的默认配置。</p><ul><li>如果用户为这些属性的相应选项指定了新的值，那么服务器就使用用户指定的值来更新相应的属性。</li><li>如果用户没有为属性的相应选项设置新的值，那么服务器就沿用之前initServerConfig函数为属性设置的默认值。</li></ul><h4 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h4><p>在之前执行initServerConfig函数初始化server状态时，程序只创建了命令表一个数据结构，不过除了命令表之外，服务器状态还包含其他数据结构，比如：</p><ul><li>server.clients链表，这个链表记录了所有与服务器相连的客户端的状态结构，链表的每个节点都包含了一个redisClient结构实例。</li><li>server.db数组，数组中包含了服务器的所有数据库。</li><li>用于保存频道订阅信息的server.pubsub_channels字典，以及用于保存模式订阅信息的server.pubsub_patterns链表。</li><li>用于执行Lua脚本的Lua环境server.lua。</li><li>用于保存慢查询日志的server.slowlog属性。</li></ul><p>当初始化服务器进行到这一步，服务器将调用initServer函数，为以上提到的数据结构分配内存，并在有需要时，为这些数据结构设置或者关联初始化值。<br>服务器到现在才初始化数据结构的原因在于，服务器必须先载入用户指定的配置选项，然后才能正确地对数据结构进行初始化。<br>如果在执行initServerConfig函数时就对数据结构进行初始化，那么一旦用户通过配置选项修改了和数据结构有关的服务器状态属性，服务器就要重新调整和修改已创建的数据结构。<br>为了避免出现这种麻烦的情况，服务器选择了将server状态的初始化分为两步进行，initServerConfig函数主要负责初始化一般属性，而initServer函数主要负责初始化数据结构。</p><p>除了初始化数据结构之外，initServer还进行了一些非常重要的设置操作，其中包括：</p><ul><li>为服务器设置进程信号处理器。</li><li>创建共享对象：这些对象包含Redis服务器经常用到的一些值，比如包含”OK”回复的字符串对象，包含”ERR”回复的字符串对象，包含整数1到10000的字符串对象等等，服务器通过重用这些共享对象来避免反复创建相同的对象。</li><li>打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接受客户端的连接。</li><li>为serverCron函数创建时间事件，等待服务器正式运行时执行serverCron函数。</li><li>如果AOF持久化功能已经打开，那么打开现有的AOF文件，如果AOF文件不存在，那么创建并打开一个新的AOF文件，为AOF写入做好准备。</li><li>初始化服务器的后台I&#x2F;O模块（bio），为将来的I&#x2F;O操作做好准备。</li></ul><p>当initServer函数执行完毕之后，服务器将用ASCII字符在日志中打印出Redis的图标，以及Redis的版本号信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">2024-11-13T01:58:13.881201049Z                 _._                                                  </span><br><span class="line">2024-11-13T01:58:13.881203185Z            _.-``__ &#x27;&#x27;-._                                             </span><br><span class="line">2024-11-13T01:58:13.881204638Z       _.-``    `.  `_.  &#x27;&#x27;-._           Redis Community Edition      </span><br><span class="line">2024-11-13T01:58:13.881205864Z   .-`` .-```.  ```\/    _.,_ &#x27;&#x27;-._     7.4.1 (00000000/0) 64 bit</span><br><span class="line">2024-11-13T01:58:13.881207186Z  (    &#x27;      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="line">2024-11-13T01:58:13.881208407Z  |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;|     Port: 6379</span><br><span class="line">2024-11-13T01:58:13.881209585Z  |    `-._   `._    /     _.-&#x27;    |     PID: 1</span><br><span class="line">2024-11-13T01:58:13.881210759Z   `-._    `-._  `-./  _.-&#x27;    _.-&#x27;                                   </span><br><span class="line">2024-11-13T01:58:13.881211947Z  |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line">2024-11-13T01:58:13.881213124Z  |    `-._`-._        _.-&#x27;_.-&#x27;    |           https://redis.io       </span><br><span class="line">2024-11-13T01:58:13.881214326Z   `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line">2024-11-13T01:58:13.881215484Z  |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line">2024-11-13T01:58:13.881216637Z  |    `-._`-._        _.-&#x27;_.-&#x27;    |                                  </span><br><span class="line">2024-11-13T01:58:13.881217812Z   `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line">2024-11-13T01:58:13.881218989Z       `-._    `-.__.-&#x27;    _.-&#x27;                                       </span><br><span class="line">2024-11-13T01:58:13.881220151Z           `-._        _.-&#x27;                                           </span><br><span class="line">2024-11-13T01:58:13.881221346Z               `-.__.-&#x27;                                               </span><br><span class="line">2024-11-13T01:58:13.881222564Z </span><br><span class="line">2024-11-13T01:58:13.883108976Z 1:M 13 Nov 2024 01:58:13.883 * Server initialized</span><br></pre></td></tr></table></figure><h4 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h4><p>在完成了对服务器状态server变量的初始化之后，服务器需要载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态。<br>根据服务器是否启用了AOF持久化功能，服务器载入数据时所使用的目标文件会有所不同：</p><ul><li>如果服务器启用了AOF持久化功能，那么服务器使用AOF文件来还原数据库状态。</li><li>相反地，如果服务器没有启用AOF持久化功能，那么服务器使用RDB文件来还原数据库状态。</li></ul><p>当服务器完成数据库状态还原工作之后，服务器将在日志中打印出载入文件并还原数据库状态所耗费的时长。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2024-11-13T01:58:13.883532676Z 1:M 13 Nov 2024 01:58:13.883 * Loading RDB produced by version 7.4.1</span><br><span class="line">2024-11-13T01:58:13.883543863Z 1:M 13 Nov 2024 01:58:13.883 * RDB age 169350 seconds</span><br><span class="line">2024-11-13T01:58:13.883545635Z 1:M 13 Nov 2024 01:58:13.883 * RDB memory usage when created 1.16 Mb</span><br><span class="line">2024-11-13T01:58:13.883549523Z 1:M 13 Nov 2024 01:58:13.883 * Done loading RDB, keys loaded: 1, keys expired: 0.</span><br><span class="line">2024-11-13T01:58:13.883742175Z 1:M 13 Nov 2024 01:58:13.883 * DB loaded from disk: 0.000 seconds</span><br></pre></td></tr></table></figure><h4 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h4><p>在初始化的最后一步，服务器将打印出以下日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024-11-13T01:58:13.883757032Z 1:M 13 Nov 2024 01:58:13.883 * Ready to accept connections tcp</span><br></pre></td></tr></table></figure><p>并开始执行服务器的事件循环（loop）。<br>至此，服务器的初始化工作圆满完成，服务器现在开始可以接受客户端的连接请求，并处理客户端发来的命令请求了。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>至此，这本书已经读完一半了。剩下还有两部分，多机数据库的实现（第十五至十七章）和独立功能的实现（第十八至第二十四章）。<br>由于这本书是16年出版的，所使用的redis版本为2.9 ，而我测试使用的redis版本为7.4<br>经过近十年的更新，书中很多api和参数可能已经变化或弃用。不过整体架构肯定是一脉相承的。<br>所以这本书的阅读就到这里了。</p><p>最后，技术相关书籍的阅读学习还是要找近两三年出版的比较好。<br>特别是关于实现方面，涉及大量需要实际搭环境验证的场景，过时的内容非常影响阅读。另外，非常推荐阅读官方文档，<a class="link"   href="https://redis.io/docs/latest/" >Redis官方文档<i class="fas fa-external-link-alt"></i></a>还是挺详细的，还有AI式的搜索。<br>但是关于设计方面，思想不会过时，架构则是根据实际需要去设计调整。那么这本书还是值得一看的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第九章-数据库&quot;&gt;&lt;a href=&quot;#第九章-数据库&quot; class=&quot;headerlink&quot; title=&quot;第九章 - 数据库&quot;&gt;&lt;/a&gt;第九章 - 数据库&lt;/h2&gt;&lt;h3 id=&quot;服务器中的数据库&quot;&gt;&lt;a href=&quot;#服务器中的数据库&quot; class=&quot;head</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://cooooing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Redis" scheme="https://cooooing.github.io/tags/Redis/"/>
    
    <category term="数据库" scheme="https://cooooing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="《Redis设计与实现》" scheme="https://cooooing.github.io/tags/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Redis设计与实现》读书笔记-数据结构与对象</title>
    <link href="https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/</id>
    <published>2024-10-27T05:19:58.000Z</published>
    <updated>2024-10-27T05:19:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有点遗憾，梁敬彬和梁敬弘老师关于数据库的第二本佳作《收获，不止SQl优化》短期内可能不会去看了。<br>正如老师在《收获，不止Oracle》第一章中所写，数据库是个庞大的体系，应该根据自己的需求去学习。<br>目前看来，时机未到。我需要更多的积累之后，再去阅读关于SQL优化的书。毕竟没有足够的使用经验，很难达到“哦，原来可以这么优化”的顿悟的感觉。<br>所以暂且搁置。开始 Redis 的学习，知识的广度也很重要。</p><p>《Redis设计与实现》第一部分：数据结构与对象包含第2-8章。第一章是引言，介绍书的大概结构和阅读顺序，这里省略。</p><h2 id="第二章-简单动态字符串"><a href="#第二章-简单动态字符串" class="headerlink" title="第二章 - 简单动态字符串"></a>第二章 - 简单动态字符串</h2><p>Redis 没有直接使用 C 语言传统的字符串（以空字符结尾的字符数组），而是自己实现了一种新的字符串类型，叫做简单动态字符串，简称<br>SDS（Simple Dynamic String）。并使用 SDS 来作为 Redis 的默认字符串表示。<br>Redis 中在一些无需对字符串进行修改的地方会使用C字符串作为字符串字面量（string literal），比如打印日志等。<br>而在需要修改字符串时，会使用 SDS 表示字符串值。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set msg &quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>Redis 会在数据库中创建一个键值对，键是一个 SDS 对象，保存着字符串 “msg”，值也是一个 SDS 对象，保存着字符串 “hello world”。</p><p>除了用来保存数据库中的字符串值之外，SDS 还被用作缓冲区(buffer):AOF 模块中的 AOF 缓冲区，以及客户端状态中的输入缓冲区，都是由<br>SDS 实现的。</p><h3 id="SDS-的定义"><a href="#SDS-的定义" class="headerlink" title="SDS 的定义"></a>SDS 的定义</h3><p>每个sds.h&#x2F;sdshdr结构表示一个SDS值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// 记录 buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/SDS%E7%A4%BA%E4%BE%8B.png"                        alt="SDS示例.png"                 ></p><p>上面是一个 SDS 的示例，其中</p><ul><li>free 属性为 0，表示 SDS 没有分配任何未使用空间</li><li>len 属性为 5，表示 SDS 保存了一个 5 字节长的字符串</li><li>buf 属性是一个<strong>字节数组</strong>，数组中保存着字符串 “hello” 的五个字节和最后一个空字符 ‘\0’</li></ul><p>SDS 遵循 C 字符串以空字符结尾的惯例，保存空字符的 1 字节空间不计算在 SDS 的 len 属性里面。<br>并且为空字符分配额外的 1 字节空间，以及添加空字符到字符串末尾等操作，都是由 SDS 函数自动完成的，所以这个空字符对于 SDS<br>的使用者来说是完全透明的。<br>遵循空字符结尾这一惯例的好处是，SDS 可以直接重用一部分 C 字符串函数库里面的函数。而无需为 SDS 做任何额外的工作。</p><p>下面这个 SDS 和之前展示的 SDS 的区别在于，这个 SDS 为 buf 数组分配了五字节未使用空间，所以它的 free 属性的值为 5</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/%E5%B8%A6%E6%9C%89%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%A9%BA%E9%97%B4%E7%9A%84SDS%E7%A4%BA%E4%BE%8B.png"                        alt="带有未使用空间的SDS示例.png"                 ></p><p>后面介绍 free 空间在 SDS 中的作用。</p><h3 id="SDS-与-C-字符串的区别"><a href="#SDS-与-C-字符串的区别" class="headerlink" title="SDS 与 C 字符串的区别"></a>SDS 与 C 字符串的区别</h3><p>根据传统，C 语言使用长度为 N+1 的字符数组来表示长度为 N 的字符串，并且字符数组的最后一个元素总是空字符’\0’。</p><p><strong>常数复杂度获取字符串长度</strong><br>因为 C 字符串并不记录自身的长度信息，所以为了获取一个 C 字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为O（N）。<br>和 C 字符串不同，因为 SDS 在 len 属性中记录了 SDS 本身的长度，所以获取一个 SDS 长度的复杂度仅为O（1）。<br>设置和更新 SDS 长度的工作是由 SDS 的 API 在执行时自动完成的，使用 SDS 无须进行任何手动修改长度的工作。</p><p><strong>杜绝缓冲区溢出</strong><br>除了获取字符串长度的复杂度高之外，C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）。<br>举个例子，&lt;string.h&gt;&#x2F;strcat 函数可以将 src 字符串中的内容拼接到 dest 字符串的末尾。<br>因为 C 字符串不记录自身的长度，所以 strcat 假定用户在执行这个函数时，已经为 dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而一旦这个假定不成立时，就会产生缓冲区溢出。</p><p>而当 SDS API 需要对 SDS 进行修改时，API 会先检查 SDS 的空间是否满足修改所需的要求，如果不满足的话，API 会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出问题。</p><p><strong>减少修改字符串时带来的内存重分配次数</strong><br>因为 C 字符串并不记录自身的长度，所以对于一个包含了 N 个字符的 C 字符串来说，这个 C 字符串的底层实现总是一个 N+1 个字符长的数组（额外的一个字符空间用于保存空字符）。<br>因为 C 字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个 C 字符串，程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作：</p><ul><li>如果程序执行的是增长字符串的操作，比如拼接操作（append），那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步就会产生缓冲区溢出。</li><li>如果程序执行的是缩短字符串的操作，比如截断操作（trim），那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生内存泄漏。</li></ul><p>因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作。<br>由于 Redis 对性能的要求非常高，经常被用于数据频繁修改的场合。所以是不能接受每次修改字符串都需要进行内存重分配操作的。</p><p>SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联：在 SDS 中，buf 数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由 SDS 的 free 属性记录。<br>通过未使用空间，SDS 实现了空间预分配和惰性空间释放两种优化策略。</p><ol><li>空间预分配<br>空间预分配用于优化 SDS 的字符串增长操作：当 SDS 的 API 对一个 SDS 进行修改，并且需要对 SDS 进行空间扩展的时候，程序不仅会为 SDS 分配修改所必须要的空间，还会为 SDS 分配额外的未使用空间。<br>额外分配的未使用空间数量由以下公式决定，这样可以减少连续修改字符串所需的内存重分配次数：<ul><li>如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。举个例子，如果进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1&#x3D;27字节（额外的一字节用于保存空字符）。</li><li>如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。举个例子，如果进行修改之后，SDS的len将变成30MB，那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB+1MB+1byte。</li></ul></li><li>惰性空间释放<br>惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。<br>通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。<br>SDS也提供了相应的API，可以在有需要时，真正地释放SDS的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。</li></ol><p><strong>二进制安全</strong><br>C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。</p><p>虽然数据库一般用于保存文本数据，但使用数据库来保存二进制数据的场景也不少见。<br>因此，为了确保Redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的（binary-safe）。<br>所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样。<br>这也是SDS的buf属性被称为字节数组的原因——Redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据。</p><p><strong>兼容部分C字符串函数</strong><br>虽然SDS的API都是二进制安全的，但它们一样遵循C字符串以空字符结尾的惯例：这些API总会将SDS保存的数据的末尾设置为空字符，并且总会在为buf数组分配空间时多分配一个字节来容纳这个空字符，这是为了让那些保存文本数据的SDS可以重用一部分&lt;string.h&gt;库定义的函数。</p><h3 id="SDS-API"><a href="#SDS-API" class="headerlink" title="SDS API"></a>SDS API</h3><p>SDS 主要操作 API</p><table><thead><tr><th><strong>API</strong></th><th><strong>作用</strong></th><th><strong>时间复杂度</strong></th></tr></thead><tbody><tr><td><code>sdsnew</code></td><td>创建一个包含给定 C 字符串的 SDS</td><td>O(M)，M 为给定 C 字符串的长度</td></tr><tr><td><code>sdsempty</code></td><td>创建一个空的 SDS</td><td>O(1)</td></tr><tr><td><code>sdsfree</code></td><td>释放给定的 SDS</td><td>O(1)，只是释放内存</td></tr><tr><td><code>sdslen</code></td><td>返回 SDS 的已使用空间字节数</td><td>O(1)，直接读取元数据</td></tr><tr><td><code>sdsavail</code></td><td>返回 SDS 的剩余可用空间字节数</td><td>O(1)，直接读取元数据</td></tr><tr><td><code>sdsdup</code></td><td>创建一个给定 SDS 的副本</td><td>O(M)，M 为给定 SDS 的长度</td></tr><tr><td><code>sdsclear</code></td><td>清空 SDS 保存的字符串内容</td><td>O(1)，保留空间，不释放内存</td></tr><tr><td><code>sdscat</code></td><td>将给定 C 字符串拼接到 SDS 字符串的末尾</td><td>O(M)，M 为被拼接 C 字符串的长度</td></tr><tr><td><code>sdscatsds</code></td><td>将给定 SDS 字符串拼接到另一个 SDS 字符串的末尾</td><td>O(M)，M 为被拼接 SDS 字符串的长度</td></tr><tr><td><code>sdscpy</code></td><td>将给定的 C 字符串复制到 SDS 中，覆盖 SDS 原有的字符串</td><td>O(N)，N 为被复制 C 字符串的长度</td></tr><tr><td><code>sdsgrowzero</code></td><td>扩展 SDS 到指定长度，如果长度变大，则在新增空间中填充零字符</td><td>O(M)，M 为扩展新增的字节数</td></tr><tr><td><code>sdssubstr</code></td><td>保留 SDS 给定区间内的数据，不在区间内的数据会被覆盖或删除</td><td>O(N)，N 为被保留数据的字节数</td></tr><tr><td><code>sdstrim</code></td><td>移除 SDS 中所有在给定 C 字符串中出现过的字符</td><td>O(M)，M 为给定 C 字符串的长度</td></tr><tr><td><code>sdscmp</code></td><td>比较两个 SDS 字符串是否相同</td><td>O(N)，N 为两个 SDS 中较短的那个的长度</td></tr></tbody></table><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS（Simple Dynamic String，简单动态字符串）作为字符串表示。</p><p>这里对字符串的包装，跟很多其他语言中的字符串类似。不过大部分语言中的字符串是不可变的。<br>可能和 go 中数组更类似，使用 make 来创建，可以传两个整型，第一个是长度，第二个是容量。</p><h2 id="第三章-链表"><a href="#第三章-链表" class="headerlink" title="第三章 - 链表"></a>第三章 - 链表</h2><p>链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。<br>作为一种常用数据结构，链表内置在很多高级的编程语言里面，因为Redis使用的C语言并没有内置这种数据结构，所以Redis构建了自己的链表实现。<br>链表在Redis中的应用非常广泛，比如列表键的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。<br>除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，Redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区（output buffer）</p><h3 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h3><p>每个链表节点使用一个adlist.h&#x2F;listNode结构来表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> * value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure><p>多个listNode可以通过prev和next指针组成双端链表，如下图</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/%E7%94%B1%E5%A4%9A%E4%B8%AAlistNode%E7%BB%84%E6%88%90%E7%9A%84%E5%8F%8C%E7%AB%AF%E9%93%BE%E8%A1%A8.png"                        alt="由多个listNode组成的双端链表.png"                 ></p><p>虽然仅仅使用多个listNode结构就可以组成链表，但使用adlist.h&#x2F;list来持有链表的话，操作起来会更方便。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode * head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode * tail;</span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr,<span class="type">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数：</p><ul><li>dup函数用于复制链表节点所保存的值</li><li>free函数用于释放链表节点所保存的值</li><li>match函数则用于对比链表节点所保存的值和另一个输入值是否相等</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/%E7%94%B1list%E7%BB%93%E6%9E%84%E5%92%8ClistNode%E7%BB%93%E6%9E%84%E7%BB%84%E6%88%90%E7%9A%84%E9%93%BE%E8%A1%A8.png"                        alt="由list结构和listNode结构组成的链表.png"                 ></p><p>Redis的链表实现的特性可以总结如下：</p><ul><li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O（1）。</li><li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li><li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O（1）。</li><li>带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O（1）。</li><li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li></ul><h3 id="链表和链表节点的API"><a href="#链表和链表节点的API" class="headerlink" title="链表和链表节点的API"></a>链表和链表节点的API</h3><table><thead><tr><th><strong>函数</strong></th><th><strong>作用</strong></th><th><strong>时间复杂度</strong></th></tr></thead><tbody><tr><td><code>listSetDupMethod</code></td><td>将给定的函数设置为链表的节点值复制函数</td><td>复制函数可以通过链表的 <code>dup</code> 属性直接获得，O(1)</td></tr><tr><td><code>listGetDupMethod</code></td><td>返回链表当前正在使用的节点值复制函数</td><td>O(1)</td></tr><tr><td><code>listSetFreeMethod</code></td><td>将给定的函数设置为链表的节点值释放函数</td><td>释放函数可以通过链表的 <code>free</code> 属性直接获得，O(1)</td></tr><tr><td><code>listGetFreeMethod</code></td><td>返回链表当前正在使用的节点值释放函数</td><td>O(1)</td></tr><tr><td><code>listSetMatchMethod</code></td><td>将给定的函数设置为链表的节点值对比函数</td><td>对比函数可以通过链表的 <code>match</code> 属性直接获得，O(1)</td></tr><tr><td><code>listGetMatchMethod</code></td><td>返回链表当前正在使用的节点值对比函数</td><td>O(1)</td></tr><tr><td><code>listLength</code></td><td>返回链表的长度（包含多少个节点）</td><td>链表长度可以通过链表的 <code>len</code> 属性直接获得，O(1)</td></tr><tr><td><code>listFirst</code></td><td>返回链表的表头节点</td><td>表头节点可以通过链表的 <code>head</code> 属性直接获得，O(1)</td></tr><tr><td><code>listLast</code></td><td>返回链表的表尾节点</td><td>表尾节点可以通过链表的 <code>tail</code> 属性直接获得，O(1)</td></tr><tr><td><code>listPrevNode</code></td><td>返回给定节点的前置节点</td><td>前置节点可以通过节点的 <code>prev</code> 属性直接获得，O(1)</td></tr><tr><td><code>listNextNode</code></td><td>返回给定节点的后置节点</td><td>后置节点可以通过节点的 <code>next</code> 属性直接获得，O(1)</td></tr><tr><td><code>listNodeValue</code></td><td>返回给定节点当前保存的值</td><td>节点值可以通过节点的 <code>value</code> 属性直接获得，O(1)</td></tr><tr><td><code>listCreate</code></td><td>创建一个不包含任何节点的新链表</td><td>O(1)</td></tr><tr><td><code>listAddNodeHead</code></td><td>将一个包含给定值的新节点添加到链表的表头</td><td>O(1)</td></tr><tr><td><code>listAddNodeTail</code></td><td>将一个包含给定值的新节点添加到链表的表尾</td><td>O(1)</td></tr><tr><td><code>listInsertNode</code></td><td>将一个包含给定值的新节点插入到指定节点的前或后</td><td>O(1)</td></tr><tr><td><code>listSearchKey</code></td><td>查找并返回链表中包含给定值的节点</td><td>O(N)，N 为链表长度</td></tr><tr><td><code>listIndex</code></td><td>返回链表中给定索引位置的节点</td><td>O(N)，N 为链表长度</td></tr><tr><td><code>listDelNode</code></td><td>从链表中删除给定的节点</td><td>O(1)</td></tr><tr><td><code>listRotate</code></td><td>将链表的表尾节点弹出，并插入到链表的表头，成为新的表头节点</td><td>O(1)</td></tr><tr><td><code>listDup</code></td><td>复制一个给定链表的副本</td><td>O(N)，N 为链表长度</td></tr><tr><td><code>listRelease</code></td><td>释放给定链表及其所有节点</td><td>O(N)，N 为链表长度</td></tr></tbody></table><h2 id="第四章-字典"><a href="#第四章-字典" class="headerlink" title="第四章 - 字典"></a>第四章 - 字典</h2><p>字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。<br>在字典中，一个键（key）可以和一个值（value）进行关联（或者说将键映射为值），这些关联的键和值就称为键值对。<br>字典中的每个键都是独一无二的，程序可以在字典中根据键查找与之关联的值，或者通过键来更新值，又或者根据键来删除整个键值对，等等。<br>字典经常作为一种数据结构内置在很多高级编程语言里面，但Redis所使用的C语言并没有内置这种数据结构，因此Redis构建了自己的字典实现。<br>字典在Redis中的应用相当广泛，比如Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。</p><h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>Redis字典所使用的哈希表由dict.h&#x2F;dictht结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line"><span class="comment">// 哈希表数组</span></span><br><span class="line">dictEntry **table;</span><br><span class="line"><span class="comment">// 哈希表大小</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line"><span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line"><span class="comment">// 总是等于size-1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line"><span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>table 属性是一个数组，数组中的每个元素都是一个指向dict.h&#x2F;dictEntry结构的指针，每个dictEntry结构保存着一个键值对。<br>size 属性记录了哈希表的大小，也即是table数组的大小。<br>used 属性则记录了哈希表目前已有节点（键值对）的数量。<br>sizemask 属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8.png"                        alt="一个空的哈希表.png"                 ></p><h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>key 属性保存着键值对中的键。<br>v 属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。<br>next 属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/%E8%BF%9E%E6%8E%A5%E5%9C%A8%E4%B8%80%E8%B5%B7%E7%9A%84%E9%94%AEK1%E5%92%8C%E9%94%AEK0.png"                        alt="连接在一起的键K1和键K0.png"                 ></p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>Redis中的字典由dict.h&#x2F;dict结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash索引</span></span><br><span class="line">    <span class="comment">// 当rehash不在进行时，值为-1</span></span><br><span class="line">    in trehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：</p><ul><li>type 属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</li><li>privdata 属性保存了需要传给那些类型特定函数的可选参数。</li></ul><p>ht 属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用<code>ht[0]</code>哈希表，<code>ht[1]</code>哈希表只会在对<code>ht[0]</code>哈希表进行rehash时使用。<br>rehashidx 属性记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/%E6%99%AE%E9%80%9A%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E5%AD%97%E5%85%B8.png"                        alt="普通状态下的字典.png"                 ></p><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p><p>Redis计算哈希值和索引值的方法如下：</p><p>使用字典设置的哈希函数，计算键 key 的哈希值<br><code>hash = dict-&gt;type-&gt;hashFunction(key);</code></p><p>使用哈希表的 sizemask 属性和哈希值，计算出索引值</p><p>根据情况不同，<code>ht[x]</code>可以是<code>ht[0]</code>或者<code>ht[1]</code><br><code>index = hash &amp; dict-&gt;ht[x].sizemask;</code></p><p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。<br><a class="link"   href="https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C" >MurmurHash Wiki<i class="fas fa-external-link-alt"></i></a></p><h3 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h3><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突（collision）。<br><strong>Redis的哈希表使用链地址法（separate chaining）来解决键冲突</strong>，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。<br>因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，<strong>程序总是将新节点添加到链表的表头位置（复杂度为O（1））</strong>，排在其他已有节点的前面。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8%E8%A7%A3%E5%86%B3k2%E5%92%8Ck1%E7%9A%84%E5%86%B2%E7%AA%81.png"                        alt="使用链表解决k2和k1的冲突.png"                 ></p><h3 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h3><p>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。<br>扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，Redis对字典的哈希表执行rehash的步骤如下：</p><ol><li>为字典的<code>ht[1]</code>哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及<code>ht[0]</code>当前包含的键值对数量（也即是<code>ht[0]</code>.used属性的值）：<ul><li>如果执行的是扩展操作，那么<code>ht[1]</code>的大小为第一个大于等于<code>ht[0]</code>.used*2的2^n（2的n次方幂），即两倍。</li><li>如果执行的是收缩操作，那么<code>ht[1]</code>的大小为第一个大于等于<code>ht[0]</code>.used的2^n。即元素数量的最小倍数。</li></ul></li><li>将保存在<code>ht[0]</code>中的所有键值对rehash到<code>ht[1]</code>上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到<code>ht[1]</code>哈希表的指定位置上。</li><li>当<code>ht[0]</code>包含的所有键值对都迁移到了<code>ht[1]</code>之后（<code>ht[0]</code>变为空表），释放<code>ht[0]</code>，将<code>ht[1]</code>设置为<code>ht[0]</code>，并在<code>ht[1]</code>新创建一个空白哈希表，为下一次rehash做准备。</li></ol><p>当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：</p><ol><li>服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。</li><li>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。</li></ol><p>当哈希表的负载因子小于0.1（即小于当前大小十倍）时，程序自动开始对哈希表执行收缩操作。</p><p>其中哈希表的负载因子可以通过下面的公式算出：<br>负载因子 &#x3D; 哈希表已保存节点数量 &#x2F; 哈希表大小<br>load_factor &#x3D; ht[0].used &#x2F; ht[0].size</p><p>根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同。<br>这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率。<br>所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。</p><blockquote><p><code>BGSAVE</code> 命令用于在后台异步地执行数据快照（snapshot）保存操作，即创建 Redis 数据的 RDB 文件。执行这个命令时，Redis 会生成一个 RDB 文件，并将当前数据库中的所有数据保存到这个文件中。<br><code>BGREWRITEAOF</code> 命令用于在后台异步地重写 AOF（Append Only File）日志文件。AOF 是 Redis 提供的另一种持久化方式，通过记录每一个写命令来实现数据的持久化。<br>写时复制（copy-on-write）是指当一个进程创建一个子进程时，子进程会共享父进程的内存页面，而不是立即拷贝整个内存数据。这种共享是“只读”的，直到某一方（父进程或子进程）试图修改共享的数据时，系统才会真正复制该内存页面。这种方式避免了在创建子进程时立即拷贝大量内存数据的开销。</p></blockquote><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>扩展或收缩哈希表需要将<code>ht[0]</code>里面的所有键值对rehash到<code>ht[1]</code>里面，但是，这个rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。</p><p>这样做的原因在于，如果<code>ht[0]</code>里只保存着四个键值对，那么服务器可以在瞬间就将这些键值对全部rehash到<code>ht[1]</code>；<br>但是，如果哈希表里保存的键值对数量不是四个，而是四百万、四千万甚至四亿个键值对，那么要一次性将这些键值对全部rehash到<code>ht[1]</code>的话，庞大的计算量可能会导致服务器在一段时间内停止服务。<br>因此，为了避免rehash对服务器性能造成影响，服务器不是一次性将<code>ht[0]</code>里面的所有键值对全部rehash到<code>ht[1]</code>，而是分多次、渐进式地将<code>ht[0]</code>里面的键值对慢慢地rehash到<code>ht[1]</code>。</p><p>哈希表渐进式rehash的详细步骤：</p><ol><li>为<code>ht[1]</code>分配空间，让字典同时持有<code>ht[0]</code>和<code>ht[1]</code>两个哈希表。</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将<code>ht[0]</code>哈希表在rehashidx索引上的所有键值对rehash到<code>ht[1]</code>，当rehash工作完成之后，程序将rehashidx属性的值增一。</li><li>随着字典操作的不断执行，最终在某个时间点上，<code>ht[0]</code>的所有键值对都会被rehash至<code>ht[1]</code>，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。</li></ol><p>渐进式rehash的好处在于它采取分而治之的方式，<strong>将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。</strong></p><p><strong>渐进式rehash执行期间的哈希表操作</strong><br>因为在进行渐进式rehash的过程中，字典会同时使用<code>ht[0]</code>和<code>ht[1]</code>两个哈希表，所以在渐进式rehash进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。<br>例如，要在字典里面查找一个键的话，程序会先在<code>ht[0]</code>里面进行查找，如果没找到的话，就会继续到<code>ht[1]</code>里面进行查找，诸如此类。</p><p>另外，在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到<code>ht[1]</code>里面，而<code>ht[0]</code>则不再进行任何添加操作，这一措施保证了<code>ht[0]</code>包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表。</p><h3 id="字典API"><a href="#字典API" class="headerlink" title="字典API"></a>字典API</h3><table><thead><tr><th>函 数</th><th>作用</th><th>时间复杂度</th></tr></thead><tbody><tr><td>diotcreate</td><td>创建一个新的字典</td><td>0(1)</td></tr><tr><td>dietAdd</td><td>将给定的键值对添加到字典里面</td><td>0(1)</td></tr><tr><td>diotkeplace</td><td>将给定的健值对添加到字典里面，如果键已经 存在于字典，那么用新值取代原有的值</td><td>0(1)</td></tr><tr><td>dictretchvalue</td><td>这回给定键的值</td><td>0(1)</td></tr><tr><td>diotCetRandomKey</td><td>从字典中随机返回个键值对</td><td>0(1)</td></tr></tbody></table><h2 id="第五章-跳跃表"><a href="#第五章-跳跃表" class="headerlink" title="第五章 - 跳跃表"></a>第五章 - 跳跃表</h2><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。<br>跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。<br>在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。<br>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>和链表、字典等数据结构被广泛地应用在Redis内部不同，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在Redis里面没有其他用途。</p><h3 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h3><p>Redis的跳跃表由redis.h&#x2F;zskiplistNode和redis.h&#x2F;zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/%E4%B8%80%E4%B8%AA%E8%B7%B3%E8%B7%83%E8%A1%A8.png"                        alt="一个跳跃表.png"                 ></p><p>上图一个跳跃表示例，位于图片最左边的是 zskiplist 结构，该结构包含以下属性：</p><ul><li>header：指向跳跃表的表头节点。</li><li>tail：指向跳跃表的表尾节点。</li><li>level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li><li>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li></ul><p>位于zskiplist结构右方的是四个zskiplistNode结构，该结构包含以下属性：</p><ul><li>层（level）：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。<br>前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。<br>在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li><li>后退（backward）指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>分值（score）：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li><li>成员对象（obj）：各个节点中的o1、o2和o3是节点所保存的成员对象。</li></ul><p>注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到，所以图中省略了这些部分，只显示了表头节点的各个层。</p><h3 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h3><p>跳跃表节点的实现由redis.h&#x2F;zskiplistNode结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><h4 id="层"><a href="#层" class="headerlink" title="层"></a>层</h4><p>跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。<br>每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。</p><h4 id="前进指针"><a href="#前进指针" class="headerlink" title="前进指针"></a>前进指针</h4><p>每个层都有一个指向表尾方向的前进指针（<code>level[i].forward</code>属性），用于从表头向表尾方向访问节点。</p><h4 id="跨度"><a href="#跨度" class="headerlink" title="跨度"></a>跨度</h4><p>层的跨度（<code>level[i].span</code>属性）用于记录两个节点之间的距离：</p><ul><li>两个节点之间的跨度越大，它们相距得就越远。</li><li>指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。</li></ul><p>初看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样，遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。<br>当查找某个值时，程序会从最高层开始逐层往下搜索，每一层会利用跨度跳过多个节点，直到找到目标节点或进入下一层。 可以提高查询的效率。</p><h4 id="后退指针"><a href="#后退指针" class="headerlink" title="后退指针"></a>后退指针</h4><p>节点的后退指针（backward属性）用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p><h4 id="分值和成员"><a href="#分值和成员" class="headerlink" title="分值和成员"></a>分值和成员</h4><p>节点的分值（score属性）是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。<br>节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。<br>在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>仅靠多个跳跃表节点就可以组成一个跳跃表。<br>但通过使用一个zskiplist结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息。</p><p>zskiplist结构的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    structz skiplistNode *header, *tail;</span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>header和tail指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为O（1）。<br>通过使用length属性来记录节点的数量，程序可以在O（1）复杂度内返回跳跃表的长度。<br>level属性则用于在O（1）复杂度内获取跳跃表中层高最大的那个节点的层数量，注意表头节点的层高并不计算在内。</p><h3 id="跳跃表API"><a href="#跳跃表API" class="headerlink" title="跳跃表API"></a>跳跃表API</h3><table><thead><tr><th>函数</th><th>作用</th><th>时间复杂度</th></tr></thead><tbody><tr><td><code>zslCreate</code></td><td>创建一个新的跳跃表</td><td>O(1)</td></tr><tr><td><code>zslFree</code></td><td>释放给定的跳跃表及其包含的所有节点</td><td>O(N)，N 为跳跃表的长度</td></tr><tr><td><code>zslInsert</code></td><td>将包含给定成员和分值的新节点添加到跳跃表中</td><td>平均 O(log N)，最坏 O(N)</td></tr><tr><td><code>zslDelete</code></td><td>删除跳跃表中包含给定成员和分值的节点</td><td>平均 O(log N)，最坏 O(N)</td></tr><tr><td><code>zslGetRank</code></td><td>返回包含给定成员和分值的节点在跳跃表中的排名</td><td>平均 O(log N)，最坏 O(N)</td></tr><tr><td><code>zslGetElementByRank</code></td><td>返回跳跃表中指定排名的节点</td><td>平均 O(log N)，最坏 O(N)</td></tr><tr><td><code>zslIsInRange</code></td><td>判断跳跃表中是否存在至少一个节点的分值在给定范围内</td><td>O(1)，只需检查表头和表尾节点即可</td></tr><tr><td><code>zslFirstInRange</code></td><td>返回跳跃表中第一个符合指定分值范围的节点</td><td>平均 O(log N)，最坏 O(N)</td></tr></tbody></table><h2 id="第六章-整数集合"><a href="#第六章-整数集合" class="headerlink" title="第六章 - 整数集合"></a>第六章 - 整数集合</h2><p>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p><h3 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h3><p>整数集合（intset）是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为 int16_t、int32_t或者int64_t 的整数值，并且保证集合中不会出现重复元素。<br>每个intset.h&#x2F;intset结构表示一个整数集合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>contents 数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。<br>length 属性记录了整数集合包含的元素数量，也即是contents数组的长度。</p><p>虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值：</p><ul><li>如果encoding属性的值为INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组，数组里的每个项都是一个int16_t类型的整数值（最小值为-32768，最大值为32767）。</li><li>如果encoding属性的值为INTSET_ENC_INT32，那么contents就是一个int32_t类型的数组，数组里的每个项都是一个int32_t类型的整数值（最小值为-2147483648，最大值为2147483647）。</li><li>如果encoding属性的值为INTSET_ENC_INT64，那么contents就是一个int64_t类型的数组，数组里的每个项都是一个int64_t类型的整数值（最小值为-9223372036854775808，最大值为9223372036854775807）。</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%E4%BA%94%E4%B8%AAint16_t%E7%B1%BB%E5%9E%8B%E6%95%B4%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88.png"                        alt="一个包含五个int16_t类型整数值的整数集合.png"                 ></p><p>当向一个底层为int16_t数组的整数集合添加一个int64_t类型的整数值时，整数集合已有的所有元素都会被转换成int64_t类型。即升级规则。</p><blockquote><p>升级规则（Redis 会对整数集合进行自动升级，以支持不同大小的整数类型。）<br>自动升级触发条件：当一个新插入的整数无法在当前整数集合的类型范围内表示时，Redis 会触发升级。<br>全量复制与排序：Redis 会分配新的内存空间，将原来的所有整数复制到新类型的整数集合中。升级后的整数集合会保持有序状态，以便于后续查找操作。<br>升级不可逆：一旦整数集合升级到更大类型，就不会降级。例如，一旦升级到 <code>int64_t</code> 类型，即使删除所有大整数，类型也不会恢复。</p></blockquote><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。</p><p>升级整数集合并添加新元素共分为三步进行：</p><ol><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组里面。</li></ol><p>因为每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已有的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O（N）。</p><p>因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素：</p><ul><li>在新元素小于所有现有元素的情况下，新元素会被放置在底层数组的最开头（索引0）；</li><li>在新元素大于所有现有元素的情况下，新元素会被放置在底层数组的最末尾（索引length-1）。</li></ul><p>整数集合的升级策略有两个好处，一个是<strong>提升整数集合的灵活性</strong>，另一个是<strong>尽可能地节约内存</strong>。</p><p>因为C语言是静态类型语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面。<br>但是，因为整数集合可以通过自动升级底层数组来适应新元素，所以我们可以随意地将int16_t、int32_t或者int64_t类型的整数添加到集合中，而不必担心出现类型错误，这种做法非常灵活。<br>同时因为根据具体情况来使用具体的类型，而不是全部使用int64_t，所以可以节约内存。</p><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。<br>即使删除所有大整数，类型也不会恢复。</p><h3 id="整数集合API"><a href="#整数集合API" class="headerlink" title="整数集合API"></a>整数集合API</h3><table><thead><tr><th>函数</th><th>作用</th><th>时间复杂度</th></tr></thead><tbody><tr><td><code>intsetNew</code></td><td>创建一个新的整数集合</td><td>O(1)</td></tr><tr><td><code>intsetAdd</code></td><td>将给定元素添加到整数集合中</td><td>O(N)</td></tr><tr><td><code>intsetRemove</code></td><td>从整数集合中移除给定元素</td><td>O(N)</td></tr><tr><td><code>intsetFind</code></td><td>检查给定值是否存在于集合中</td><td>O(log N)，由于数组有序，可通过二分查找实现</td></tr><tr><td><code>intsetRandom</code></td><td>从整数集合中随机返回一个元素</td><td>O(1)</td></tr><tr><td><code>intsetGet</code></td><td>取出底层数组中给定索引上的元素</td><td>O(1)</td></tr><tr><td><code>intsetLen</code></td><td>返回整数集合中包含的元素个数</td><td>O(1)</td></tr><tr><td><code>intsetBlobLen</code></td><td>返回整数集合的内存字节数</td><td>O(1)</td></tr></tbody></table><h2 id="第七章-压缩列表"><a href="#第七章-压缩列表" class="headerlink" title="第七章 - 压缩列表"></a>第七章 - 压缩列表</h2><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。<br>当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p><h3 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h3><p>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p><p>压缩列表主要由以下几个部分组成：</p><ol><li><p><strong>Header（头部）</strong>：</p><ul><li><code>zlbytes</code>：4字节，表示整个压缩列表的总字节数，便于在内存中管理。</li><li><code>zltail</code>：4字节，记录最后一个元素的偏移量，使得可以快速定位尾部元素。</li><li><code>zllen</code>：2字节，表示压缩列表中包含的元素数量。如果数量大于 <code>65535</code>，<code>zllen</code> 只表示 65535，实际数量需要遍历确定。</li></ul></li><li><p><strong>Entry（节点）</strong>：</p><ul><li><code>previous_entry_length</code>：1-5字节，表示前一个元素的长度，用于<strong>双向遍历</strong>。如果前一个元素长度小于 254 字节，<code>previous_entry_length</code> 用 1 字节表示；否则，用 5 字节表示。</li><li><code>encoding</code>：1-5字节，记录当前元素的数据类型和长度，用于解析元素内容。例如，数据可以是字节数组或整数类型。</li><li><code>content</code>：变长，存储元素的实际数据。</li></ul></li><li><p><strong>End（结尾标志）</strong>：</p><ul><li>压缩列表以 1 字节特殊标志 <code>0xFF</code> 结尾，表示压缩列表结束。</li></ul></li></ol><h3 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h3><p>节点由以下组成：</p><ul><li><code>previous_entry_length</code>：1-5字节，表示前一个元素的长</li><li><code>encoding</code>：1-5字节，记录当前元素的数</li><li><code>content</code>：变长，存储元素的实际数据。</li></ul><p>每个压缩列表节点可以保存一个字节数组或者一个整数值，其中，字节数组可以是以下三种长度的其中一种：</p><ul><li>长度小于等于63（2 6–1）字节的字节数组；</li><li>长度小于等于16383（2 14–1）字节的字节数组；</li><li>长度小于等于4294967295（2 32–1）字节的字节数组；</li></ul><p>而整数值则可以是以下六种长度的其中一种：</p><ul><li>4位长，介于0至12之间的无符号整数；</li><li>1字节长的有符号整数；</li><li>3字节长的有符号整数；</li><li>int16_t类型整数；</li><li>int32_t类型整数；</li><li>int64_t类型整数。</li></ul><h4 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h4><p>节点的previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度。<br>previous_entry_length属性的长度可以是1字节或者5字节：</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面。</li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置为0xFE（十进制值254），而之后的四个字节则用于保存前一节点的长度。</li></ul><p>因为节点的previous_entry_length属性记录了前一个节点的长度，所以程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址。<br>举个例子，如果我们有一个指向当前节点起始地址的指针c，那么我们只要用指针c减去当前节点previous_entry_length属性的值，就可以得出一个指向前一个节点起始地址的指针p</p><blockquote><p>双向遍历<br>对于正向遍历。因为每个节点的大小不固定，需要计算当前节点的长度，以根据每个节点的实际长度进行跳转。<br>对于整数类型，encoding 直接决定了所占用的字节数（1、2、4 或 8 字节）。<br>对于字节数组类型，encoding 包含了字节数组的长度信息，用于确定 content 部分的大小。<br>对于反向遍历。则是通过previous_entry_length来实现的，它记录了当前节点的前一个节点的长度，从而可以计算出前一个节点的起始地址，从而进行跳转。</p></blockquote><h4 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h4><p>节点的encoding属性记录了节点的content属性所保存数据的类型以及长度。</p><table><thead><tr><th><strong>编码类型</strong></th><th><strong><code>encoding</code> 值</strong></th><th><strong>编码字节数</strong></th><th><strong>表示的数据类型</strong></th><th><strong>内容字节数</strong></th></tr></thead><tbody><tr><td><strong>字符串编码</strong></td><td><code>00xxxxxx</code></td><td>1 字节</td><td>字符串，长度 ≤ 63 字节</td><td>6 位表示长度（0-63）</td></tr><tr><td></td><td><code>01xxxxxx xxxxxxxx</code></td><td>2 字节</td><td>字符串，长度 ≤ 16383 字节</td><td>14 位表示长度（0-16383）</td></tr><tr><td></td><td><code>100xxxxx xxxxxxxx xxxxxxxx xxxxxxxx</code></td><td>5 字节</td><td>字符串，长度 ≤ 4294967295 字节</td><td>4 字节表示长度（0-4294967295）</td></tr><tr><td><strong>整数编码</strong></td><td><code>1111 0000</code></td><td>1 字节</td><td>4 位有符号整数</td><td>无</td></tr><tr><td></td><td><code>1100 0000</code></td><td>1 字节</td><td>1 字节有符号整数</td><td>1 字节内容</td></tr><tr><td></td><td><code>1101 0000</code></td><td>1 字节</td><td>2 字节有符号整数</td><td>2 字节内容</td></tr><tr><td></td><td><code>1110 0000</code></td><td>1 字节</td><td>4 字节有符号整数</td><td>4 字节内容</td></tr><tr><td></td><td><code>1111 0001</code></td><td>1 字节</td><td>8 字节有符号整数</td><td>8 字节内容</td></tr></tbody></table><h4 id="content"><a href="#content" class="headerlink" title="content"></a>content</h4><p>节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</p><h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>前面有提到，每个节点的previous_entry_length属性都记录了前一个节点的长度：</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性需要用1字节长的空间来保存这个长度值。</li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length属性需要用5字节长的空间来保存这个长度值。</li></ul><p>那么有一种情况<br>在一个压缩列表中，有多个连续的、长度介于250字节到253字节之间的节点e1至eN，因为e1至eN的所有节点的长度都小于254字节，所以记录这些节点的长度只需要1字节长的previous_entry_length属性。<br>如果将一个长度大于等于254字节的新节点new设置为压缩列表的表头节点，那么new将成为e1的前置节点。<br><strong>因为e1的previous_entry_length属性仅长1字节，它没办法保存新节点new的长度，所以程序将对压缩列表执行空间重分配操作，并将e1节点的previous_entry_length属性从原来的1字节长扩展为5字节长。</strong><br>同时，e1原本的长度介于250字节至253字节之间，在为previous_entry_length属性新增四个字节的空间之后，e1的长度就变成了介于254字节至257字节之间，而这种长度使用1字节长的previous_entry_length属性是没办法保存的。<br>所以e2也需要进行重新分配，以此类推。程序需要不断地对压缩列表执行空间重分配操作，直到eN为止。</p><p>Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update）<br><strong>除了添加新节点可能会引发连锁更新之外，删除节点也可能会引发连锁更新。</strong></p><p>因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O（N），所以连锁更新的最坏复杂度为O（N 2）。<br>要注意的是，尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：</p><ul><li>首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见；</li><li>其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的；</li></ul><p>因为以上原因，ziplistPush等命令的平均复杂度仅为O（N），在实际中，我们可以放心地使用这些函数，而不必担心连锁更新会影响压缩列表的性能。</p><h3 id="压缩列表API"><a href="#压缩列表API" class="headerlink" title="压缩列表API"></a>压缩列表API</h3><table><thead><tr><th>函数</th><th>作用</th><th>算法复杂度</th></tr></thead><tbody><tr><td><code>ziplistNew</code></td><td>创建一个新的压缩列表</td><td>O(1)</td></tr><tr><td><code>ziplistPush</code></td><td>将给定值的新节点添加到压缩列表的表头或表尾</td><td>平均 O(N)，最坏 O(N^2)</td></tr><tr><td><code>ziplistInsert</code></td><td>在给定节点之后插入包含给定值的新节点</td><td>平均 O(N)，最坏 O(N^2)</td></tr><tr><td><code>ziplistIndex</code></td><td>返回压缩列表给定索引处的节点</td><td>O(N)</td></tr><tr><td><code>ziplistFind</code></td><td>在压缩列表中查找并返回包含给定值的节点</td><td>O(N)，值检查为 O(M)</td></tr><tr><td><code>ziplistNext</code></td><td>返回给定节点的下一个节点</td><td>O(1)</td></tr><tr><td><code>ziplistPrev</code></td><td>返回给定节点的前一个节点</td><td>O(1)</td></tr><tr><td><code>ziplistGet</code></td><td>获取给定节点存储的值</td><td>O(1)</td></tr><tr><td><code>ziplistDelete</code></td><td>从压缩列表中删除给定的节点</td><td>平均 O(N)，最坏 O(N^2)</td></tr><tr><td><code>ziplistDeleteRange</code></td><td>删除压缩列表中从给定索引开始的多个连续节点</td><td>平均 O(N)，最坏 O(N^2)</td></tr><tr><td><code>ziplistBlobLen</code></td><td>返回压缩列表当前占用的内存字节数</td><td>O(1)</td></tr><tr><td><code>ziplistLen</code></td><td>返回压缩列表当前包含的节点数量</td><td>节点数量 ≤ 65535 时为 O(1)，否则为 O(N)</td></tr></tbody></table><p>其中：</p><ul><li><code>M</code> 是节点值的字节数（如果节点包含字符串值），表示比较过程中所需的检查复杂度。</li><li><code>N</code> 是压缩列表中节点的总数。</li></ul><p>因为ziplistPush、ziplistInsert、ziplistDelete和ziplistDeleteRange四个函数都有可能会引发连锁更新，所以它们的最坏复杂度都是O（N^2）。</p><h2 id="第八章-对象"><a href="#第八章-对象" class="headerlink" title="第八章 - 对象"></a>第八章 - 对象</h2><p>前面介绍了Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。<br>Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象。</p><p>通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。<br>使用对象的另一个好处是，我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</p><p>除此之外，Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；<br>另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。<br>最后，Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。</p><h3 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h3><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。</p><p>Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>对象的type属性记录了对象的类型，这个属性的值可以是下面列出的常量的其中一个。</p><table><thead><tr><th>类型常量</th><th>对象的名称</th></tr></thead><tbody><tr><td>REDIS_STRING</td><td>字符串对象</td></tr><tr><td>REDIS_LIST</td><td>列表对象</td></tr><tr><td>REDIS_HASH</td><td>哈希对象</td></tr><tr><td>REDIS_SET</td><td>集合对象</td></tr><tr><td>REDIS_ZSET</td><td>有序集合对象</td></tr></tbody></table><p>对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种，因此：</p><ul><li>当我们称呼一个数据库键为“字符串键”时，我们指的是“这个数据库键所对应的值为字符串对象”；</li><li>当我们称呼一个键为“列表键”时，我们指的是“这个数据库键所对应的值为列表对象”。</li></ul><p>TYPE命令的实现方式也与此类似，当我们对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型。</p><p>不同类型值对象的TYPE命令输出：</p><table><thead><tr><th>对象</th><th>对象type属性的值</th><th>TYPE命令的输出</th></tr></thead><tbody><tr><td>字符串对象</td><td>REDIS_STRING</td><td>“string”</td></tr><tr><td>列表对象</td><td>REDIS_LIST</td><td>“list”</td></tr><tr><td>哈希对象</td><td>REDIS_HASH</td><td>“hash”</td></tr><tr><td>集合刘象</td><td>REDIS_SET</td><td>“set”</td></tr><tr><td>有序集合对象</td><td>REDIS_ZSET</td><td>“zset”</td></tr></tbody></table><h4 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h4><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。<br>encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是下面列出的常量的其中一个。</p><table><thead><tr><th>数据类型</th><th>编码常量</th><th>编码所对应的底层数据结构</th></tr></thead><tbody><tr><td>String</td><td><code>REDIS_ENCODING_INT</code></td><td>整型类型的整数</td></tr><tr><td>String</td><td><code>REDIS_ENCODING_EMBSTR</code></td><td>embstr 编码的简单动态字符串</td></tr><tr><td>String</td><td><code>REDIS_ENCODING_RAW</code></td><td>简单动态字符串</td></tr><tr><td>Hash</td><td><code>REDIS_ENCODING_ZIPLIST</code></td><td>压缩列表</td></tr><tr><td>Hash</td><td><code>REDIS_ENCODING_HT</code></td><td>字典</td></tr><tr><td>List</td><td><code>REDIS_ENCODING_LINKEDLIST</code></td><td>双端链表</td></tr><tr><td>List</td><td><code>REDIS_ENCODING_ZIPLIST</code></td><td>压缩列表</td></tr><tr><td>Set</td><td><code>REDIS_ENCODING_INTSET</code></td><td>整数集合</td></tr><tr><td>Set</td><td><code>REDIS_ENCODING_HT</code></td><td>字典</td></tr><tr><td>Sorted Set</td><td><code>REDIS_ENCODING_ZIPLIST</code></td><td>压缩列表</td></tr><tr><td>Sorted Set</td><td><code>REDIS_ENCODING_SKIPLIST</code></td><td>跳跃表和字典</td></tr></tbody></table><p>每种类型的对象都至少使用了两种不同的编码，下面列出了每种类型的对象可以使用的编码。</p><table><thead><tr><th>类型</th><th>编码常量</th><th>对象描述</th></tr></thead><tbody><tr><td><code>REDIS_STRING</code></td><td><code>REDIS_ENCODING_INT</code></td><td>使用整数值实现的字符串对象</td></tr><tr><td><code>REDIS_STRING</code></td><td><code>REDIS_ENCODING_EMBSTR</code></td><td>使用 embstr 编码的简单动态字符串实现的字符串对象</td></tr><tr><td><code>REDIS_STRING</code></td><td><code>REDIS_ENCODING_RAW</code></td><td>使用简单动态字符串实现的字符串对象</td></tr><tr><td><code>REDIS_LIST</code></td><td><code>REDIS_ENCODING_ZIPLIST</code></td><td>使用压缩列表实现的列表对象</td></tr><tr><td><code>REDIS_LIST</code></td><td><code>REDIS_ENCODING_LINKEDLIST</code></td><td>使用双端链表实现的列表对象</td></tr><tr><td><code>REDIS_HASH</code></td><td><code>REDIS_ENCODING_ZIPLIST</code></td><td>使用压缩列表实现的哈希对象</td></tr><tr><td><code>REDIS_HASH</code></td><td><code>REDIS_ENCODING_HT</code></td><td>使用字典实现的哈希对象</td></tr><tr><td><code>REDIS_SET</code></td><td><code>REDIS_ENCODING_INTSET</code></td><td>使用整数集合实现的集合对象</td></tr><tr><td><code>REDIS_SET</code></td><td><code>REDIS_ENCODING_HT</code></td><td>使用字典实现的集合对象</td></tr><tr><td><code>REDIS_ZSET</code></td><td><code>REDIS_ENCODING_ZIPLIST</code></td><td>使用压缩列表实现的有序集合对象</td></tr><tr><td><code>REDIS_ZSET</code></td><td><code>REDIS_ENCODING_SKIPLIST</code></td><td>使用跳跃表和字典实现的有序集合对象</td></tr></tbody></table><p>使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码。下面列出了不同编码的对象所对应的OBJECT ENCODING命令输出。</p><table><thead><tr><th>对象所使用的底层数据结构</th><th>编码常量</th><th><code>OBJECT ENCODING</code> 命令输出</th></tr></thead><tbody><tr><td>整数</td><td><code>REDIS_ENCODING_INT</code></td><td><code>&quot;int&quot;</code></td></tr><tr><td>embstr 编码的简单动态字符串（SDS）</td><td><code>REDIS_ENCODING_EMBSTR</code></td><td><code>&quot;embstr&quot;</code></td></tr><tr><td>简单动态字符串（SDS）</td><td><code>REDIS_ENCODING_RAW</code></td><td><code>&quot;raw&quot;</code></td></tr><tr><td>字典</td><td><code>REDIS_ENCODING_HT</code></td><td><code>&quot;hashtable&quot;</code></td></tr><tr><td>双端链表</td><td><code>REDIS_ENCODING_LINKEDLIST</code></td><td><code>&quot;linkedlist&quot;</code></td></tr><tr><td>压缩列表</td><td><code>REDIS_ENCODING_ZIPLIST</code></td><td><code>&quot;ziplist&quot;</code></td></tr><tr><td>整数集合</td><td><code>REDIS_ENCODING_INTSET</code></td><td><code>&quot;intset&quot;</code></td></tr><tr><td>跳跃表和字典</td><td><code>REDIS_ENCODING_SKIPLIST</code></td><td><code>&quot;skiplist&quot;</code></td></tr></tbody></table><p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。<br>举个例子，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：</p><ul><li>因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</li><li>随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；</li></ul><p>其他类型的对象也会通过使用多种不同的编码来进行类似的优化。</p><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串对象的编码可以是int、raw或者embstr。</p><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成long），并将字符串对象的编码设置为int。<br>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。<br>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</p><p>embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都使用redisObject结构和sdshdr结构来表示字符串对象。<br><strong>但raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间</strong>，空间中依次包含redisObject和sdshdr两个结构。</p><p>embstr编码的字符串对象在执行命令时，产生的效果和raw编码的字符串对象执行命令时产生的效果是相同的，但使用embstr编码的字符串对象来保存短字符串值有以下好处：</p><ul><li>embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。</li><li>释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。</li><li>因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势。</li></ul><p><strong>可以用 long double 类型表示的浮点数在Redis中也是作为字符串值来保存的。</strong><br>如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值。<br>在有需要的时候，程序会将保存在字符串对象里面的字符串值转换回浮点数值，执行某些操作，然后再将执行操作所得的浮点数值转换回字符串值，并继续保存在字符串对象里面。</p><h4 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h4><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象。<br>对于int编码的字符串对象来说，如果我们向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从int变为raw。</p><p>另外，因为Redis没有为embstr编码的字符串对象编写任何相应的修改程序（只有int编码的字符串对象和raw编码的字符串对象有这些程序），所以embstr编码的字符串对象实际上是只读的。<br>当我们对embstr编码的字符串对象执行任何修改命令时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。因为这个原因，<strong>embstr编码的字符串对象在执行修改命令之后，总会变成一个raw编码的字符串对象。</strong></p><h4 id="字符串命令的实现"><a href="#字符串命令的实现" class="headerlink" title="字符串命令的实现"></a>字符串命令的实现</h4><p>因为字符串键的值为字符串对象，所以用于字符串键的所有命令都是针对字符串对象来构建的，表8-7列举了其中一部分字符串命令，以及这些命令在不同编码的字符串对象下的实现方法。</p><table><thead><tr><th>命令</th><th><code>int</code> 编码的实现方法</th><th><code>embstr</code> 编码的实现方法</th><th><code>raw</code> 编码的实现方法</th></tr></thead><tbody><tr><td><code>SET</code></td><td>使用整数编码保存值</td><td>使用 <code>embstr</code> 编码保存值</td><td>使用 <code>raw</code> 编码保存值</td></tr><tr><td><code>GET</code></td><td>拷贝整数值并转换为字符串后返回给客户端</td><td>直接返回字符串值</td><td>直接返回字符串值</td></tr><tr><td><code>APPEND</code></td><td>转换为 <code>raw</code> 编码后按 <code>raw</code> 编码方式执行</td><td>转换为 <code>raw</code> 编码后按 <code>raw</code> 编码方式执行</td><td>将给定字符串追加到现有字符串的末尾</td></tr><tr><td><code>INCRBYFLOAT</code></td><td>转换整数为浮点数，计算结果并保存浮点数结果</td><td>尝试将字符串转换为 <code>long double</code> 类型的浮点数，计算并保存</td><td>尝试将字符串转换为 <code>long double</code> 类型的浮点数，计算并保存</td></tr><tr><td><code>INCRBY</code></td><td>执行加法计算，保存结果为整数</td><td><code>embstr</code> 编码无法执行此命令，返回错误</td><td><code>raw</code> 编码无法执行此命令，返回错误</td></tr><tr><td><code>DECRBY</code></td><td>执行减法计算，保存结果为整数</td><td><code>embstr</code> 编码无法执行此命令，返回错误</td><td><code>raw</code> 编码无法执行此命令，返回错误</td></tr><tr><td><code>STRLEN</code></td><td>将整数转换为字符串并返回其长度</td><td>返回字符串的长度</td><td>返回字符串的长度</td></tr><tr><td><code>SETRANGE</code></td><td>转换为 <code>raw</code> 编码后按 <code>raw</code> 编码方式执行</td><td>转换为 <code>raw</code> 编码后按 <code>raw</code> 编码方式执行</td><td>将指定索引位置上的值设置为给定字符</td></tr><tr><td><code>GETRANGE</code></td><td>将整数转换为字符串并返回指定索引上的字符</td><td>返回字符串指定索引上的字符</td><td>返回字符串指定索引上的字符</td></tr></tbody></table><h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>列表对象的编码可以是ziplist或者linkedlist。</p><p>ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素。<br>linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点（node）都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</p><h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><p>当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：</p><ul><li>列表对象保存的所有字符串元素的长度都小于64字节；</li><li>列表对象保存的元素数量小于512个；</li></ul><p>不能满足这两个条件的列表对象需要使用linkedlist编码。</p><p>以上两个条件的上限值是可以修改的，具体请看配置文件中关于 <code>list-max-ziplist-value</code> 选项和 <code>list-max-ziplist-entries</code> 选项的说明。<br>对于使用ziplist编码的列表对象来说，当使用ziplist编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行，原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面，对象的编码也会从ziplist变为linkedlist。</p><h4 id="列表命令的实现"><a href="#列表命令的实现" class="headerlink" title="列表命令的实现"></a>列表命令的实现</h4><p>因为列表键的值为列表对象，所以用于列表键的所有命令都是针对列表对象来构建的，下面列出了其中一部分列表键命令，以及这些命令在不同编码的列表对象下的实现方法。</p><table><thead><tr><th>命令</th><th><code>ziplist</code> 编码的实现方法</th><th><code>linkedlist</code> 编码的实现方法</th></tr></thead><tbody><tr><td><code>LPUSH</code></td><td>调用 <code>ziplistPush</code> 函数，将新元素推入到压缩列表的表头</td><td>用 <code>listAddNodeHead</code> 函数，将新元素推入到双端链表的表头</td></tr><tr><td><code>RPUSH</code></td><td>调用 <code>ziplistPush</code> 函数，将新元素推入到压缩列表的表尾</td><td>调用 <code>listAddNodeTail</code> 函数，将新元素推入到双端链表的表尾</td></tr><tr><td><code>LPOP</code></td><td>调用 <code>ziplistIndex</code> 函数定位压缩列表的表头节点，返回节点所保存的元素后，调用 <code>ziplistDelete</code> 函数删除表头节点</td><td>调用 <code>listFirst</code> 函数定位双端链表的表头节点，返回节点所保存的元素后，调用 <code>listDelNode</code> 函数删除表头节点</td></tr><tr><td><code>RPOP</code></td><td>调用 <code>ziplistIndex</code> 函数定位压缩列表的表尾节点，返回节点所保存的元素后，调用 <code>ziplistDelete</code> 函数删除表尾节点</td><td>调用 <code>listLast</code> 函数定位双端链表的表尾节点，返回节点所保存的元素后，调用 <code>listDelNode</code> 函数删除表尾节点</td></tr><tr><td><code>LINDEX</code></td><td>调用 <code>ziplistIndex</code> 函数定位压缩列表中的指定节点，然后返回节点所保存的元素</td><td>调用 <code>listIndex</code> 函数定位双端链表中的指定节点，然后返回节点所保存的元素</td></tr><tr><td><code>LLEN</code></td><td>调用 <code>ziplistLen</code> 函数返回压缩列表的长度</td><td>调用 <code>listLength</code> 函数返回双端链表的长度</td></tr><tr><td><code>LINSERT</code></td><td>若在表头或表尾插入新节点，调用 <code>ziplistPush</code> 函数；在其他位置插入时调用 <code>ziplistInsert</code> 函数</td><td>调用 <code>listInsertNode</code> 函数，将新节点插入到双端链表的指定位置</td></tr><tr><td><code>LREM</code></td><td>遍历压缩列表节点，并调用 <code>ziplistDelete</code> 函数删除包含给定元素的节点</td><td>遍历双端链表节点，调用 <code>listDelNode</code> 函数删除包含给定元素的节点</td></tr><tr><td><code>LTRIM</code></td><td>调用 <code>ziplistDeleteRange</code> 函数，删除压缩列表中所有不在指定索引范围内的节点</td><td>遍历双端链表节点，调用 <code>listDelNode</code> 函数删除所有不在指定索引范围内的节点</td></tr><tr><td><code>LSET</code></td><td>调用 <code>ziplistDelete</code> 删除指定索引上的现有节点，然后调用 <code>ziplistInsert</code> 插入新节点</td><td>调用 <code>listIndex</code> 函数定位到双端链表的指定索引节点，然后通过赋值更新节点的值</td></tr></tbody></table><h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>哈希对象的编码可以是ziplist或者hashtable。<br>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：</p><ul><li>保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li></ul><p>hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：</p><ul><li>字典的每个键都是一个字符串对象，对象中保存了键值对的键；</li><li>字典的每个值都是一个字符串对象，对象中保存了键值对的值。</li></ul><h4 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h4><p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：</p><ul><li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</li><li>哈希对象保存的键值对数量小于512个；不能满足这两个条件的哈希对象需要使用hashtable编码。</li></ul><p>这两个条件的上限值是可以修改的，具体请看配置文件中关于hash-max-ziplist-value选项和hash-max-ziplist-entries选项的说明。</p><p>对于使用ziplist编码的列表对象来说，当使用ziplist编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行。<br>原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面，对象的编码也会从ziplist变为hashtable。<br>除了键的长度太大会引起编码转换之外，值的长度太大也会引起编码转换。</p><h4 id="哈希命令的实现"><a href="#哈希命令的实现" class="headerlink" title="哈希命令的实现"></a>哈希命令的实现</h4><p>因为哈希键的值为哈希对象，所以用于哈希键的所有命令都是针对哈希对象来构建的，下面列出了其中一部分哈希键命令，以及这些命令在不同编码的哈希对象下的实现方法。</p><table><thead><tr><th>命令</th><th><code>ziplist</code> 编码实现方法</th><th><code>hashtable</code> 编码实现方法</th></tr></thead><tbody><tr><td><code>HSET</code></td><td>调用 <code>ziplistPush</code> 函数，将键推入到压缩列表的表尾，然后再次调用 <code>ziplistPush</code> 函数，将值推入到压缩列表的表尾</td><td>调用 <code>dictAdd</code> 函数，将新键值对添加到字典中</td></tr><tr><td><code>HGET</code></td><td>调用 <code>ziplistFind</code> 函数，在压缩列表中查找指定键所对应的节点，然后调用 <code>ziplistNext</code> 函数，移动到值节点并返回其值</td><td>使用 <code>dictFind</code> 函数在字典中查找给定键，然后调用 <code>dictGetVal</code> 函数返回该键的值</td></tr><tr><td><code>HEXISTS</code></td><td>调用 <code>ziplistFind</code> 函数在压缩列表中查找指定键节点，找到则表示键值对存在，未找到则表示不存在</td><td>调用 <code>dictFind</code> 函数在字典中查找给定键，找到表示存在，未找到表示不存在</td></tr><tr><td><code>HDEL</code></td><td>调用 <code>ziplistFind</code> 函数在压缩列表中查找指定键节点，然后删除键节点及其相邻的值节点</td><td>调用 <code>dictDelete</code> 函数将指定键对应的键值对从字典中删除</td></tr><tr><td><code>HLEN</code></td><td>调用 <code>ziplistLen</code> 函数，取得压缩列表中节点的总数，并除以 2，得出键值对数量</td><td>调用 <code>dictSize</code> 函数返回字典中包含的键值对数量</td></tr><tr><td><code>HGETALL</code></td><td>遍历整个压缩列表，调用 <code>ziplistGet</code> 函数返回所有键和值（都是节点）</td><td>遍历整个字典，调用 <code>dictGetKey</code> 函数返回键，调用 <code>dictGetVal</code> 函数返回值</td></tr></tbody></table><h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>集合对象的编码可以是intset或者hashtable。</p><p>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。<br>hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。</p><h4 id="编码的转换-1"><a href="#编码的转换-1" class="headerlink" title="编码的转换"></a>编码的转换</h4><p>当集合对象可以同时满足以下两个条件时，对象使用intset编码：</p><ul><li>集合对象保存的所有元素都是整数值；</li><li>集合对象保存的元素数量不超过512个。</li></ul><p>不能满足这两个条件的集合对象需要使用hashtable编码。</p><p>第二个条件的上限值是可以修改的，具体请看配置文件中关于set-max-intset-entries选项的说明。</p><p>对于使用intset编码的集合对象来说，当使用intset编码所需的两个条件的任意一个不能被满足时，就会执行对象的编码转换操作。<br>原本保存在整数集合中的所有元素都会被转移并保存到字典里面，并且对象的编码也会从intset变为hashtable。</p><h4 id="集合命令的实现"><a href="#集合命令的实现" class="headerlink" title="集合命令的实现"></a>集合命令的实现</h4><p>因为集合键的值为集合对象，所以用于集合键的所有命令都是针对集合对象来构建的，下面列出了其中一部分集合键命令，以及这些命令在不同编码的集合对象下的实现方法。</p><table><thead><tr><th>命令</th><th><code>intset</code> 编码实现方法</th><th><code>hashtable</code> 编码实现方法</th></tr></thead><tbody><tr><td><code>SADD</code></td><td>调用 <code>intsetAdd</code> 函数，将所有新元素添加到整数集合中</td><td>调用 <code>dictAdd</code> 函数，以新元素为键，<code>NULL</code> 值，将键值对添加到字典中</td></tr><tr><td><code>SCARD</code></td><td>调用 <code>intsetLen</code> 函数，返回整数集合包含的元素数量</td><td>调用 <code>dictSize</code> 函数，返回字典中包含的键值对数量</td></tr><tr><td><code>SISMEMBER</code></td><td>调用 <code>intsetFind</code> 函数，在整数集合中查找给定的元素，找到则说明元素存在，未找到则说明元素不存在</td><td>调用 <code>dictFind</code> 函数，在字典中查找给定的元素，找到则说明元素存在，未找到则说明元素不存在</td></tr><tr><td><code>SMEMBERS</code></td><td>遍历整个整数集合，使用 <code>intsetGet</code> 函数返回集合元素</td><td>遍历整个字典，使用 <code>dictGetKey</code> 函数返回字典的键作为集合元素</td></tr><tr><td><code>SRANDMEMBER</code></td><td>调用 <code>intsetRandom</code> 函数，从整数集合中随机返回一个元素</td><td>调用 <code>dictGetRandomKey</code> 函数，从字典中随机返回一个键</td></tr><tr><td><code>SPOP</code></td><td>调用 <code>intsetPop</code> 函数，从整数集合中随机取出一个元素，并在将这个随机元素返回给客户端之后，调用 <code>intsetRemove</code> 函数将随机元素从整数集合中删除</td><td>调用 <code>dictGetRandomKey</code> 函数，从字典中随机取出一个键，并在将这个随机字典键的值返回给客户端之后，调用 <code>dictDelete</code> 函数删除随机字典键所对应的键值对</td></tr><tr><td><code>SREM</code></td><td>调用 <code>intsetRemove</code> 函数，从整数集合中移除所有给定的元素</td><td>调用 <code>dictDelete</code> 函数，从字典中删除所有键为给定元素的键值对</td></tr></tbody></table><h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><p>有序集合的编码可以是ziplist或者skiplist。</p><p>ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。<br>压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。</p><p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表。</p><p>zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值。<br>通过这个跳跃表，程序可以对有序集合进行范围型操作，比如ZRANK、ZRANGE等命令就是基于跳跃表API来实现的。<br>除此之外，zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值则保存了元素的分值。<br>通过这个字典，程序可以用O（1）复杂度查找给定成员的分值，ZSCORE命令就是根据这一特性实现的，而很多其他有序集合命令都在实现的内部用到了这一特性。</p><p>有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。<br>值得一提的是，虽然zset结构同时使用跳跃表和字典来保存有序集合元素，但这两种数据结构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，也不会因此而浪费额外的内存。</p><p><strong>为什么有序集合需要同时使用跳跃表和字典来实现？</strong></p><p>在理论上，有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现，但无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低。<br>举个例子，如果我们只使用字典来实现有序集合，那么虽然以O（1）复杂度查找成员的分值这一特性会被保留，但是，因为字典以无序的方式来保存集合元素，所以每次在执行范围型操作——比如ZRANK、ZRANGE等命令时。<br>程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少O（NlogN）时间复杂度，以及额外的O（N）内存空间（因为要创建一个数组来保存排序后的元素）。</p><p>另一方面，如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O（1）上升为O（logN）。<br>因为以上原因，为了让有序集合的查找和范围型操作都尽可能快地执行，Redis选择了同时使用字典和跳跃表两种数据结构来实现有序集合。</p><h4 id="编码的转换-2"><a href="#编码的转换-2" class="headerlink" title="编码的转换"></a>编码的转换</h4><p>当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：</p><ul><li>有序集合保存的元素数量小于128个；</li><li>有序集合保存的所有元素成员的长度都小于64字节；</li></ul><p>不能满足以上两个条件的有序集合对象将使用skiplist编码。</p><p>以上两个条件的上限值是可以修改的，具体请看配置文件中关于zset-max-ziplist-entries选项和zset-max-ziplist-value选项的说明。</p><p>对于使用ziplist编码的有序集合对象来说，当使用ziplist编码所需的两个条件中的任意一个不能被满足时，就会执行对象的编码转换操作。<br>原本保存在压缩列表里的所有集合元素都会被转移并保存到zset结构里面，对象的编码也会从ziplist变为skiplist。</p><h4 id="有序集合命令的实现"><a href="#有序集合命令的实现" class="headerlink" title="有序集合命令的实现"></a>有序集合命令的实现</h4><p>因为有序集合键的值为哈希对象，所以用于有序集合键的所有命令都是针对哈希对象来构建的，下面列出了其中一部分有序集合键命令，以及这些命令在不同编码的哈希对象下的实现方法。</p><table><thead><tr><th>命令</th><th><code>ziplist</code> 编码实现方法</th><th><code>zset</code> 编码实现方法</th></tr></thead><tbody><tr><td><code>ZADD</code></td><td>调用 <code>ziplistInsert</code> 函数，将成员和分值作为两个节点分别插入到压缩列表</td><td>先调用 <code>zslInsert</code> 函数，将新元素添加到跳跃表，然后调用 <code>dictAdd</code> 函数，将新元素与分值的关联添加到字典中</td></tr><tr><td><code>ZCARD</code></td><td>调用 <code>ziplistLength</code> 函数，获得压缩列表包含的节点数量，将这个数量除以2得出集合元素的数量</td><td>访问跳跃表的数据结构的 <code>length</code> 属性，直接返回集合元素的数量</td></tr><tr><td><code>ZCOUNT</code></td><td>遍历压缩列表，统计分值在给定范围内的节点的数量</td><td>遍历跳跃表，统计分值在给定范围内的节点的数量</td></tr><tr><td><code>ZRANGE</code></td><td>从表头向表尾遍历压缩列表，返回给定索引范围内的所有元素</td><td>从表头向表尾遍历跳跃表，返回给定索引范围内的所有元素</td></tr><tr><td><code>ZREVRANGE</code></td><td>从表尾向表头遍历压缩列表，返回给定索引范围内的所有元素</td><td>从表尾向表头遍历跳跃表，返回给定索引范围内的所有元素</td></tr><tr><td><code>ZRANK</code></td><td>从表头向表尾遍历压缩列表，查找给定的成员，沿途记录经过节点的数量，当找到给定成员之后，途经节点的数量就是该成员的排名</td><td>从表头向表尾遍历跳跃表，查找给定的成员，沿途记录经过节点的数量，当找到给定成员之后，途经节点的数量就是该成员的排名</td></tr><tr><td><code>ZREVRANK</code></td><td>从表尾向表头遍历压缩列表，查找给定的成员，沿途记录经过节点的数量，当找到给定成员之后，途经节点的数量就是该成员的排名</td><td>从表尾向表头遍历跳跃表，查找给定的成员，沿途记录经过节点的数量，当找到给定成员之后，途经节点的数量就是该成员的排名</td></tr><tr><td><code>ZREM</code></td><td>遍历压缩列表，移除所有包含给定成员的节点，以及被移除成员节点旁边的分值节点</td><td>遍历跳跃表，移除所有包含给定成员的跳跃表节点，并在字典中解除该成员与分值的关联</td></tr><tr><td><code>ZSCORE</code></td><td>遍历压缩列表，找到包含给定成员的节点，然后取出成员节点旁边的分值节点保存的元素分值</td><td>直接从字典中取出给定成员的分值</td></tr></tbody></table><h3 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h3><p>Redis中用于操作键的命令基本上可以分为两种类型。</p><p>其中一种命令可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等。<br>而另一种命令只能对特定类型的键执行，比如说：</p><ul><li>SET、GET、APPEND、STRLEN等命令只能对字符串键执行；</li><li>HDEL、HSET、HGET、HLEN等命令只能对哈希键执行；</li><li>RPUSH、LPOP、LINSERT、LLEN等命令只能对列表键执行；</li><li>SADD、SPOP、SINTER、SCARD等命令只能对集合键执行；</li><li>ZADD、ZCARD、ZRANK、ZSCORE等命令只能对有序集合键执行；</li></ul><h4 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h4><p>从为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。</p><p>类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的：</p><ul><li>在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令；</li><li>否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。</li></ul><h4 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h4><p>Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。</p><p>比如，列表对象有ziplist和linkedlist两种编码可用，其中前者使用压缩列表API来实现列表命令，而后者则使用双端链表API来实现列表命令。<br>如果我们对一个键执行LLEN命令，那么服务器除了要确保执行命令的是列表键之外，还需要根据键的值对象所使用的编码来选择正确的LLEN命令实现：</p><ul><li>如果列表对象的编码为ziplist，那么说明列表对象的实现为压缩列表，程序将使用ziplistLen函数来返回列表的长度；</li><li>如果列表对象的编码为linkedlist，那么说明列表对象的实现为双端链表，程序将使用listLength函数来返回双端链表的长度；</li></ul><p>借用面向对象方面的术语来说，我们可以认为LLEN命令是多态（polymorphism）的，只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都可以正常执行。<br>实际上，我们也可以将DEL、EXPIRE、TYPE等命令也称为多态命令，因为无论输入的键是什么类型，这些命令都可以正确地执行。<br>DEL、EXPIRE等命令和LLEN等命令的区别在于，前者是基于类型的多态——一个命令可以同时用于处理多种不同类型的键，而后者是基于编码的多态——一个命令可以同时用于处理多种不同编码。</p><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制。<br>通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p><p>每个对象的引用计数信息由redisObject结构的refcount属性记录：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>对象的引用计数信息会随着对象的使用状态而不断变化：</p><ul><li>在创建一个新对象时，引用计数的值会被初始化为1；</li><li>当对象被一个新程序使用时，它的引用计数值会被增一；</li><li>当对象不再被一个程序使用时，它的引用计数值会被减一；</li><li>当对象的引用计数值变为0时，对象所占用的内存会被释放。</li></ul><p>下面列出了修改对象引用计数的API，这些API分别用于增加、减少、重置对象的引用计数。</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><strong>incrRefCount</strong></td><td>将对象的引用计数值增加 1。</td></tr><tr><td><strong>decrRefCount</strong></td><td>将对象的引用计数值减少 1。当对象的引用计数值等于 0 时，释放对象。</td></tr><tr><td><strong>resetRefCount</strong></td><td>将对象的引用计数值设置为指定值，通常在需要重置引用计数时使用。</td></tr></tbody></table><h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。</p><p>举个例子，假设键A创建了一个包含整数值100的字符串对象作为值对象。<br>如果这时键B也要创建一个同样保存了整数值100的字符串对象作为值对象，那么服务器有以下两种做法：</p><ol><li>为键B新创建一个包含整数值100的字符串对象；</li><li>让键A和键B共享同一个字符串对象；</li></ol><p>以上两种方法很明显是第二种方法更节约内存。<br>在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：</p><ol><li>将数据库键的值指针指向一个现有的值对象；</li><li>将被共享的值对象的引用计数增一。</li></ol><p>目前来说，Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。<br>创建共享字符串对象的数量可以通过修改redis.h&#x2F;REDIS_SHARED_INTEGERS常量来修改。<br>可以使用<code>OBJECT REFCOUNT</code>命令查看对象的引用计数。</p><p>另外，这些共享对象不单单只有字符串键可以使用，那些在数据结构中嵌套了字符串对象的对象（linkedlist编码的列表对象、hashtable编码的哈希对象、hashtable编码的集合对象，以及zset编码的有序集合对象）都可以使用这些共享对象。</p><p><strong>为什么Redis不共享包含字符串的对象？</strong></p><p>当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象。<br>而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的CPU时间也会越多：</p><ul><li>如果共享对象是保存整数值的字符串对象，那么验证操作的复杂度为O（1）；</li><li>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O（N）；</li><li>如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O（N 2）。</li></ul><p>因此，尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享。</p><h3 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h3><p>除了前面介绍过的type、encoding、ptr和refcount四个属性之外，redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p><code>OBJECT IDLETIME</code>命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的：</p><p><code>OBJECT IDLETIME</code>命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的lru属性。<br>除了可以被OBJECT IDLETIME命令打印出来之外，键的空转时长还有另外一项作用：<br>如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为 volatile-lru 或者 allkeys-lru，那么当服务器占用的内存数超过了 maxmemory 选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p><p>配置文件的 maxmemory 选项和 maxmemory-policy 选项的说明介绍了关于这方面的更多信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有点遗憾，梁敬彬和梁敬弘老师关于数据库的第二本佳作《收获，不止SQl优化》短期内可能不会去看了。&lt;br&gt;正如老师在《收获，不止Oracle》</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://cooooing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Redis" scheme="https://cooooing.github.io/tags/Redis/"/>
    
    <category term="数据库" scheme="https://cooooing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="《Redis设计与实现》" scheme="https://cooooing.github.io/tags/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>BitTorrent协议</title>
    <link href="https://cooooing.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/BitTorrent%E5%8D%8F%E8%AE%AE/"/>
    <id>https://cooooing.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/BitTorrent%E5%8D%8F%E8%AE%AE/</id>
    <published>2024-10-12T03:24:13.000Z</published>
    <updated>2024-10-12T03:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BitTorrent协议规范"><a href="#BitTorrent协议规范" class="headerlink" title="BitTorrent协议规范"></a>BitTorrent协议规范</h2><p>BitTorrent是一个用于分发文件的协议。它通过URL识别内容，并设计为与网络无缝集成。<br>与普通HTTP相比，它的优势在于，当多个用户同时下载同一文件时，下载者之间会互相上传，这使得文件源能够以适度的负载支持大量下载者。</p><p>BitTorrent文件分发包括以下实体：</p><ul><li>普通Web服务器</li><li>静态“元信息”文件</li><li>BitTorrent跟踪器</li><li>“原始”下载者</li><li>终端用户的Web浏览器</li><li>终端用户的下载器</li></ul><p>理想情况下，一个文件应该有多个终端用户。</p><h3 id="服务端准备步骤："><a href="#服务端准备步骤：" class="headerlink" title="服务端准备步骤："></a>服务端准备步骤：</h3><ol><li>启动一个跟踪器（或更可能是已经在运行一个）。</li><li>启动一个普通的Web服务器，例如Apache，或已经有一个。</li><li>将.torrent扩展名与MIME类型application&#x2F;x-bittorrent关联（或已经完成）。</li><li>使用要服务的完整文件和跟踪器的URL生成一个元信息（.torrent）文件。</li><li>将元信息文件放置在Web服务器上。</li><li>从其他网页链接到元信息（.torrent）文件。</li><li>启动一个已经拥有完整文件的下载器（“原点”）。</li></ol><h3 id="用户下载步骤："><a href="#用户下载步骤：" class="headerlink" title="用户下载步骤："></a>用户下载步骤：</h3><ol><li>安装BitTorrent（或已经完成）。</li><li>浏览网页。</li><li>点击.torrent文件的链接。</li><li>选择在本地保存文件的位置，或选择恢复部分下载。</li><li>等待下载完成。</li><li>告诉下载器退出（在这之前，它会继续上传）。</li></ol><h2 id="bencoding"><a href="#bencoding" class="headerlink" title="bencoding"></a>bencoding</h2><ul><li>字符串以长度前缀表示，后跟一个冒号和字符串。例如，<code>4:spam</code>对应于“spam”。</li><li>整数以“i”开头，后跟十进制数字，再以“e”结束。例如，<code>i3e</code>对应于3，i-3e对应于-3。整数没有大小限制。i-0e是无效的。以零开头的所有编码，例如i03e，都是无效的，除了i0e，它当然对应于0。</li><li>列表以“l”开头，后跟其元素（也经过bencoding编码），最后以“e”结束。例如，<code>l4:spam4:eggse</code>对应于[‘spam’, ‘eggs’]。</li><li>字典以“d”开头，后跟一个交替的键值对列表，最后以“e”结束。例如，<code>d3:cow3:moo4:spam4:eggse</code>对应于{‘cow’: ‘moo’, ‘spam’: ‘eggs’}，而<code>d4:spaml1:a1:bee</code>对应于{‘spam’: [‘a’, ‘b’]}。键必须是字符串并按排序顺序出现（按原始字符串排序，而非字母数字）。</li></ul><h2 id="元信息文件"><a href="#元信息文件" class="headerlink" title="元信息文件"></a>元信息文件</h2><p>元信息文件（也称为.torrent文件）是一个bencoded字典，包含以下键：</p><ul><li><strong>announce</strong>：跟踪器的URL。</li><li><strong>info</strong>：映射到一个字典，下面描述了其键。</li></ul><p>所有包含文本的.torrent文件中的字符串必须是UTF-8编码。</p><h2 id="info字典"><a href="#info字典" class="headerlink" title="info字典"></a>info字典</h2><ul><li><strong>name</strong>：键映射到一个UTF-8编码的字符串，建议将文件（或目录）保存为的名称。这是纯粹的建议。</li><li><strong>piece length</strong>：映射到文件分割成的每个片段的字节数。为了传输，文件被分割成固定大小的片段，除非最后一个片段可能被截断，所有片段通常都是相同长度的。piece length几乎总是2的幂，最常见的是2^18 &#x3D; 256 K（BitTorrent在3.2版本之前使用2^20 &#x3D; 1 M作为默认值）。</li><li><strong>pieces</strong>：映射到一个长度是20的倍数的字符串。它被细分为长度为20的字符串，每个字符串是相应索引的片段的SHA1哈希。</li></ul><p>还可以有一个<strong>length</strong>或<strong>files</strong>键，但不能同时存在。<br>如果length存在，则下载表示单个文件；否则，它表示一组在目录结构的文件。<br>在单文件情况下，length映射到文件的字节长度。</p><p>在其他键的目的上，多文件情况被视为只有一个文件，通过按文件列表中出现的顺序连接文件。文件列表的值是files，映射到一个字典列表，包含以下键：</p><ul><li><strong>length</strong>：文件的字节长度。</li><li><strong>path</strong>：对应子目录名称的UTF-8编码字符串列表，最后一个是实际文件名（零长度列表是错误情况）。</li></ul><p>在单文件情况下，name键是文件名；在多文件情况下，它是目录名。</p><h2 id="跟踪器"><a href="#跟踪器" class="headerlink" title="跟踪器"></a>跟踪器</h2><p>跟踪器的GET请求具有以下键：</p><ul><li><strong>info_hash</strong>：bencoded形式的info值的20字节SHA1哈希。该值几乎肯定需要进行转义。<br>请注意，这个值是元信息文件的一个子串。info-hash必须是编码形式的哈希，正如在.torrent文件中找到的那样，这与b解码元信息文件、提取info字典并编码相同，仅当bencode完全验证输入（例如，键排序、没有前导零）时才能这样做。<br>相反，这意味着客户端必须拒绝无效的元信息文件，或者直接提取子串。它们不得在无效数据上进行解码-编码的循环。</li><li><strong>peer_id</strong>：下载器使用的长度为20的字符串作为其ID。每个下载器在新的下载开始时随机生成自己的ID。该值也几乎肯定需要进行转义。</li><li><strong>ip</strong>：可选参数，给出该对等体的IP（或DNS名称）。通常用于原点，如果它与跟踪器在同一台机器上。</li><li><strong>port</strong>：该对等体正在监听的端口号。通常的行为是下载器尝试监听6881端口，如果该端口已被占用，则尝试6882、6883等，并在6889之后放弃。</li><li><strong>uploaded</strong>：到目前为止，总共上传的量，以十进制ASCII编码。</li><li><strong>downloaded</strong>：到目前为止，总共下载的量，以十进制ASCII编码。</li><li><strong>left</strong>：该对等体仍需下载的字节数，以十进制ASCII编码。请注意，这不能从下载量和文件长度计算出来，因为它可能是恢复下载，且有可能部分下载的数据未通过完整性检查，必须重新下载。</li><li><strong>event</strong>：这是一个可选键，映射到started、completed或stopped（或空，表示与不出现时相同）。如果不存在，则这是定期进行的公告之一。<br>当下载首次开始时，会发送使用started的公告；当下载完成时，会发送使用completed的公告。如果文件在开始时已完成，则不会发送completed。下载者在停止下载时发送一个使用stopped的公告。</li></ul><p>跟踪器响应是bencoded字典。如果跟踪器响应有一个键failure reason，则它映射到一个可读字符串，解释查询失败的原因，且不需要其他键。<br>否则，它必须有两个键：interval，映射到下载器应该等待的秒数，以便进行定期重新请求，和peers。peers映射到对应对等体的字典列表，每个字典包含peer id、ip和port键，分别映射到对等体自选的ID、IP地址或DNS名称作为字符串和端口号。<br>请注意，下载者在发生事件或需要更多对等体时，可以在非预定时间重新请求。</p><p>更常见的是，跟踪器返回对等体列表的紧凑表示，见<a class="link"   href="http://ll.www.bittorrent.org/beps/bep_0023.html" >BEP 23<i class="fas fa-external-link-alt"></i></a>。<br>如果您想对元信息文件或跟踪器查询进行任何扩展，请与Bram Cohen协调，以确保所有扩展都是兼容的。<br>通常通过<a class="link"   href="http://ll.www.bittorrent.org/beps/bep_0015.html" >UDP跟踪器协议<i class="fas fa-external-link-alt"></i></a>进行公告。</p><h2 id="对等协议"><a href="#对等协议" class="headerlink" title="对等协议"></a>对等协议</h2><p>BitTorrent的对等协议通过TCP或<a class="link"   href="http://ll.www.bittorrent.org/beps/bep_0029.html" >uTP<i class="fas fa-external-link-alt"></i></a>运行。<br>对等连接是对称的。双向发送的消息看起来相同，数据可以在任一方向流动。</p><p>对等协议通过索引引用文件的片段，如元信息文件中所描述，从零开始。当对等体完成下载一个片段并检查哈希匹配时，它会向所有对等体宣布它拥有该片段。<br>连接在两端包含两个状态位：阻塞或不阻塞，以及感兴趣或不感兴趣。阻塞是一个通知，在解除阻塞之前不会发送任何数据。阻塞背后的原因和常见技术将在本文档后面解释。</p><p>数据传输发生在一个对等体（peer）感兴趣而另一个对等体没有被阻塞（unchoked）时。兴趣状态必须始终保持更新——当下载者在未被阻塞的情况下，发现没有什么需要请求的内容时，他们必须表达缺乏兴趣，即使他们当前被阻塞。<br>这一过程的实现比较复杂，但这样做的目的是让下载者能够知道，哪些对等体在解除阻塞后会立即开始下载。</p><p>连接开始时被阻塞且不感兴趣。<br>当数据正在传输时，下载者应同时保持多个片段请求排队，以获得良好的TCP性能（这被称为“流水线”）。另一方面，无法立即写入TCP缓冲区的请求应在内存中排队，而不是保留在应用程序级别的网络缓冲区，以便在发生阻塞时可以全部丢弃。<br>对等协议的消息流由握手开始，后跟一个永无止境的长度前缀消息流。握手以字符19（十进制）开头，后跟字符串“BitTorrent protocol”。前导字符是长度前缀，旨在希望其他新协议也能这样做，从而彼此显著区分。<br>所有后续发送的整数都以四字节大端格式编码。<br>在固定头之后，有八个保留字节，当前实现中都为零。如果您希望使用这些字节扩展协议，请与Bram Cohen协调，以确保所有扩展都是兼容的。</p><p>接下来是元信息文件中info值的20字节SHA1哈希（这是跟踪器上公告为info_hash的相同值，只是在这里是原始的而不是引用的）。如果双方发送的值不相同，则断开连接。<br>一个可能的例外是，如果下载者希望通过单个端口进行多个下载，他们可能会等待传入连接首先提供下载哈希，并在其列表中如果存在则响应相同的值。<br>握手之后，接下来是一个交替的长度前缀和消息的流。长度为零的消息是保持活跃消息，忽略。保持活跃消息通常每两分钟发送一次，但在期望数据时超时可以更快完成。</p><h2 id="对等消息"><a href="#对等消息" class="headerlink" title="对等消息"></a>对等消息</h2><p>所有非保持活跃消息以一个单字节开头，表示其类型。</p><p>可能的值是：</p><ul><li>0 - choke</li><li>1 - unchoke</li><li>2 - interested</li><li>3 - not interested</li><li>4 - have</li><li>5 - bitfield</li><li>6 - request</li><li>7 - piece</li><li>8 - cancel</li></ul><p>“choke”、“unchoke”、“interested”和“not interested”没有负载。<br>“bitfield”只在首次消息中发送。其负载是一个比特字段，下载者发送的每个索引设置为1，其余设置为0。尚未拥有任何内容的下载者可以跳过“bitfield”消息。比特字段的第一个字节对应于高位到低位的索引0-7，第二个字节对应于8-15，以此类推。末尾的闲置位设置为零。<br>“have”消息的负载是一个单一数字，即该下载者刚刚完成并检查哈希的索引。<br>“request”消息包含索引、开始和长度。最后两个是字节偏移。长度通常是2的幂，除非在文件末尾被截断。所有当前实现使用2^14（16 KiB），并关闭请求大于该量的连接。<br>“cancel”消息的负载与请求消息相同。它们通常仅在下载接近完成时发送，在所谓的“结束模式”下。当下载几乎完成时，最后几个片段通常全部从一个拥挤的调制解调器线路下载，耗时很长。为了确保最后几个片段快速到达，一旦所有该下载者尚未拥有的片段的请求正在进行，它会向所有正在下载的对等体发送请求。为了避免效率低下，它在每次接收到片段时向其他所有对等体发送取消。<br>“piece”消息包含索引、开始和片段。请注意，它们与请求消息隐含相关。如果在快速连续发送的阻塞和解除阻塞消息中，可能会收到意外的片段。</p><p>下载者通常以随机顺序下载片段，这样可以合理地避免拥有任何对等体的片段的严格子集或超集。<br>阻塞是出于多种原因。TCP拥塞控制在同时通过多个连接发送时表现非常差。此外，阻塞让每个对等体使用一种互惠算法，确保它们获得一致的下载速度。</p><p>以下描述的阻塞算法是当前部署的算法。所有新算法在由它们自身组成的网络中和以此为主的网络中都应良好运作。<br>一个好的阻塞算法应满足多个标准。<br>它应限制同时上传的数量以确保良好的TCP性能。<br>它应避免快速阻塞和解除阻塞，这称为“颤动”。<br>它应对让其下载的对等体进行互惠。<br>最后，它应偶尔尝试未使用的连接，以查找它们是否可能比当前使用的连接更好，这称为乐观解除阻塞。</p><p>当前部署的阻塞算法通过每十秒钟仅更改被阻塞的对象，避免了颤动。它通过解除四个上传速率最佳且感兴趣的对等体来实现互惠和上传数量的限制。<br>那些上传速率更好但不感兴趣的对等体会被解除阻塞，如果它们变得感兴趣，则最差的上传者会被阻塞。如果下载者拥有完整文件，它会使用其上传速率而非下载速率来决定解除哪个对等体的阻塞。<br>在乐观解除阻塞方面，任何时候都有一个对等体被解除阻塞，无论其上传速率如何（如果感兴趣，它会算作四个允许的下载者之一）。被乐观解除阻塞的对等体每30秒轮换一次。为了给它们一个良好的机会上传完整的片段，新连接比当前乐观解除阻塞的连接更有三倍的可能性。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="http://ll.www.bittorrent.org/beps/bep_0003.html" >The BitTorrent Protocol Specification<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BitTorrent协议规范&quot;&gt;&lt;a href=&quot;#BitTorrent协议规范&quot; class=&quot;headerlink&quot; title=&quot;BitTorrent协议规范&quot;&gt;&lt;/a&gt;BitTorrent协议规范&lt;/h2&gt;&lt;p&gt;BitTorrent是一个用于分发文件的协议</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://cooooing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Bencode编码" scheme="https://cooooing.github.io/tags/Bencode%E7%BC%96%E7%A0%81/"/>
    
    <category term="BitTorrent" scheme="https://cooooing.github.io/tags/BitTorrent/"/>
    
    <category term="p2p" scheme="https://cooooing.github.io/tags/p2p/"/>
    
  </entry>
  
  <entry>
    <title>Bencode编码</title>
    <link href="https://cooooing.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Bencode%E7%BC%96%E7%A0%81/"/>
    <id>https://cooooing.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Bencode%E7%BC%96%E7%A0%81/</id>
    <published>2024-10-12T02:46:02.000Z</published>
    <updated>2024-10-12T02:46:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bencode"><a href="#Bencode" class="headerlink" title="Bencode"></a>Bencode</h2><p>Bencode（发音为Bee-Encode）是 BitTorrent 用在传输数据结构的编码方式。</p><p>这种编码方式支持四种资料类型：</p><ul><li>字符串</li><li>整数</li><li>串列</li><li>字典表</li></ul><p>Bencode 最常被用在 .torrent 档中，文件里的元数据都是被 Bencode 编码过的字典表。这种编码方法也被 Tracker 返回响应时使用。</p><p>虽然比用纯二进制编码效率低，但 Bencode 结构简单而且不受字节存储顺序影响（所有数字以十进制编码），这对于跨平台性非常重要。并且，Bencode<br>具有较好的灵活性，即使存在故障的字典键，只要将其忽略并更换新的就能兼容补充。</p><h2 id="编码方法"><a href="#编码方法" class="headerlink" title="编码方法"></a>编码方法</h2><p>Bencode 使用 ASCII 字符进行编码。</p><p>Bencode（BitTorrent 编码）是一种简单且轻量级的序列化格式，主要用于 BitTorrent 协议中的元数据文件（<code>.torrent</code> 文件）。Bencode<br>支持四种基本类型：整数、字符串、列表和字典。下面是 Bencode 的详细介绍，包括其语法、数据类型和一些示例。</p><ol><li>整数<ul><li>语法：<code>i&lt;数字&gt;e</code> <strong>int 整数 end</strong></li><li>示例：<code>i123e</code> 表示整数 123</li><li><blockquote><p>负数和零也是有效的，例如 <code>i-123e</code> 表示 -123，<code>i0e</code> 表示 0，但是不可以使用 <code>i-0e</code> 包括其他除了<code>i0e</code>的具有前导0的（<code>i03e</code>）都是无效的。</p></blockquote></li></ul></li><li>字符串<ul><li>语法：<code>&lt;长度&gt;:&lt;字符串&gt;</code></li><li>示例：<code>4:spam</code> 表示字符串 “spam”</li><li><blockquote><p>长度是指字符串的<strong>字节数</strong>，而不是字符数</p></blockquote></li></ul></li><li>列表<ul><li>语法：<code>l&lt;元素1&gt;&lt;元素2&gt;...e</code> <strong>list 列表 end</strong></li><li>示例：<code>l4:spam3:fooi42ee</code> 表示列表 <code>[&quot;spam&quot;, &quot;foo&quot;, 42]</code></li><li><blockquote><p>列表中的元素可以是任何 Bencode 支持的类型</p></blockquote></li></ul></li><li>字典<ul><li>语法：<code>d&lt;键1&gt;&lt;值1&gt;&lt;键2&gt;&lt;值2&gt;...e</code> <strong>dictionary 字典 end</strong></li><li>示例：<code>d3:bar4:spam3:fooi42ee</code> 表示字典 <code>&#123;&quot;bar&quot;: &quot;spam&quot;, &quot;foo&quot;: 42&#125;</code></li><li><blockquote><p><strong>字典中的键必须是字符串</strong>，并且按键的字典序排序</p></blockquote></li></ul></li></ol><p>复杂结构的 Bencode 示例：<br>包含嵌套结构的 Bencode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d8:announce22:https://tracker.example.com/announce4:infod6:lengthi1000e4:name4:file15:piece lengthi262144e6:pieces20:0123456789abcdef0123456789abcdefe</span><br></pre></td></tr></table></figure><p>表示一个包含嵌套字典和列表的复杂结构，类似于以下 JSON：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;announce&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://tracker.example.com/announce&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;length&quot;</span><span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;file&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;piece length&quot;</span><span class="punctuation">:</span> <span class="number">262144</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pieces&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0123456789abcdef0123456789abcdef&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Bencode-编解码实现"><a href="#Bencode-编解码实现" class="headerlink" title="Bencode 编解码实现"></a>Bencode 编解码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.kernel.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BencodeUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encode</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">case</span> Map&lt;?, ?&gt; map -&gt; &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : map.entrySet()) &#123;</span><br><span class="line">                    sb.append(encode(entry.getKey()));</span><br><span class="line">                    sb.append(encode(entry.getValue()));</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> Integer ignored -&gt; sb.append(<span class="string">&quot;i&quot;</span>).append(obj).append(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> List&lt;?&gt; list -&gt; &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;l&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (Object item : list) &#123;</span><br><span class="line">                    sb.append(encode(item));</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> String str -&gt; sb.append(str.length()).append(<span class="string">&#x27;:&#x27;</span>).append(str);</span><br><span class="line">            <span class="keyword">case</span> <span class="literal">null</span>, <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unsupported type: &quot;</span> + obj.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">decode</span><span class="params">(<span class="type">byte</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        o = decodeObject(s, <span class="number">0</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法：解码对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] decodeObject(<span class="type">byte</span>[] s, <span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> s[index];</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="string">&#x27;i&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 整数类型</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> index;</span><br><span class="line">            <span class="keyword">while</span> (s[index] != <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> Long.parseLong(<span class="keyword">new</span> <span class="title class_">String</span>(s, start, index - start));</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;value, index&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= b &amp;&amp; b &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 字符串类型</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> index;</span><br><span class="line">            <span class="keyword">while</span> (s[index] != <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(s, start, index - start));</span><br><span class="line">            index++;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(s, index, length);</span><br><span class="line">            index += length;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;str, index&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="string">&#x27;d&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 字典类型</span></span><br><span class="line">            index++;</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (s[index] != <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">                Object[] keyResult = decodeObject(s, index);</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> (String) keyResult[<span class="number">0</span>];</span><br><span class="line">                index = (<span class="type">int</span>) keyResult[<span class="number">1</span>];</span><br><span class="line">                Object[] valueResult = decodeObject(s, index);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> valueResult[<span class="number">0</span>];</span><br><span class="line">                index = (<span class="type">int</span>) valueResult[<span class="number">1</span>];</span><br><span class="line">                map.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;map, index&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="string">&#x27;l&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 列表类型</span></span><br><span class="line">            index++;</span><br><span class="line">            List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (s[index] != <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">                Object[] result = decodeObject(s, index);</span><br><span class="line">                list.add(result[<span class="number">0</span>]);</span><br><span class="line">                index = (<span class="type">int</span>) result[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;list, index&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 忽略无效的字符</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> decodeObject(s, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Bencode&quot;&gt;&lt;a href=&quot;#Bencode&quot; class=&quot;headerlink&quot; title=&quot;Bencode&quot;&gt;&lt;/a&gt;Bencode&lt;/h2&gt;&lt;p&gt;Bencode（发音为Bee-Encode）是 BitTorrent 用在传输数据结构的编码方式。&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://cooooing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://cooooing.github.io/tags/java/"/>
    
    <category term="Bencode编码" scheme="https://cooooing.github.io/tags/Bencode%E7%BC%96%E7%A0%81/"/>
    
    <category term="BitTorrent" scheme="https://cooooing.github.io/tags/BitTorrent/"/>
    
    <category term="p2p" scheme="https://cooooing.github.io/tags/p2p/"/>
    
  </entry>
  
  <entry>
    <title>计算字符串相似度</title>
    <link href="https://cooooing.github.io/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%BC%BC%E5%BA%A6/"/>
    <id>https://cooooing.github.io/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%BC%BC%E5%BA%A6/</id>
    <published>2024-09-02T11:57:58.000Z</published>
    <updated>2024-09-02T11:57:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>今天有个需求中需要定时同步数据，同步的判断条件是某个字段的相似度要大于 80%<br>于是有了下面这篇文章。</p><p>为了方便同步脚本的编写，提供了 Oracle 的函数版本，以便在sql中调用。</p><h2 id="Levenshtein距离"><a href="#Levenshtein距离" class="headerlink" title="Levenshtein距离"></a>Levenshtein距离</h2><p>首先介绍下 <a class="link"   href="https://zh.wikipedia.org/wiki/%E8%90%8A%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E9%9B%A2" >Levenshtein 距离（编辑距离）<i class="fas fa-external-link-alt"></i></a></p><p><strong>莱文斯坦距离</strong>（英语：Levenshtein distance）是编辑距离的一种。指两个字串之间，由一个转成另一个所需的最少编辑操作次数。</p><p>允许的编辑操作包括：</p><ul><li>将一个字符替换成另一个字符</li><li>插入一个字符</li><li>删除一个字符</li></ul><p>俄罗斯科学家弗拉基米尔·莱文斯坦在1965年提出这个概念。</p><p>下面是它的数学定义</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%BC%BC%E5%BA%A6/Levenshtein%E8%B7%9D%E7%A6%BB%E7%9A%84%E6%95%B0%E5%AD%A6%E5%AE%9A%E4%B9%89.png"                        alt="Levenshtein距离的数学定义.png"                 ></p><h2 id="字符串相似度的实现"><a href="#字符串相似度的实现" class="headerlink" title="字符串相似度的实现"></a>字符串相似度的实现</h2><h3 id="java-全矩阵迭代（动态规划）-实现"><a href="#java-全矩阵迭代（动态规划）-实现" class="headerlink" title="java 全矩阵迭代（动态规划） 实现"></a>java 全矩阵迭代（动态规划） 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">getSimilarityRatio</span><span class="params">(String str, String target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp; <span class="comment">// 记录相同字符，在某个矩阵位置值的增量。相同为0，不同为1</span></span><br><span class="line">    <span class="keyword">if</span> (str.isEmpty() || target.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化矩阵</span></span><br><span class="line">    <span class="type">int</span>[][] d = <span class="keyword">new</span> <span class="title class_">int</span>[str.length() + <span class="number">1</span>][target.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= str.length(); i++) &#123; <span class="comment">// 初始化第一列</span></span><br><span class="line">        d[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= target.length(); j++) &#123; <span class="comment">// 初始化第一行</span></span><br><span class="line">        d[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态规划填充矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= str.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch1</span> <span class="operator">=</span> str.charAt(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= target.length(); j++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch2</span> <span class="operator">=</span> target.charAt(j - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (ch1 == ch2) &#123;</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            d[i][j] = Math.min(Math.min(d[i - <span class="number">1</span>][j] + <span class="number">1</span>, d[i][j - <span class="number">1</span>] + <span class="number">1</span>), d[i - <span class="number">1</span>][j - <span class="number">1</span>] + temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算相似度 1 - (Levenshtein 距离 / 两字符串最大长度) * 100%</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> - (<span class="type">float</span>) d[str.length()][target.length()] / Math.max(str.length(), target.length())) * <span class="number">100F</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="oracle-函数-全矩阵迭代-实现"><a href="#oracle-函数-全矩阵迭代-实现" class="headerlink" title="oracle 函数 全矩阵迭代 实现"></a>oracle 函数 全矩阵迭代 实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">-- 创建临时表，用于存储矩阵（过程值）</span><br><span class="line">CREATE GLOBAL TEMPORARY TABLE similarity_matrix</span><br><span class="line">(</span><br><span class="line">    id1   NUMBER,</span><br><span class="line">    id2   NUMBER,</span><br><span class="line">    value NUMBER</span><br><span class="line">) ON COMMIT DELETE ROWS;</span><br><span class="line"></span><br><span class="line">-- 创建函数 计算字符串相似度</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE FUNCTION func_get_similarity_ratio(str VARCHAR2, target VARCHAR2) RETURN NUMBER DETERMINISTIC IS</span><br><span class="line">    -- 使用自治事务</span><br><span class="line">    pragma autonomous_transaction;</span><br><span class="line">    n     NUMBER := LENGTH(str);</span><br><span class="line">    m     NUMBER := LENGTH(target);</span><br><span class="line">    i     NUMBER;</span><br><span class="line">    j     NUMBER;</span><br><span class="line">    temp  NUMBER;</span><br><span class="line">    d_val NUMBER;</span><br><span class="line">    ch1   VARCHAR2(1);</span><br><span class="line">    ch2   VARCHAR2(1);</span><br><span class="line">BEGIN</span><br><span class="line">    IF n = 0 OR m = 0 THEN</span><br><span class="line">        RETURN 0;</span><br><span class="line">    END IF;</span><br><span class="line"></span><br><span class="line">    -- 初始化矩阵的第一列</span><br><span class="line">    FOR i IN 0..n</span><br><span class="line">        LOOP</span><br><span class="line">            INSERT INTO similarity_matrix(id1, id2, value) VALUES (i, 0, i);</span><br><span class="line">        END LOOP;</span><br><span class="line"></span><br><span class="line">    -- 初始化矩阵的第一行</span><br><span class="line">    FOR j IN 0..m</span><br><span class="line">        LOOP</span><br><span class="line">            INSERT INTO similarity_matrix(id1, id2, value) VALUES (0, j, j);</span><br><span class="line">        END LOOP;</span><br><span class="line"></span><br><span class="line">    -- 动态规划填充矩阵</span><br><span class="line">    FOR i IN 1..n</span><br><span class="line">        LOOP</span><br><span class="line">            FOR j IN 1..m</span><br><span class="line">                LOOP</span><br><span class="line">                    ch1 := SUBSTR(str, i, 1);</span><br><span class="line">                    ch2 := SUBSTR(target, j, 1);</span><br><span class="line"></span><br><span class="line">                    IF ch1 = ch2 THEN</span><br><span class="line">                        temp := 0;</span><br><span class="line">                    ELSE</span><br><span class="line">                        temp := 1;</span><br><span class="line">                    END IF;</span><br><span class="line"></span><br><span class="line">                    -- 获取三者中的最小值</span><br><span class="line">                    SELECT MIN(value)</span><br><span class="line">                    INTO d_val</span><br><span class="line">                    FROM (SELECT value + 1 as value FROM similarity_matrix WHERE id1 = i - 1   AND id2 = j union</span><br><span class="line">                          SELECT value + 1 as value FROM similarity_matrix WHERE id1 = i   AND id2 = j - 1 union</span><br><span class="line">                          SELECT value + temp as value FROM similarity_matrix WHERE id1 = i - 1 AND id2 = j - 1);</span><br><span class="line"></span><br><span class="line">                    -- 更新当前格子的值</span><br><span class="line">                    INSERT INTO similarity_matrix(id1, id2, value) VALUES (i, j, d_val);</span><br><span class="line">                END LOOP;</span><br><span class="line">        END LOOP;</span><br><span class="line"></span><br><span class="line">    SELECT value into d_val FROM similarity_matrix WHERE id1 = n AND id2 = m;</span><br><span class="line">    commit;</span><br><span class="line">    -- 计算并返回相似度</span><br><span class="line">    RETURN (1 - round(d_val / GREATEST(n, m), 4)) * 100;</span><br><span class="line">END func_get_similarity_ratio;</span><br><span class="line"></span><br><span class="line">-- 调用函数测试</span><br><span class="line">select func_get_similarity_ratio(&#x27;12345a&#x27;, &#x27;12345A&#x27;) as ratio</span><br><span class="line">from dual;</span><br></pre></td></tr></table></figure><h3 id="java-递归实现"><a href="#java-递归实现" class="headerlink" title="java 递归实现"></a>java 递归实现</h3><p>递归返回 Levenshtein 距离，相似度可按照 <code>1 - (Levenshtein 距离 / 两字符串最大长度) * 100%</code> 公式计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSimilarityRatio</span><span class="params">(String str, <span class="type">int</span> strLength, String target, <span class="type">int</span> targetLength)</span> &#123;</span><br><span class="line">    <span class="comment">// 递归回归点</span></span><br><span class="line">    <span class="keyword">if</span> (strLength == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> targetLength;</span><br><span class="line">    <span class="keyword">if</span> (targetLength == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> strLength;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cos;</span><br><span class="line">    <span class="keyword">if</span> (str.charAt(strLength - <span class="number">1</span>) == target.charAt(targetLength - <span class="number">1</span>))</span><br><span class="line">        cos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cos = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">re1</span> <span class="operator">=</span> getSimilarityRatio(str, strLength - <span class="number">1</span>, target, targetLength) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">re2</span> <span class="operator">=</span> getSimilarityRatio(str, strLength, target, targetLength - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">re3</span> <span class="operator">=</span> getSimilarityRatio(str, strLength - <span class="number">1</span>, target, targetLength - <span class="number">1</span>) + cos;</span><br><span class="line">    <span class="comment">// 三个中的最小值</span></span><br><span class="line">    <span class="keyword">return</span> re1 &lt; re2 ? (Math.min(re1, re3)) : (Math.min(re2, re3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2024-10-09-fix-添加对中文字符的支持"><a href="#2024-10-09-fix-添加对中文字符的支持" class="headerlink" title="2024-10-09 fix: 添加对中文字符的支持"></a>2024-10-09 fix: 添加对中文字符的支持</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">create FUNCTION func_get_similarity_ratio(str VARCHAR2, target VARCHAR2) RETURN NUMBER DETERMINISTIC IS</span><br><span class="line">    PRAGMA AUTONOMOUS_TRANSACTION;</span><br><span class="line">    n     NUMBER := LENGTH(str);</span><br><span class="line">    m     NUMBER := LENGTH(target);</span><br><span class="line">    i     NUMBER;</span><br><span class="line">    j     NUMBER;</span><br><span class="line">    temp  NUMBER;</span><br><span class="line">    d_val NUMBER;</span><br><span class="line">    ch1   VARCHAR2(1 CHAR);</span><br><span class="line">    ch2   VARCHAR2(1 CHAR);</span><br><span class="line">BEGIN</span><br><span class="line">    IF n = 0 OR m = 0 THEN</span><br><span class="line">        RETURN 0;</span><br><span class="line">    END IF;</span><br><span class="line"></span><br><span class="line">    -- 初始化矩阵的第一列</span><br><span class="line">    FOR i IN 0..n</span><br><span class="line">        LOOP</span><br><span class="line">            INSERT INTO similarity_matrix(id1, id2, value) VALUES (i, 0, i);</span><br><span class="line">        END LOOP;</span><br><span class="line"></span><br><span class="line">    -- 初始化矩阵的第一行</span><br><span class="line">    FOR j IN 0..m</span><br><span class="line">        LOOP</span><br><span class="line">            INSERT INTO similarity_matrix(id1, id2, value) VALUES (0, j, j);</span><br><span class="line">        END LOOP;</span><br><span class="line"></span><br><span class="line">    -- 动态规划填充矩阵</span><br><span class="line">    FOR i IN 1..n</span><br><span class="line">        LOOP</span><br><span class="line">            FOR j IN 1..m</span><br><span class="line">                LOOP</span><br><span class="line">                    ch1 := SUBSTR(str, i, 1);</span><br><span class="line">                    ch2 := SUBSTR(target, j, 1);</span><br><span class="line"></span><br><span class="line">                    IF ch1 = ch2 THEN</span><br><span class="line">                        temp := 0;</span><br><span class="line">                    ELSE</span><br><span class="line">                        temp := 1;</span><br><span class="line">                    END IF;</span><br><span class="line"></span><br><span class="line">                    -- 定义变量存储左、上、左上角的值</span><br><span class="line">                    SELECT MIN(value)</span><br><span class="line">                    INTO d_val</span><br><span class="line">                    FROM (SELECT value + 1 as value FROM similarity_matrix WHERE id1 = i - 1   AND id2 = j union</span><br><span class="line">                          SELECT value + 1 as value FROM similarity_matrix WHERE id1 = i   AND id2 = j - 1 union</span><br><span class="line">                          SELECT value + temp as value FROM similarity_matrix WHERE id1 = i - 1 AND id2 = j - 1);</span><br><span class="line"></span><br><span class="line">                    -- 更新当前格子的值</span><br><span class="line">                    INSERT INTO similarity_matrix(id1, id2, value) VALUES (i, j, d_val);</span><br><span class="line">                END LOOP;</span><br><span class="line">        END LOOP;</span><br><span class="line"></span><br><span class="line">    SELECT value INTO d_val FROM similarity_matrix WHERE id1 = n AND id2 = m;</span><br><span class="line"></span><br><span class="line">    COMMIT;</span><br><span class="line"></span><br><span class="line">    -- 计算并返回相似度</span><br><span class="line">    RETURN (1 - d_val / GREATEST(n, m)) * 100;</span><br><span class="line">END func_get_similarity_ratio;</span><br></pre></td></tr></table></figure><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>这种基于矩阵迭代的算法，时间复杂度和空间复杂度都是 O(m * n) 。其中，m 是第一个字符串的长度，n 是第二个字符串的长度。<br>对于长字符串效率可能会较低。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Start&quot;&gt;&lt;a href=&quot;#Start&quot; class=&quot;headerlink&quot; title=&quot;Start&quot;&gt;&lt;/a&gt;Start&lt;/h2&gt;&lt;p&gt;今天有个需求中需要定时同步数据，同步的判断条件是某个字段的相似度要大于 80%&lt;br&gt;于是有了下面这篇文章。&lt;/p&gt;</summary>
      
    
    
    
    <category term="编程记录" scheme="https://cooooing.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="java" scheme="https://cooooing.github.io/tags/java/"/>
    
    <category term="字符串" scheme="https://cooooing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="sql" scheme="https://cooooing.github.io/tags/sql/"/>
    
    <category term="算法" scheme="https://cooooing.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="编辑距离" scheme="https://cooooing.github.io/tags/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>《收获，不止Oracle》读书笔记下篇</title>
    <link href="https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8B%E7%AF%87/"/>
    <id>https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8B%E7%AF%87/</id>
    <published>2024-08-29T10:09:22.000Z</published>
    <updated>2024-08-29T10:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>下篇的章节，主要是作者多年优化工作中的经验总结。<br>主要是关于解决问题的思路，如何定位问题等。技术相关的其实不多。我也觉得<strong>会发现问题比会解决问题的人更厉害</strong>。<br>这几章经典的优化操作，主要的思想就是以下这些。（我读完的总结，不一定全。）</p><ol><li>少做事，在可以满足需求的情况下，尽量不做无意义的事。毕竟再怎么优化也没有不做快。比如，排序是否需要，一定要的情况下是否可以走索引，所以是有序的，可以避免排序。</li><li>提问的方式，描述问题要准确、有重点。避免太过简单或者太过复杂。另外，不要问以前问过的问题，勤用搜索引擎和动手实践独立解决问题。</li><li>规范，学习、操作、流程、开发、设计等等方面都需要有规范，规范可以提高效率避免出错。</li></ol><p>下面是一些命令，用于排查问题等。</p><h3 id="流程规范-保障问题快速解决"><a href="#流程规范-保障问题快速解决" class="headerlink" title="流程规范 保障问题快速解决"></a>流程规范 保障问题快速解决</h3><h4 id="动态整体"><a href="#动态整体" class="headerlink" title="动态整体"></a>动态整体</h4><p>主机动态情况检查</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主机情况检查（数据库出问题，主机是首先要查看的，皮之不存，毛将焉附）</span></span><br><span class="line">uname -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查主机CPU等使用情况（重点关注时间最长的，同时也注意观察主机的内存的物理大小和CPU的个数)</span></span><br><span class="line">top </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报告虚拟内存统计信息以及其他与系统活动相关的信息 1 10 表示每秒输出一次统计信息，一共输出10次</span></span><br><span class="line">vmstat 1 10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计所有包含 <span class="string">&quot;ora&quot;</span> 的进程数。</span></span><br><span class="line">ps -ef |grep ora |wc -l</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计所有既包含 <span class="string">&quot;ora&quot;</span> 又包含 <span class="string">&quot;LOCAL&quot;</span> 的进程数，这通常指本地监听器和数据库实例的进程。</span></span><br><span class="line">ps -ef |grep ora |grep LOCAL |wc -l</span><br></pre></td></tr></table></figure><p>vmstat 命令输出结果含义：</p><ul><li><code>procs</code>:<ul><li><code>r</code>: 当前运行和可运行（等待运行）的进程数。</li><li><code>b</code>: 处于不可中断睡眠状态的进程数。</li></ul></li><li><code>memory</code>:<ul><li><code>swpd</code>: 使用的虚拟内存交换空间大小（KB）。</li><li><code>free</code>: 空闲物理内存大小（KB）。</li><li><code>buff</code>: 用作缓冲区的物理内存大小（KB）。</li><li><code>cache</code>: 用作缓存的物理内存大小（KB）。</li></ul></li><li><code>swap</code>:<ul><li><code>si</code>: 每秒从磁盘交换到内存的大小（KB&#x2F;s）。</li><li><code>so</code>: 每秒从内存交换到磁盘的大小（KB&#x2F;s）。</li></ul></li><li><code>io</code>:<ul><li><code>bi</code>: 每秒从块设备读取的数据量（KB&#x2F;s）。</li><li><code>bo</code>: 每秒写入块设备的数据量（KB&#x2F;s）。</li></ul></li><li><code>system</code>:<ul><li><code>in</code>: 每秒发生的中断次数。</li><li><code>cs</code>: 每秒上下文切换次数。</li></ul></li><li><code>cpu</code>:<ul><li><code>us</code>: 用户空间占用的 CPU 百分比。</li><li><code>sy</code>: 内核空间占用的 CPU 百分比。</li><li><code>id</code>: 空闲 CPU 百分比。</li><li><code>wa</code>: 等待 I&#x2F;O 完成的 CPU 百分比。</li><li><code>st</code>: 被窃取的时间百分比（仅在虚拟化环境中可见）。</li></ul></li></ul><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 2  0      0 115444   6688 1897744    0    0   261    30    3    4  2  3 94  1  0</span><br><span class="line"> 0  0      0 114500   6688 1897792    0    0     0    32 1949 3657  3  3 94  0  0</span><br><span class="line"> 0  0      0 114648   6688 1897792    0    0     0     0 1642 2953  1  2 97  0  0</span><br><span class="line"> 0  0      0 114512   6688 1897792    0    0     0     0 2037 3806  3  3 94  0  0</span><br><span class="line"> 0  0      0 114512   6700 1897796    0    0    16    84 2148 3758  3  4 93  0  0</span><br><span class="line"> 0  0      0 114512   6700 1897808    0    0     0     0 2152 4052  3  4 94  0  0</span><br><span class="line"> 0  0      0 114512   6700 1897808    0    0     0     0 1784 3357  1  2 98  0  0</span><br><span class="line"> 0  0      0 115272   6724 1897812    0    0     0   160 2202 4116  3  4 93  0  0</span><br><span class="line"> 0  0      0 116028   6756 1897812    0    0     0   324 1835 3365  2  2 95  1  0</span><br><span class="line"> 0  0      0 116916   6756 1897812    0    0     0     0 2011 3854  2  4 95  0  0</span><br></pre></td></tr></table></figure><hr><p>性能视图备份</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">-- 考虑备份数据库性能视图（最好是在新建的非生产使用的单独用户下操作，比如 TEST_USER 用户）</span><br><span class="line">-- 此外在数据库需要重启时，更应考虑备份这些视图</span><br><span class="line">create table diag_session_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$session;</span><br><span class="line">create table diag_session_wait_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$session_wait;</span><br><span class="line">create table diag_process_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$process;</span><br><span class="line">create table diag_sql_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$sql;</span><br><span class="line">create table diag_sqlarea_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$sqlarea;</span><br><span class="line">create table diag_sql_plan_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$sql_plan; --耗性能</span><br><span class="line">create table diag_lock_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$lock;</span><br><span class="line">create table diag_locked_object_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$locked_object;</span><br><span class="line">create table diag_access_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$access;</span><br><span class="line">create table diag_latch_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$latch;</span><br><span class="line">create table diag_latch_children_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$latch_children;</span><br><span class="line">create table diag_Librarycache_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv_$Librarycache;</span><br><span class="line">create table diag_rowcache_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv_$rowcache;</span><br><span class="line">create table diag_sort_segment_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$sort_segment;</span><br><span class="line">create table diag_sort_usage_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$sort_usage;</span><br><span class="line">create table diag_log_history_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$log_history;</span><br><span class="line">create table diag_log_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$log;</span><br><span class="line">create table diag_logfile_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$logfile;</span><br><span class="line">create table diag_transaction_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$transaction;</span><br><span class="line">create table diag_parameter_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$parameter;</span><br><span class="line">create table diag_session_longops_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$session_longops;</span><br><span class="line">create table diag_bh_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$bh;</span><br><span class="line">create table diag_filestat_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$filestat;</span><br><span class="line">create table diag_segstat_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$segstat;</span><br><span class="line">create table diag_tempstat_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$tempstat;</span><br><span class="line">create table diag_datafile_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$datafile;</span><br><span class="line">create table diag_tempfile_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$tempfile;</span><br><span class="line">create table diag_open_cursors_&amp;yyyymmdd_seq_area nologging as</span><br><span class="line">select *</span><br><span class="line">from gv$open_cursors;</span><br></pre></td></tr></table></figure><hr><p>获取基线<br>当系统觉得有问题时，可以考虑立即取一个断点基线，作为AWR报表的一个断点。<br><code>exec dbms_workload_repository.create_snapshot();</code></p><hr><p>观察临时表空间和回滚段表空间情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">-- 查谁占用了undo表空间</span><br><span class="line">select r.name                      回滚段名</span><br><span class="line">     , rssize / 1024 / 1024 / 1024 &quot;rssize(g)&quot;</span><br><span class="line">     , s.sid</span><br><span class="line">     , s.serial#</span><br><span class="line">     , s.username                  用户名</span><br><span class="line">     , s.status</span><br><span class="line">     , s.sql_hash_value</span><br><span class="line">     , s.sql_address</span><br><span class="line">     , s.machine</span><br><span class="line">     , s.module</span><br><span class="line">     , substr(s.program, 1, 78)    操作程序</span><br><span class="line">     , r.usn</span><br><span class="line">     , hwmsize / 1024 / 1024 / 1024</span><br><span class="line">     , shrinks</span><br><span class="line">     , xacts</span><br><span class="line">from sys.v_$session S</span><br><span class="line">   , sys.v_$transaction t</span><br><span class="line">   , sys.v_$rollname r</span><br><span class="line">   , v$rollstat rs</span><br><span class="line">where t.addr = s.taddr</span><br><span class="line">  and t.xidusn = r.usn</span><br><span class="line">  and r.usn = rs.usn</span><br><span class="line">order by rssize desc;</span><br><span class="line"></span><br><span class="line">-- 查谁占用了temp表空间</span><br><span class="line">select t.blocks * 16 / 1024 / 1024</span><br><span class="line">     , s.username</span><br><span class="line">     , s.schemaname</span><br><span class="line">     , t.tablespace</span><br><span class="line">     , t.segtype</span><br><span class="line">     , t.extents</span><br><span class="line">     , s.program</span><br><span class="line">     , s.osuser</span><br><span class="line">     , s.terminal</span><br><span class="line">     , s.sid</span><br><span class="line">     , s.serial#</span><br><span class="line">from v$sort_usage t</span><br><span class="line">   , v$session s</span><br><span class="line">where t.session_addr = s.saddr;</span><br><span class="line"></span><br><span class="line">-- 还可查到具体SQL</span><br><span class="line">select sql.sql_id</span><br><span class="line">     , t.blocks * 16 / 1024 / 1024</span><br><span class="line">     , s.username</span><br><span class="line">     , s.schemaname</span><br><span class="line">     , t.tablespace</span><br><span class="line">     , t.segtype</span><br><span class="line">     , t.extents</span><br><span class="line">     , s.program</span><br><span class="line">     , s.osuser</span><br><span class="line">     , s.terminal</span><br><span class="line">     , s.sid</span><br><span class="line">     , s.serial#</span><br><span class="line">     , sql.sql_text</span><br><span class="line">from v$sort_usage t</span><br><span class="line">   , v$session s</span><br><span class="line">   , v$sql sql</span><br><span class="line">where t.session_addr = s.saddr</span><br><span class="line">  and t.sqladdr = sql.address</span><br><span class="line">  and t.sqlhash = sql.hash_value;</span><br></pre></td></tr></table></figure><h4 id="动态局部"><a href="#动态局部" class="headerlink" title="动态局部"></a>动态局部</h4><p>通过主机进程PID查SQL<br>通过主机进程PID查SQL(这个步骤和之前的top命令紧密相连，就是为了直接分析这些耗CPU的进程和哪些SQL有关系)<br>本来可以用如下方法来查，但是系统出现问题时，一般不容易查出来，太慢（有时用 ordered 或者 no_merge 的 HINT 有效，有时无效)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select /*+ ordered */</span><br><span class="line">    sql_text</span><br><span class="line">from v$sqltext a</span><br><span class="line">where (a.hash_value, a.address) in</span><br><span class="line">      (select decode(sql_hash_value, 0, prev_hash_value, sql_hash_value)</span><br><span class="line">            , decode(sql_hash_value, 0, prev_sql_addr, sql_address)</span><br><span class="line">       from v$session b</span><br><span class="line">       where b.paddr =</span><br><span class="line">             (select addr from v$process c where c.spid = &#x27;&amp;pid&#x27;))</span><br><span class="line">order by piece asc;</span><br></pre></td></tr></table></figure><p>一般采用下面三步（可避免性能问题，返回结果会快）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">-- 1. 获取 addr</span><br><span class="line">select spid</span><br><span class="line">     , addr</span><br><span class="line">     , t.pga_used_mem</span><br><span class="line">     , t.pga_alloc_mem</span><br><span class="line">     , t.pga_freeable_mem</span><br><span class="line">     , t.pga_max_mem</span><br><span class="line">from v$process t</span><br><span class="line">where spid = &#x27;$pid&#x27;;</span><br><span class="line"></span><br><span class="line">-- 2. 根据 addr 获取 sql_id</span><br><span class="line">select t.sid</span><br><span class="line">     , t.program</span><br><span class="line">     , t.machine</span><br><span class="line">     , t.logon_time</span><br><span class="line">     , t.wait_class</span><br><span class="line">     , t.wait_time</span><br><span class="line">     , t.seconds_in_wait</span><br><span class="line">     , t.event</span><br><span class="line">     , t.sql_id</span><br><span class="line">     , t.prev_sql_id</span><br><span class="line">from v$session t</span><br><span class="line">where paddr = &#x27;$addr&#x27;;</span><br><span class="line"></span><br><span class="line">-- 3. 根据 sql_id 查询具体 SQL</span><br><span class="line">select t.sql_id</span><br><span class="line">     , t.sql_text</span><br><span class="line">     , t.executions</span><br><span class="line">     , t.first_load_time</span><br><span class="line">     , t.last_load_time</span><br><span class="line">     , t.buffer_gets</span><br><span class="line">     , t.rows_processed</span><br><span class="line">from v$sql t</span><br><span class="line">where sql_id in (&#x27;$sql_id&#x27;);</span><br></pre></td></tr></table></figure><hr><p>观察当前数据库的版本及等待情况，SQL基本情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">-- 等待事件（当前)</span><br><span class="line">select t.event, count(*)</span><br><span class="line">from v$session t</span><br><span class="line">group by event</span><br><span class="line">order by count(*) desc;</span><br><span class="line"></span><br><span class="line">-- 等待事件（历史汇集）</span><br><span class="line">select t.event, t.total_waits</span><br><span class="line">from v$system_event t</span><br><span class="line">order by total_waits desc;</span><br><span class="line"></span><br><span class="line">-- 游标使用情况</span><br><span class="line">select inst_id, sid, count(*)</span><br><span class="line">from gv$open_cursor</span><br><span class="line">group by inst_id, sid</span><br><span class="line">having count(*) &gt;= 1000</span><br><span class="line">order by count(*) desc;</span><br><span class="line"></span><br><span class="line">-- PGA占用最多的进程</span><br><span class="line">select p.spid</span><br><span class="line">     , p.pid</span><br><span class="line">     , s.sid</span><br><span class="line">     , s.serial#</span><br><span class="line">     , s.status</span><br><span class="line">     , p.pga_alloc_mem</span><br><span class="line">     , s.username</span><br><span class="line">     , s.osuser</span><br><span class="line">     , s.program</span><br><span class="line">from v$process p</span><br><span class="line">   , v$session s</span><br><span class="line">where s.paddr(+) = p.addr</span><br><span class="line">order by p.pga_alloc_mem desc;</span><br><span class="line"></span><br><span class="line">-- 登录时间最长的SESSION(同时获取到 spid ,方便在主机层面 ps-ef|grep spid 来查看)</span><br><span class="line">select *</span><br><span class="line">from (select t.sid</span><br><span class="line">           , t2.spid</span><br><span class="line">           , t.PROGRAM</span><br><span class="line">           , t.status</span><br><span class="line">           , t.sql_id</span><br><span class="line">           , t.PREV_SQL_ID</span><br><span class="line">           , t.event</span><br><span class="line">           , t.LOGON_TIME</span><br><span class="line">           , trunc(sysdate - logon_time)</span><br><span class="line">      from v$session t</span><br><span class="line">         , v$process t2</span><br><span class="line">      where t.paddr = t2.ADDR</span><br><span class="line">        and t.type &lt;&gt; &#x27;BACKGROUND&#x27;</span><br><span class="line">      order by logon_time)</span><br><span class="line">where rownum &lt; 20;</span><br><span class="line"></span><br><span class="line">-- 物理读和逻辑较多的5QL</span><br><span class="line">-- 逻辑读最多</span><br><span class="line">select *</span><br><span class="line">from (select sql_id</span><br><span class="line">           , sql_text</span><br><span class="line">           , s.executions</span><br><span class="line">           , s.last_load_time</span><br><span class="line">           , s.first_load_time</span><br><span class="line">           , s.disk_reads</span><br><span class="line">           , s.buffer_gets</span><br><span class="line">      from v$sql s</span><br><span class="line">      where s.buffer_gets &gt; 300</span><br><span class="line">      order by buffer_gets desc)</span><br><span class="line">where rownum &lt;= 20;</span><br><span class="line"></span><br><span class="line">-- 物理读最多</span><br><span class="line">select *</span><br><span class="line">from (select sql_id</span><br><span class="line">           , sql_text</span><br><span class="line">           , s.executions</span><br><span class="line">           , s.last_load_time</span><br><span class="line">           , s.first_load_time</span><br><span class="line">           , s.disk_reads</span><br><span class="line">           , s.buffer_gets</span><br><span class="line">           , s.parse_calls</span><br><span class="line">      from v$sql s</span><br><span class="line">      where s.disk_reads &gt; 300</span><br><span class="line">      order by disk_reads desc)</span><br><span class="line">where rownum &lt;= 20;</span><br><span class="line"></span><br><span class="line">-- 执行次数最多</span><br><span class="line">select *</span><br><span class="line">from (select sql_id</span><br><span class="line">           , sql_text</span><br><span class="line">           , s.executions</span><br><span class="line">           , s.last_load_time</span><br><span class="line">           , s.first_load_time</span><br><span class="line">           , s.disk_reads</span><br><span class="line">           , s.buffer_gets</span><br><span class="line">           , s.parse_calls</span><br><span class="line">      from v$sql s</span><br><span class="line">      order by s.executions desc)</span><br><span class="line">where rownum &lt;= 20;</span><br><span class="line"></span><br><span class="line">-- 解析次数最多</span><br><span class="line">select *</span><br><span class="line">from (select sql_id</span><br><span class="line">           , sql_text</span><br><span class="line">           , s.executions</span><br><span class="line">           , s.last_load_time</span><br><span class="line">           , s.first_load_time</span><br><span class="line">           , s.disk_reads</span><br><span class="line">           , s.buffer_gets</span><br><span class="line">           , s.parse_calls</span><br><span class="line">      from v$sql s</span><br><span class="line">      order by s.parse_calls desc)</span><br><span class="line">where rownum &lt; 20;</span><br><span class="line"></span><br><span class="line">-- 求 DISK SORT 严重的 SQL</span><br><span class="line">select sess.username, sql.sql_text, sql.address, sort1.blocks</span><br><span class="line">from v$session sess</span><br><span class="line">   , v$sqlarea sql</span><br><span class="line">   , v$sort_usage sort1</span><br><span class="line">where sess.serial# = sort1.session_num</span><br><span class="line">  and sort1.sqladdr = sql.address</span><br><span class="line">  and sort1.sqlhash = sql.hash_value</span><br><span class="line">  and sort1.blocks &gt; 200</span><br><span class="line">order by sort1.blocks desc;</span><br></pre></td></tr></table></figure><p>补充：<br>在 Oracle SQL 中，<code>(+)</code> 符号用于指示外连接（outer join）。除了 <code>(+)</code> 符号之外，Oracle 还支持使用 <code>LEFT OUTER JOIN</code>,<br><code>RIGHT OUTER JOIN</code>, 和 <code>FULL OUTER JOIN</code> 语法来表达外连接。</p><p>JOIN 的写法这里就省略了。下面说 <code>(+)</code> 的写法：</p><ul><li><code>(+)</code> 符号用于指示外连接，它可以出现在等式的一边或两边。</li><li>如果 <code>(+)</code> 出现在等式的左边，则表示 LEFT OUTER JOIN。</li><li>如果 <code>(+)</code> 出现在等式的右边，则表示 RIGHT OUTER JOIN。</li><li>如果 <code>(+)</code> 出现在等式的两边，则表示 FULL OUTER JOIN。</li></ul><p>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> left_table, right_table</span><br><span class="line"><span class="keyword">WHERE</span> left_table.column (<span class="operator">+</span>) <span class="operator">=</span> right_table.column</span><br></pre></td></tr></table></figure><ul><li><p><strong>语法差异</strong>:</p><ul><li>使用 <code>LEFT OUTER JOIN</code>, <code>RIGHT OUTER JOIN</code>, 和 <code>FULL OUTER JOIN</code> 语法时，可以使用现代的 ANSI SQL 标准语法。</li><li>使用 <code>(+)</code> 符号时，需要使用旧式的逗号连接语法，并在 <code>WHERE</code> 子句中指定外连接条件。</li></ul></li><li><p><strong>性能</strong>:</p><ul><li>在大多数情况下，使用现代的外连接语法 (<code>LEFT OUTER JOIN</code>, <code>RIGHT OUTER JOIN</code>, 和 <code>FULL OUTER JOIN</code>) 可能会产生更好的执行计划和性能。</li><li><code>(+)</code> 符号虽然仍然支持，但在新版本的 Oracle 数据库中可能不再推荐使用。</li></ul></li><li><p><strong>版本兼容性</strong>:</p><ul><li>确保使用的外连接语法在当前 Oracle 数据库版本中可用。</li></ul></li></ul><hr><p>检查是否有过分提交的语句<br>检查是否有过分提交的语句，关键是得到 sid,代入 V$SESSION 就可知道是什么进程，接下来还可以知道 V$SQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-- 提交次数最多的SESSION</span><br><span class="line">select t1.sid, t1.value, t2.name</span><br><span class="line">from v$sesstat t1</span><br><span class="line">   , v$statname t2</span><br><span class="line">--where t2.name like &#x27;%commit%&#x27;</span><br><span class="line">where t2.name like &#x27;%user commits?%&#x27; -- 可以只选user commits,其他系统级的先不关心</span><br><span class="line">  and t1.STATISTIC# = t2.STATISTIC#</span><br><span class="line">  and value &gt;= 10000</span><br><span class="line">order by value desc;</span><br><span class="line">-- 取得SID既可以代入到v$SESSION和v$SQL中去分析</span><br><span class="line">-- 得出SQL_ID</span><br><span class="line">select t.sid</span><br><span class="line">     , t.program</span><br><span class="line">     , t.machine</span><br><span class="line">     , t.logon_time</span><br><span class="line">     , t.wait_class</span><br><span class="line">     , t.wait_time</span><br><span class="line">     , t.seconds_in_wait</span><br><span class="line">     , t.event</span><br><span class="line">     , t.sql_id</span><br><span class="line">     , t.prev_sql_id</span><br><span class="line">from v$session t</span><br><span class="line">where sid in (&#x27;$sid&#x27;);</span><br><span class="line">-- 根据sql id或prev_sql_id代入得到SQL</span><br><span class="line">select t.sql_id</span><br><span class="line">     , t.sql_text</span><br><span class="line">     , t.executions</span><br><span class="line">     , t.first_load_time</span><br><span class="line">     , t.last_load_time</span><br><span class="line">     , t.buffer_gets</span><br><span class="line">     , t.rows_processed</span><br><span class="line">from v$sql t</span><br><span class="line">where sql_id in (&#x27;$sql_id&#x27;)</span><br></pre></td></tr></table></figure><hr><p>检查系统使用绑定变量的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">-- 查询共享内存占有率</span><br><span class="line">select count(*), round(sum(sharable_mem) / 1024 / 1024, 2)</span><br><span class="line">from v$db_object_cache a;</span><br><span class="line"></span><br><span class="line">-- 捕获出需要使用绑定变量的SQL(这里只能适配大多数语句)</span><br><span class="line">Drop table t1 purge;</span><br><span class="line">create table t1 as</span><br><span class="line">select sql_text, module</span><br><span class="line">from v$sqlarea;</span><br><span class="line">alter table t1</span><br><span class="line">    add sql_text_wo_constants varchar2(1000);</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE FUNCTION remove_constants(p_query IN VARCHAR2) RETURN VARCHAR2</span><br><span class="line">AS</span><br><span class="line">    l_query     LONG;</span><br><span class="line">    l_char      VARCHAR2(10);</span><br><span class="line">    l_in_quotes BOOLEAN DEFAULT FALSE;</span><br><span class="line">BEGIN</span><br><span class="line">    FOR i IN 1..LENGTH(p_query)</span><br><span class="line">        LOOP</span><br><span class="line">            l_char := SUBSTR(p_query, i, 1);</span><br><span class="line">            IF (l_char = &#x27;&#x27;&#x27;&#x27;) THEN</span><br><span class="line">                IF l_in_quotes THEN</span><br><span class="line">                    l_in_quotes := FALSE;</span><br><span class="line">                ELSE</span><br><span class="line">                    l_in_quotes := TRUE;</span><br><span class="line">                    l_query := l_query || &#x27;&#x27;&#x27;#&#x27;;</span><br><span class="line">                END IF;</span><br><span class="line">            ELSIF NOT l_in_quotes THEN</span><br><span class="line">                l_query := l_query || l_char;</span><br><span class="line">            END IF;</span><br><span class="line">        END LOOP;</span><br><span class="line"></span><br><span class="line">    -- 替换数字</span><br><span class="line">    l_query := TRANSLATE(l_query, &#x27;0123456789&#x27;, &#x27;@@@@@@@@@@&#x27;);</span><br><span class="line"></span><br><span class="line">    -- 移除多余的 @ 符号</span><br><span class="line">    FOR i IN 0..8</span><br><span class="line">        LOOP</span><br><span class="line">            l_query := REPLACE(l_query, LPAD(&#x27;@&#x27;, 10 - i, &#x27;@&#x27;), &#x27;@&#x27;);</span><br><span class="line">            l_query := REPLACE(l_query, LPAD(&#x27;&#x27;, 10 - i, &#x27;&#x27;), &#x27;&#x27;);</span><br><span class="line">        END LOOP;</span><br><span class="line"></span><br><span class="line">    RETURN UPPER(l_query);</span><br><span class="line">END;</span><br><span class="line">-- 编译函数</span><br><span class="line">    ALTER FUNCTION TEST_USER.remove_constants COMPILE;</span><br><span class="line">update TEST_USER.t1</span><br><span class="line">set sql_text_wo_constants = remove_constants(sql_text);</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">-- 执行完上述动作后，以下SQL语句可以完成未绑定变量语句的统计</span><br><span class="line">select sql_text_wo_constants, module, count(*)</span><br><span class="line">from t1</span><br><span class="line">group by sql_text_wo_constants, module</span><br><span class="line">having count(*) &gt; 100</span><br><span class="line">order by 3 desc;</span><br></pre></td></tr></table></figure><h4 id="静态整体"><a href="#静态整体" class="headerlink" title="静态整体"></a>静态整体</h4><p>主机静态情况检查</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看磁盘空间使用情况</span></span><br><span class="line">df -h</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主机内存情况</span></span><br><span class="line">cat /proc/meminfo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主机CPU情况</span></span><br><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure><hr><p>记录下Oracle数据库的所有参数设置情况，并检查是否归档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 版本及所有参数情况</span><br><span class="line">-- 开启CRT的日志跟踪</span><br><span class="line">-- 版本</span><br><span class="line">select *</span><br><span class="line">from v$version;</span><br><span class="line">-- 所有参数</span><br><span class="line">show parameter</span><br><span class="line">-- 关闭CRT的日志跟踪，将文件取回</span><br><span class="line">-- 其中重点关注的是</span><br><span class="line">-- sga pga log_buffer processes open_cursors session_cached_cursors db_recovery_file_dest cluster_database</span><br><span class="line">-- SGA, PGA, 日志缓冲区, 进程数, 打开的游标数, 会话缓存的游标数, 数据库恢复文件目的地, 集群数据库设置相关的参数。</span><br><span class="line">-- 是否归档</span><br><span class="line">archive log list</span><br></pre></td></tr></table></figure><hr><p>检查数据库表和索引是否存在并行度设在其中的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 检查数据库表和索引是否存在并行度设在其中的情况（很多时候有人用parallel建了表或索引，忘记alter table xxx noparallel关闭了)。</span><br><span class="line">select t.owner, t.table_name, degree</span><br><span class="line">from dba_tables t</span><br><span class="line">where t.degree &gt; &#x27;1&#x27;;</span><br><span class="line">select t.owner, t.table_name, index_name, degree, status</span><br><span class="line">from dba_indexes t</span><br><span class="line">where owner in (&#x27;TEST_USER&#x27;)</span><br><span class="line">  and t.degree &gt; &#x27;1&#x27;;</span><br><span class="line">-- 有问题就要处理，比如索引有并行，就处理如下：</span><br><span class="line">select &#x27;alter index &#x27; || t.owner || &#x27;.&#x27; || index_name || &#x27;noparallel;&#x27;</span><br><span class="line">from dba_indexes t</span><br><span class="line">where owner in (&#x27;TEST_USER&#x27;)</span><br><span class="line">  and t.degree &gt; &#x27;1&#x27;;</span><br></pre></td></tr></table></figure><hr><p>检查是否有失效的索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">-- 普通索引</span><br><span class="line">select t.index_name</span><br><span class="line">     , t.table_name</span><br><span class="line">     , blevel</span><br><span class="line">     , t.num_rows</span><br><span class="line">     , t.leaf_blocks</span><br><span class="line">     , t.distinct_keys</span><br><span class="line">from dba_indexes t</span><br><span class="line">where status = &#x27;INVALID&#x27;;</span><br><span class="line">-- 分区索引</span><br><span class="line">select t2.owner</span><br><span class="line">     , t1.blevel</span><br><span class="line">     , t1.leaf_blocks</span><br><span class="line">     , t1.index_name</span><br><span class="line">     , t2.table_name</span><br><span class="line">     , t1.partition_name</span><br><span class="line">     , t1.status</span><br><span class="line">from dba_ind_partitions t1</span><br><span class="line">   , dba_indexes t2</span><br><span class="line">where t1.index_name = t2.index_name</span><br><span class="line">  and t1.status = &#x27;UNUSABLE&#x27;</span><br><span class="line">  and t2.owner in (&#x27;TEST_USER&#x27;);</span><br><span class="line">-- 以下是所有失效对象的检查</span><br><span class="line">select &#x27;alter&#x27; ||</span><br><span class="line">       decode(object_type, &#x27;PACKAGE BODY&#x27;, &#x27;PACKAGE&#x27;, &#x27;TYPE BODY&#x27;, &#x27;TYPE&#x27;, object_type) || &#x27;&#x27; ||</span><br><span class="line">       owner || &#x27;.&#x27; || object_name || &#x27;&#x27; ||</span><br><span class="line">       decode(object_type, &#x27;PACKAGE BODY&#x27;, &#x27;compile body&#x27;, &#x27;compile&#x27;) || &#x27;;&#x27;</span><br><span class="line">     , t.*</span><br><span class="line">from dba_objects t</span><br><span class="line">where status = &#x27;INVALID&#x27;</span><br><span class="line">--owner not in (&#x27;PUBLIC&#x27;,&#x27;SYSTEM&#x27;,&#x27;SYS&#x27;)</span><br><span class="line">  and owner in (&#x27;TEST_USER&#x27;);</span><br></pre></td></tr></table></figure><hr><p>检查是否有显著未释放高水平位的表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">select table_name, blocks, num_rows</span><br><span class="line">from user_tables</span><br><span class="line">where blocks / num_rows &gt;= 0.2</span><br><span class="line">  and num_rows is not null</span><br><span class="line">  and num_rows &lt;&gt; 0</span><br><span class="line">  and blocks &gt;= 10000;</span><br><span class="line">-- 这个就可以预测到哪些是高水平位没释放的表。</span><br><span class="line">-- 其中blocks&gt;:=10000是因为低于10000的块说明表的体积太小了，释放或不释放无所谓。</span><br><span class="line"></span><br><span class="line">-- 而 blocks / num_rows &gt;= 1 表示是严重有问题的。</span><br><span class="line">-- 而这个 blocks / num_rows &gt;= 0.2 表示至少一个块要装5行数据，如果装不了，那就很奇怪了，值得怀疑了，除非有LONG和CLOB字段或者一堆的VARCHAR2(4OOO)字段。</span><br><span class="line"></span><br><span class="line">-- 附（可以释放高水平位的脚本，在 Oracle 的 shrink 方法无效时可采纳）：</span><br><span class="line">create or replace package pkg_shrink</span><br><span class="line">    Authid Current_User</span><br><span class="line">as</span><br><span class="line">    /*</span><br><span class="line">    功能：将delete后的表降低高水平</span><br><span class="line">    */</span><br><span class="line">    procedure p_move_tab(p_tab varchar2);</span><br><span class="line">    procedure p_cal_bytes(p_status varchar2, p_tab varchar2);</span><br><span class="line">    procedure p_rebuid_idx(p_tab varchar2);</span><br><span class="line">    procedure p_main(p_table_name varchar2);</span><br><span class="line">end pkg_shrink;</span><br><span class="line">create or replace package body pkg_shrink</span><br><span class="line">as</span><br><span class="line">    v_sql varchar2(4000);</span><br><span class="line">    procedure p_cal_bytes(p_status varchar2, p_tab varchar2)</span><br><span class="line">    as</span><br><span class="line">        v_tab_bytes number;</span><br><span class="line">        v_idx_bytes number;</span><br><span class="line">        v_str_tab   varchar2(4000);</span><br><span class="line">        v_str_idx   varchar2(4000);</span><br><span class="line">    begin</span><br><span class="line">        select sum(bytes) / 1024 / 1024 into v_tab_bytes from user_segments where segment_name = upper(p_tab);</span><br><span class="line">        select sum(bytes) / 1024 / 1024</span><br><span class="line">        into v_idx_bytes</span><br><span class="line">        from user_segments</span><br><span class="line">        where segment_name IN (SELECT INDEX_NAME</span><br><span class="line">                               FROM USER_INDEXES</span><br><span class="line">                               WHERE TABLE_NAME = upper(p_tab));</span><br><span class="line">        v_str_tab := p_status || &#x27;表&#x27; || p_tab || &#x27;的大小为&#x27; || v_tab_bytes || &#x27;M&#x27;;</span><br><span class="line">        if v_idx_bytes is null then</span><br><span class="line">            v_str_idx := p_status || &#x27;无索引&#x27;;</span><br><span class="line">        else</span><br><span class="line">            v_str_idx := p_status || &#x27;索引的大小为&#x27; || v_idx_bytes || &#x27;M&#x27;;</span><br><span class="line">        end if;</span><br><span class="line">        dbms_output.put_line(v_str_tab || &#x27;;&#x27; || v_str_idx);</span><br><span class="line">    end p_cal_bytes;</span><br><span class="line"></span><br><span class="line">    procedure p_move_tab(p_tab varchar2)</span><br><span class="line">    as</span><br><span class="line">        V_IF_PART_TAB NUMBER;</span><br><span class="line">    begin</span><br><span class="line">        SELECT COUNT(*) INTO V_IF_PART_TAB FROM user_part_tables WHERE TABLE_NAME = upper(P_TAB);</span><br><span class="line">        IF V_IF_PART_TAB = 0 THEN --非分区表</span><br><span class="line">            v_sql := &#x27;alter table &#x27; || p_tab || &#x27; move&#x27;; -- 完成表的MOVE动作，从而做到降低高水平位，不过也带来了索引的失效！</span><br><span class="line">            DBMS_OUTPUT.put_line(v_sql);</span><br><span class="line">            execute immediate v_sql;</span><br><span class="line">        ELSE -- 分区表</span><br><span class="line">            for i in (SELECT * from USER_TAB_PARTITIONS WHERE TABLE_NAME = upper(p_tab))</span><br><span class="line">                loop</span><br><span class="line">                    v_sql := &#x27;alter table &#x27; || p_tab || &#x27; move partition &#x27; || i.partition_name; -- 完成分区表的MOVE动作，同样带来了索引失效！</span><br><span class="line">                    DBMS_OUTPUT.put_line(v_sql);</span><br><span class="line">                    execute immediate v_Sql;</span><br><span class="line">                end loop;</span><br><span class="line">        END IF;</span><br><span class="line">    end p_move_tab;</span><br><span class="line"></span><br><span class="line">    procedure p_rebuid_idx(p_tab varchar2)</span><br><span class="line">    as</span><br><span class="line">        V_NORMAL_IDX NUMBER;</span><br><span class="line">        V_PART_IDX   NUMBER;</span><br><span class="line">    begin</span><br><span class="line">        SELECT COUNT(*)</span><br><span class="line">        INTO V_NORMAL_IDX</span><br><span class="line">        FROM user_indexes</span><br><span class="line">        where table_name = &#x27;PART_TAB&#x27;</span><br><span class="line">          AND INDEX_NAME</span><br><span class="line">            NOT IN (SELECT INDEX_NAME FROM user_part_indexes);</span><br><span class="line">        IF V_NORMAL_IDX &gt;= 1 THEN -- 普通索引</span><br><span class="line">            for i in (select *</span><br><span class="line">                      from user_indexes</span><br><span class="line">                      where table_name = upper(p_tab)</span><br><span class="line">                        AND INDEX_NAME</span><br><span class="line">                          NOT IN (SELECT INDEX_NAME FROM user_part_indexes))</span><br><span class="line">                loop</span><br><span class="line">                    v_sql := &#x27;alter index &#x27; || i.index_name || &#x27; rebuild&#x27;; -- 将失效的普通索引重建</span><br><span class="line">                    DBMS_OUTPUT.put_line(v_sql);</span><br><span class="line">                    execute immediate v_sql;</span><br><span class="line">                end loop;</span><br><span class="line">        END IF;</span><br><span class="line">        SELECT COUNT(*) INTO V_PART_IDX FROM user_part_indexes WHERE TABLE_NAME = &#x27;PART_TAB&#x27;;</span><br><span class="line">        IF V_PART_IDX &gt;= 1 THEN -- 分区索引</span><br><span class="line">            for i in (SELECT *</span><br><span class="line">                      from User_Ind_Partitions</span><br><span class="line">                      WHERE index_name in (select index_name</span><br><span class="line">                                           from user_part_indexes</span><br><span class="line">                                           where table_name = upper(p_tab)))</span><br><span class="line">                loop</span><br><span class="line">                    v_sql := &#x27;alter index &#x27; || i.index_name || &#x27; rebuild partition &#x27; || i.partition_name; -- 将失效分区索引重建</span><br><span class="line">                    DBMS_OUTPUT.put_line(v_sql);</span><br><span class="line">                    execute immediate v_Sql;</span><br><span class="line">                end loop;</span><br><span class="line">        END IF;</span><br><span class="line">    end p_rebuid_idx;</span><br><span class="line"></span><br><span class="line">    procedure p_main(p_table_name varchar2)</span><br><span class="line">    as</span><br><span class="line">    begin</span><br><span class="line">        for i in (select *</span><br><span class="line">                  from (SELECT SUBSTR(s, INSTR(s, &#x27;,&#x27;, 1, ROWNUM) + 1,</span><br><span class="line">                                      INSTR(s, &#x27;,&#x27;, 1, ROWNUM + 1) - INSTR(s, &#x27;,&#x27;, 1, ROWNUM) - 1) AS TYPE_ID</span><br><span class="line">                        FROM (SELECT &#x27;,&#x27; || p_table_name || &#x27;,&#x27; AS s FROM DUAL)</span><br><span class="line">                        CONNECT BY ROWNUM &lt;= 100)</span><br><span class="line">                  WHERE type_id IS NOT NULL</span><br><span class="line">            )</span><br><span class="line">            loop</span><br><span class="line">                -- 在外面SELECT再套一层是必须的，否则只会循环一次。另外type_id IS NOT NULL是必须的，否则会多循环</span><br><span class="line">                DBMS_OUTPUT.put_line(&#x27;当前处理的表为&#x27; || i.TYPE_ID);</span><br><span class="line">                p_cal_bytes(&#x27;未降低高水平位前&#x27;, i.type_id);</span><br><span class="line">                p_move_tab(i.type_id);</span><br><span class="line">                p_rebuid_idx(I.TYPE_ID);</span><br><span class="line">                p_cal_bytes(&#x27;降低高水平位后&#x27;, i.type_id);</span><br><span class="line">            end loop;</span><br><span class="line">    end p_main;</span><br><span class="line">end pkg_shrink;</span><br><span class="line"></span><br><span class="line">-- 编译</span><br><span class="line">    alter package PKG_SHRINK compile reuse settings</span><br><span class="line"></span><br><span class="line">-- 执行</span><br><span class="line">BEGIN</span><br><span class="line">    pkg_shrink.p_main(&#x27;TABLE_NAME&#x27;);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><hr><p>检查统计信息</p><p>自动统计信息收集情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-- 检查哪些对象的统计信息不够新，或者从未统计过（注意，让未统计过的在前面，即nulls first)。</span><br><span class="line">-- 检查统计信息是否被收集</span><br><span class="line">select t.JOB_NAME, t.PROGRAM_NAME, t.state, t.enabled</span><br><span class="line">from dba_scheduler_jobs t</span><br><span class="line">where job_name = &#x27;GATHER_STATS_JOB&#x27;;</span><br><span class="line"></span><br><span class="line">-- 检查哪些未被收集或者很久没收集</span><br><span class="line">select owner</span><br><span class="line">     , table_name</span><br><span class="line">     , t.last_analyzed</span><br><span class="line">     , t.num_rows</span><br><span class="line">     , t.blocks</span><br><span class="line">     , t.object_type</span><br><span class="line">from dba_tab_statistics t</span><br><span class="line">where owner in (&#x27;TEST_USER&#x27;)</span><br><span class="line">  and (t.last_analyzed is null or t.last_analyzed &lt; sysdate - 14)</span><br><span class="line">order by t.last_analyzed nulls first;</span><br><span class="line"></span><br><span class="line">-- 查看数量</span><br><span class="line">select count(*)</span><br><span class="line">from dba_tab_statistics t</span><br><span class="line">where owner in (&#x27;TEST_USER&#x27;)</span><br><span class="line">  and (t.last_analyzed is null or t.last_analyzed &lt; sysdate - 14);</span><br></pre></td></tr></table></figure><p>全局临时表情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 检查全局临时表有没有被收集统计信息</span><br><span class="line">select owner</span><br><span class="line">     , table_name</span><br><span class="line">     , t.last_analyzed</span><br><span class="line">     , t.num_rows</span><br><span class="line">     , t.blocks</span><br><span class="line">from dba_tables t</span><br><span class="line">where t.temporary = &#x27;Y&#x27;</span><br><span class="line">  and owner in (&#x27;TEST_USER&#x27;);</span><br><span class="line"></span><br><span class="line">-- 相应的处理措施</span><br><span class="line">BEGIN</span><br><span class="line">    DBMS_STATS.DELETE_TABLE_STATS(&#x27;TEST_USER&#x27;, &#x27;RN_IDENTIFICATION_BATCH&#x27;); -- 删除统计信息</span><br><span class="line">    DBMS_STATS.LOCK_TABLE_STATS(&#x27;TEST_USER&#x27;, &#x27;RN_IDENTIFICATION_BATCH&#x27;); -- 不收集统计信息</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><hr><p>awr addm ash awrddrpt awrsqrpt等方式观察数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exec dbms_workload_repository.create_snapshot();</span><br><span class="line">@?/rdbms/admin/awrrpt.sql</span><br><span class="line">@?/rdbms/admin/addmrpt.sql</span><br><span class="line">@7/rdbms/admin/ashrpt.sql</span><br><span class="line">@?/rdbms/admin/awrddrpt.sql</span><br><span class="line">@?/rdbms/admin/awrsqrpt.sql</span><br><span class="line">-- 注意：一般要考虑统计出问题的时间段的报表，顺序一般是 awr -&gt; addm -&gt; ash -&gt; awrdd -&gt; awrsq</span><br></pre></td></tr></table></figure><p>这些命令和脚本用于生成和分析 Oracle 自动工作负载仓库 (AWR) 的报告。</p><ol><li><code>exec dbms_workload_repository.create_snapshot();</code>:<ul><li>该命令用于创建一个新的 AWR 快照。AWR 快照包含了数据库在某一时间段内的性能统计数据，这些数据可用于后续的性能分析。</li><li>创建快照有助于记录当前数据库的工作负载状况，并为后续的性能对比提供基准。</li></ul></li><li><code>@?/rdbms/admin/awrrpt.sql</code>:<ul><li>此命令用于执行 AWR 报告生成脚本 <code>awrrpt.sql</code>。该脚本会生成一份详细的 AWR 报告，这份报告包含了数据库在指定时间段内的性能指标和统计数据。</li><li>AWR 报告是性能分析的基础，可以了解数据库的整体性能状况。</li></ul></li><li><code>@?/rdbms/admin/addmrpt.sql</code>:<ul><li>此命令用于执行 ADDM (自动数据库诊断监控器) 报告生成脚本 <code>addmrpt.sql</code>。该脚本会生成一份基于 AWR 数据的 ADDM 报告。</li><li>ADDM 报告提供了更深入的性能分析，包括性能问题的根本原因分析和优化建议。</li></ul></li><li><code>@7/rdbms/admin/ashrpt.sql</code>:<ul><li>此命令用于执行 ASH (自动共享历史) 报告生成脚本 <code>ashrpt.sql</code>。该脚本会生成一份基于 ASH 数据的报告。</li><li>ASH 报告提供了关于会话活动的详细信息，包括等待事件、SQL 执行等，这对于诊断性能瓶颈非常有用。</li></ul></li><li><code>@?/rdbms/admin/awrddrpt.sql</code>:<ul><li>此命令用于执行 AWR 数据字典报告生成脚本 <code>awrddrpt.sql</code>。该脚本会生成一份关于 AWR 数据字典的报告。</li><li>AWR 数据字典报告提供了关于 AWR 表的详细信息，这有助于理解 AWR 数据的结构。</li></ul></li><li><code>@?/rdbms/admin/awrsqrpt.sql</code>:<ul><li>此命令用于执行 AWR SQL 报告生成脚本 <code>awrsqrpt.sql</code>。该脚本会生成一份关于 SQL 语句执行性能的报告。</li><li>AWR SQL 报告提供了 SQL 语句的性能统计数据，包括执行次数、CPU 时间等，这对于优化 SQL 语句的性能非常有用。</li></ul></li></ol><hr><p>获取数据库告警和监听日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsnrctl status # 可获取监听的路径</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show parameter ump -- 可获取告警日志的路径</span><br><span class="line">-- 文件很大的情况下，可以考虑 tail -n 50000 alert* &gt; alert.log 的方式获取最近5万条记录</span><br><span class="line">-- 监听也是类似 tail -n 50000 list* &gt; listener.log</span><br></pre></td></tr></table></figure><hr><p>检查日志大小设置情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 一般情况下，建议单个RED0设置为5GB大，如果发现告警日志切换频繁，则应该立即调整</span><br><span class="line">select inst_id, group#, member</span><br><span class="line">from gv$logfile;</span><br><span class="line"></span><br><span class="line">select group#, bytes, status</span><br><span class="line">from v$log;</span><br></pre></td></tr></table></figure><hr><p>检查最大的对象是哪些、表空间的使用情况及回收站情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">-- 用户的权限情况</span><br><span class="line">select *</span><br><span class="line">from dba_role_privs</span><br><span class="line">where grantee = &#x27;TEST_USER&#x27;;</span><br><span class="line"></span><br><span class="line">-- 最大的前20个对象（然后再进一步COUNT(*)统计其记录数）</span><br><span class="line">select *</span><br><span class="line">from (select owner</span><br><span class="line">           , segment_name</span><br><span class="line">           , segment_type</span><br><span class="line">           , sum(bytes) / 1024 / 1024 / 1024 object_size</span><br><span class="line">      from DBA_segments</span><br><span class="line">      WHERE owner in (&#x27;TEST_USER&#x27;)</span><br><span class="line">      group by owner, segment_name, segment_type</span><br><span class="line">      order by object_size desc)</span><br><span class="line">where rownum &lt; 50;</span><br><span class="line"></span><br><span class="line">-- 表空间使用情况</span><br><span class="line">select a.tablespace_name                                    &quot;表空间名&quot;</span><br><span class="line">     , a.total_space                                        &quot;总空间(g)&quot;</span><br><span class="line">     , nvl(b.free_space, 0)                                 &quot;剩余空间(g)&quot;</span><br><span class="line">     , a.total_space - nvl(b.free_space, 0)                 &quot;使用空间(g)&quot;</span><br><span class="line">     , trunc(nvl(b.free_space, 0) / a.total_space * 100, 2) &quot;剩余百分比%&quot;</span><br><span class="line">from (select tablespace_name</span><br><span class="line">           , trunc(sum(bytes) / 1024 / 1024 / 1024, 2) total_space</span><br><span class="line">      from dba_data_files</span><br><span class="line">      group by tablespace_name) a</span><br><span class="line">   , (select tablespace_name</span><br><span class="line">           , trunc(sum(bytes / 1024 / 1024 / 1024), 2) free_space</span><br><span class="line">      from dba_free_space</span><br><span class="line">      group by tablespace_name) b</span><br><span class="line">where a.tablespace_name = b.tablespace_name(+)</span><br><span class="line">order by 5;</span><br><span class="line"></span><br><span class="line">-- 整个用户有多大（比如 TEST_USER 用户）</span><br><span class="line">select sum(bytes) / 1024 / 1024 / 1024 &quot;G&quot;</span><br><span class="line">from dba_segments</span><br><span class="line">where owner = &#x27;TEST_USER&#x27;;</span><br><span class="line"></span><br><span class="line">-- 回收站情况</span><br><span class="line">select SUM(BYTES) / 1024 / 1024 / 1024</span><br><span class="line">from DBA_SEGMENTS</span><br><span class="line">WHERE owner = &#x27;TEST_USER&#x27;</span><br><span class="line">  AND SEGMENT_NAME LIKE &#x27;BINS%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 分区最多的前20个对象（先知道表就可以大概了解了，索引可以后续再观察）</span><br><span class="line">select *</span><br><span class="line">from (select table_owner, table_name, count(*) cnt</span><br><span class="line">      from dba_tab_partitions</span><br><span class="line">      WHERE table_owner in (&#x27;TEST_USER&#x27;)</span><br><span class="line">      group by table_owner, table_name</span><br><span class="line">      order by cnt desc)</span><br><span class="line">where rownum &lt; 20;</span><br></pre></td></tr></table></figure><h4 id="静态局部"><a href="#静态局部" class="headerlink" title="静态局部"></a>静态局部</h4><p>检查有哪些函数索引或者位图索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 检查有哪些函数索引或者位图索引（大多数情况下开发人员对这两类索引是使用不当的，所以需要捞出来确认一下)</span><br><span class="line">select t.owner</span><br><span class="line">     , t.index_name</span><br><span class="line">     , t.index_type</span><br><span class="line">     , t.status</span><br><span class="line">     , t.blevel</span><br><span class="line">     , t.leaf_blocks</span><br><span class="line">from dba_indexes t</span><br><span class="line">where index_type in (&#x27;BITMAP&#x27;, &#x27;FUNCTION-BASED NORMAL&#x27;)</span><br><span class="line">  and owner in (&#x27;TEST_USER&#x27;);</span><br></pre></td></tr></table></figure><hr><p>检查CACHE小于20的序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 检查序CACHE小于20的序列的情况（一般情况下可将其增至1000左右，序列默认的20太小）</span><br><span class="line">select t.sequence_name</span><br><span class="line">     , t.cache_size</span><br><span class="line">     , &#x27;alter sequence &#x27; || t.sequence_owner || &#x27;.&#x27; || t.sequence_name || &#x27; cache 1000;&#x27;</span><br><span class="line">from dba_sequences t</span><br><span class="line">where sequence_owner in (&#x27;TEST_USER&#x27;)</span><br><span class="line">  AND CACHE_SIZE &lt; 20;</span><br></pre></td></tr></table></figure><hr><p>分析需要跟踪的表和索引的情况</p><p>查看表大小情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 记录的大小</span><br><span class="line">select count(*)</span><br><span class="line">from TANBLE_NAME;</span><br><span class="line"></span><br><span class="line">-- 物理的大小</span><br><span class="line">select segment_name, sum(bytes) / 1024 / 1024</span><br><span class="line">from user_segments</span><br><span class="line">where segment_name in (&#x27;TANBLE_NAME&#x27;)</span><br><span class="line">group by segment_name;</span><br></pre></td></tr></table></figure><p>查看表结构情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">-- 查看表信息</span><br><span class="line">select t.table_name</span><br><span class="line">     , t.num_rows</span><br><span class="line">     , t.blocks</span><br><span class="line">     -- t.empty_blocks, --统计信息不收集这个字段，所以不需要这个字段了</span><br><span class="line">     , t.degree</span><br><span class="line">     , t.last_analyzed</span><br><span class="line">     , t.temporary</span><br><span class="line">     , t.partitioned</span><br><span class="line">     , t.pct_free</span><br><span class="line">     , t.tablespace_name</span><br><span class="line">from user_tables t</span><br><span class="line">where table_name in (&#x27;TABLE_NAME&#x27;);</span><br><span class="line"></span><br><span class="line">-- 查看分区表相关信息</span><br><span class="line">-- 查看分区表相关信息(user_part_tables记录分区的表的信息，user_tab_partitions记录表的分区的信息)</span><br><span class="line">-- 以下了解这些表的分区是什么类型的，有多少个分区</span><br><span class="line">select t.table_name</span><br><span class="line">     , t.partitioning_type</span><br><span class="line">     , t.partition_count</span><br><span class="line">from user_part_tables t</span><br><span class="line">where table_name in (&#x27;TABLE_NAME&#x27;);</span><br><span class="line"></span><br><span class="line">-- 以下了解这些表以什么列作为分区</span><br><span class="line">Select name</span><br><span class="line">     , object_type</span><br><span class="line">     , column_name</span><br><span class="line">from user_part_key_columns</span><br><span class="line">where name in (&#x27;TABLE_NAME&#x27;);</span><br><span class="line"></span><br><span class="line">-- 以下了解这些表的分区范围是多少</span><br><span class="line">SELECT table_name, partition_name, high_value, tablespace_name</span><br><span class="line">FROM user_tab_partitions t</span><br><span class="line">where table_name in (&#x27;TABLE_NAME&#x27;)</span><br><span class="line">order by table_name, t.partition_position;</span><br></pre></td></tr></table></figure><p>每张表对应有多少个索引，物理多大</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">select t2.table_name</span><br><span class="line">     , t1.segment_name</span><br><span class="line">     , sum(t1.bytes) / 1024 / 1024</span><br><span class="line">from user_segments t1</span><br><span class="line">   , user_indexes t2</span><br><span class="line">where t1.segment_name = t2.index_name</span><br><span class="line">  and t1.segment_type like &#x27;%INDEX%&#x27;</span><br><span class="line">  and t2.table_name in (&#x27;T1&#x27;)</span><br><span class="line">group by t2.table_name, t1.segment_name</span><br><span class="line">order by table_name;</span><br><span class="line"></span><br><span class="line">-- 结构情况（高度、重复度、并行度、叶子高度、聚合因子、记录数、状态、最近分析时间...）</span><br><span class="line">select t.table_name</span><br><span class="line">     , t.index_name</span><br><span class="line">     , t.num_rows</span><br><span class="line">     , t.index_type</span><br><span class="line">     , t.status</span><br><span class="line">     , t.clustering_factor</span><br><span class="line">     , t.blevel</span><br><span class="line">     , t.distinct_keys</span><br><span class="line">     , t.leaf_blocks</span><br><span class="line">     , t.uniqueness</span><br><span class="line">     , t.degree</span><br><span class="line">     , t.last_analyzed</span><br><span class="line">from user_indexes t</span><br><span class="line">where table_name in (&#x27;TABLE_NAME&#x27;);</span><br></pre></td></tr></table></figure><p>查看索引列信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- 以下可以查出来的是索引的列是什么（无论分区表和非分区表都可以查出）</span><br><span class="line">select t.table_name, t.index_name, t.column_name, t.column_position, t.DESCEND</span><br><span class="line">from user_ind_columns t</span><br><span class="line">where table_name in (&#x27;TABLE_NAME&#x27;)</span><br><span class="line">order by table_name, index_name, column_position;</span><br><span class="line"></span><br><span class="line">-- 以下查出的都是分区索引</span><br><span class="line">select table_name, index_name, partitioning_type, partition_count</span><br><span class="line">from user_part_indexes</span><br><span class="line">where table_name in (&#x27;TABLE_NAME&#x27;)</span><br><span class="line">order by table_name, index_name;</span><br><span class="line"></span><br><span class="line">select index_name, partition_name, status, blevel, leaf_blocks</span><br><span class="line">from user_ind_partitions</span><br><span class="line">where index_name in</span><br><span class="line">      (select index_name</span><br><span class="line">       from user_indexes</span><br><span class="line">       where table_name in (&#x27;TABLE_NAME&#x27;));</span><br></pre></td></tr></table></figure><h3 id="开发规范-让开发者驾轻就熟"><a href="#开发规范-让开发者驾轻就熟" class="headerlink" title="开发规范 让开发者驾轻就熟"></a>开发规范 让开发者驾轻就熟</h3><h4 id="sql-编写规范"><a href="#sql-编写规范" class="headerlink" title="sql 编写规范"></a>sql 编写规范</h4><p>单条SQL长度不宜超过100行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 判断过长 sql</span><br><span class="line">select sql_id, count(*)</span><br><span class="line">from v$sqltext</span><br><span class="line">group by sql_id</span><br><span class="line">having count(*) &gt;= 100</span><br><span class="line">order by count(*) desc;</span><br></pre></td></tr></table></figure><hr><p>SQL子查询嵌套不宜超过3层<br>一般来说，子查询嵌套如果超过3层，容易导致$QL语句的解析过于复杂，导致产生错误的执行计划。此外子查询嵌套过多，一般适宜分解成更简单的多条SQL。</p><hr><p>SQL表关联需考虑连接和限制条件的索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">drop table t purge;</span><br><span class="line">create table t as</span><br><span class="line">select *</span><br><span class="line">from v$sql_plan;</span><br><span class="line"></span><br><span class="line">-- 使用Nested Loops Join但是未用到索引的，比较可疑</span><br><span class="line">select *</span><br><span class="line">from t</span><br><span class="line">where sql_id not in (select sql_id</span><br><span class="line">                     from t</span><br><span class="line">                     where sql_id in (select sql_id from t where operation = &#x27;NESTED LOOPS&#x27;)</span><br><span class="line">                       and (operation like &#x27;%INDEX%&#x27; or object_owner like &#x27;%SYS%&#x27;))</span><br><span class="line">  and sql_id in (select sql_id from t where operation = &#x27;NESTED LOOPS&#x27;);</span><br></pre></td></tr></table></figure><hr><p>尽量避免HNT在代码中出现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 找出非SYS用户用HINT的所有SQL来分析</span><br><span class="line">select sql_text</span><br><span class="line">     , sql_id</span><br><span class="line">     , module</span><br><span class="line">     , t.service</span><br><span class="line">     , first_load_time</span><br><span class="line">     , last_load_time</span><br><span class="line">     , executions</span><br><span class="line">     , service</span><br><span class="line">from v$sql t</span><br><span class="line">where sql_text like &#x27;%/*+%&#x27;</span><br><span class="line">  and t.SERVICE not like &#x27;SYS$%&#x27;;</span><br></pre></td></tr></table></figure><hr><p>同一SQL模块避免出现大量相似之处<br>这种SQL写法一般比较可疑，一般可以优化，比如 WITH 子句等等，所以出现后需引起注意。</p><hr><p>用到并行度需谨慎</p><p>表和索引属性设置并行<br>找出被设置成并行属性的表和索引，并修正</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select t.owner, t.table_name, degree</span><br><span class="line">from dba_tables t</span><br><span class="line">where t.degree &gt; &#x27;1&#x27;;</span><br><span class="line"></span><br><span class="line">select t.owner, t.table_name, index_name, degree, status</span><br><span class="line">from dba_indexes t</span><br><span class="line">where owner in (&#x27;TEST_USER&#x27;)</span><br><span class="line">  and t.degree &gt; &#x27;1&#x27;;</span><br><span class="line"></span><br><span class="line">-- 有问题就要处理，比如索引有并行，就处理如下：</span><br><span class="line">select &#x27;alter index &#x27; || t.owner || &#x27;.&#x27; || index_name || &#x27; noparallel;&#x27;</span><br><span class="line">from dba_indexes t</span><br><span class="line">where owner in (&#x27;TEST_USER&#x27;)</span><br><span class="line">  and t.degree &gt; &#x27;1&#x27;;</span><br></pre></td></tr></table></figure><p>SQL中 HINT 的并行设置<br>属性未设并行，但是 HINT 设并行的SQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select sql_text</span><br><span class="line">     , sql_id</span><br><span class="line">     , module</span><br><span class="line">     , service</span><br><span class="line">     , first_load_time</span><br><span class="line">     , last_load_time</span><br><span class="line">     , executions</span><br><span class="line">from v$sql t</span><br><span class="line">where sql_text like &#x27;%parall%&#x27;</span><br><span class="line">  and t.SERVICE not like &#x27;SYS$%&#x27;;</span><br></pre></td></tr></table></figure><hr><p>尽量避免对列进行运算<br>捞取对列进行运算的SQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select sql_text</span><br><span class="line">     , sql_id</span><br><span class="line">     , module</span><br><span class="line">     , t.service</span><br><span class="line">     , first_load_time</span><br><span class="line">     , last_load_time</span><br><span class="line">     , executions</span><br><span class="line">from v$sql t</span><br><span class="line">where (upper(sql_text) like &#x27;%TRUNC%&#x27;</span><br><span class="line">    or upper(sql_text) like &#x27;%TO_DATE%&#x27;</span><br><span class="line">    or upper(sql_text) like &#x27;%SUBSTR%&#x27;)</span><br><span class="line">  and t.SERVICE not like &#x27;SYS$%&#x27;;</span><br></pre></td></tr></table></figure><h4 id="PL-SQL-编写规范"><a href="#PL-SQL-编写规范" class="headerlink" title="PL&#x2F;SQL 编写规范"></a>PL&#x2F;SQL 编写规范</h4><p>注释不少于代码的十分之一<br>注释如果过少，将容易导致开发者后续忘记代码的逻辑，尤其是对新人交接很不利，一般建议注释不少于代码的十分之一。<br>捞取注释少于代码十分之一的程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from (select name</span><br><span class="line">           , t.type</span><br><span class="line">           , sum(case when text like &#x27;%--%&#x27; then 1 else 0 end) / count(*) rate</span><br><span class="line">      from user_source t</span><br><span class="line">      where type in (&#x27;package body&#x27;, &#x27;procedure&#x27;, &#x27;function&#x27;) -- 包头就算了</span><br><span class="line">      group by name, type</span><br><span class="line">      having sum(case when text like &#x27;%-%&#x27; then 1 else 0 end) / count(*) &lt;= 1 / 10)</span><br><span class="line">order by rate;</span><br></pre></td></tr></table></figure><hr><p>代码必须提供最小化测试案例于注释中<br>这是一个值得推崇的好习惯，对新人接手熟悉程序尤为有用。</p><hr><p>绑定变量</p><p>相似语句需考虑绑定变量<br>这里就不提供脚本了，在前面的“检查系统使用绑定变量的情况”中已提供代码。</p><p>动态SQL最容易遗忘绑定变量<br>一般来说，动态SQL未用绑定变量的情况多半是因为未使用 USING 关键字，所以可用如下脚本来搜索可疑的未用绑定变量的动态SQL。<br>动态SQL未用 USING 有可能未用绑定变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from user_source</span><br><span class="line">where name in</span><br><span class="line">      (select name</span><br><span class="line">       from user_source</span><br><span class="line">       where name in (select name from user_source where UPPER(text) like &#x27;%EXECUTE IMMEDIATE%&#x27;))</span><br><span class="line">  and name in</span><br><span class="line">      (select name from user_source where name in (select name from user_source where UPPER(text) like &#x27;%||%&#x27;))</span><br><span class="line">  and name not in</span><br><span class="line">      (select name from user_source where name in (select name from user_source where upper(text) not like &#x27;%USING%&#x27;));</span><br></pre></td></tr></table></figure><hr><p>尽量使用批量提交<br>未使用批量提交，一般都是因为将 commit 写到了循环内。以下语句可查出单个 session 提交次数超过10000次的情况，这么多次很可疑，应该捞取出来进行分析。<br>查询提交次数过多的 SESSION</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select t1.sid, t1.value, t2.name</span><br><span class="line">from v$sesstat t1</span><br><span class="line">   , v$statname t2</span><br><span class="line">--where t2.name like &#x27;%commit%&#x27;</span><br><span class="line">where t2.name like &#x27;%user commits%&#x27; --可以只选user commits,其他系统级的先不关心</span><br><span class="line">  and t1.STATISTIC# = t2.STATISTIC#</span><br><span class="line">  and value &gt; 10000</span><br><span class="line">order by value desc;</span><br></pre></td></tr></table></figure><hr><p>同一过程包中出现重复逻辑块需封装，统一调用<br>这是封装的概念，否则修改统一逻辑，代码可能需要修改多处，不利于维护。</p><hr><p>生产环境尽量使用包来封装过程和函数<br>一般来说，只要是正式的产品，就必须使用包。<br>查询未用包的程序逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select distinct name, type</span><br><span class="line">from user_source</span><br><span class="line">where type in (&#x27;PROCEDURE&#x27;, &#x27;FUNCTION&#x27;)</span><br><span class="line">order by type;</span><br></pre></td></tr></table></figure><hr><p>动态SQL编写需设法保存真实SQL<br>动态SQL编写最大的麻烦在于调试困难，因为语句是拼装组合而成的，无论是出现该语句的语法错误还是性能问题，都无法被有效跟踪到。<br>此时考虑将拼装成的$QL记录在某张表里，将会给调试跟踪带来极大的方便。</p><h3 id="设计规范-助设计者运筹帷幄"><a href="#设计规范-助设计者运筹帷幄" class="headerlink" title="设计规范 助设计者运筹帷幄"></a>设计规范 助设计者运筹帷幄</h3><h4 id="表规范"><a href="#表规范" class="headerlink" title="表规范"></a>表规范</h4><p>范式</p><ol><li>绝大部分场景要遵循第三范式。减少数据冗余</li><li>适当场景考虑反范式。为提高性能</li></ol><hr><p>不同类表的要点差异</p><ol><li>小表（参数配置表）<ul><li>一般需要有主键。</li><li>一般需要有约束。</li><li>尽量规划在同一表空间。</li></ul></li><li>大表（业务表及日志表）<ul><li>尺寸超过10GB需考虑建分区</li><li>分区表中分区个数超过100要注意</li><li>大表尽量要有明确的数据保留策略<ul><li>体现在设计文档。</li><li>实现步骤体现在维护脚本中。</li><li>体现在表注释中。</li></ul></li><li>大表坚决不允许有触发器</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">-- 表大小超过10GB未建分区的</span><br><span class="line">select owner</span><br><span class="line">     , segment_name</span><br><span class="line">     , segment_type</span><br><span class="line">     , sum(bytes) / 1024 / 1024 / 1024 object_size</span><br><span class="line">from dba_segments</span><br><span class="line">WHERE segment_type = &#x27;TABLE&#x27; -- 此处说明是普通表，不是分区表，如果是分区表，类型是TABLE PARTITION</span><br><span class="line">group by owner, segment_name, segment_type</span><br><span class="line">having sum(bytes) / 1024 / 1024 / 1024 &gt;= 10</span><br><span class="line">order by object_size desc;</span><br><span class="line"></span><br><span class="line">-- 分区个数超过100个的表</span><br><span class="line">select table_owner, table_name, count(*) cnt</span><br><span class="line">from dba_tab_partitions</span><br><span class="line">WHERE table_owner in (&#x27;TEST_USER&#x27;)</span><br><span class="line">having count(*) &gt;= 100</span><br><span class="line">group by table_owner, table_name</span><br><span class="line">order by cnt desc;</span><br><span class="line"></span><br><span class="line">-- 表大小超过10GB，有时间字段，可以考虑在该列上建立分区</span><br><span class="line">-- 超过10GB的大表没有时间字段</span><br><span class="line">select T1.*, t2.column_name, t2.data_type</span><br><span class="line">from (select segment_name</span><br><span class="line">           , segment_type</span><br><span class="line">           , sum(bytes) / 1024 / 1024 / 1024 object_size</span><br><span class="line">      from user_segments</span><br><span class="line">      WHERE segment_type = &#x27;TABLE&#x27; --此处说明是普通表，不是分区表，如果是分区表，类型是TABLE PARTITION</span><br><span class="line">      group by segment_name, segment_type</span><br><span class="line">      having sum(bytes) / 1024 / 1024 / 1024 &gt;= 0.01</span><br><span class="line">      order by object_size desc) t1</span><br><span class="line">   , user_tab_columns t2</span><br><span class="line">where t1.segment_name = t2.table_name(+)</span><br><span class="line">  and t2.DATA_TYPE = &#x27;DATE&#x27;</span><br><span class="line">-- 来说明这个大表有时间列</span><br><span class="line"></span><br><span class="line">-- 上述语句和下面的语句进行观察比较 下面只是过滤了大小</span><br><span class="line">select segment_name</span><br><span class="line">     , segment_type</span><br><span class="line">     , sum(bytes) / 1024 / 1024 / 1024 object_size</span><br><span class="line">from user_segments</span><br><span class="line">WHERE segment_type = &#x27;TABLE&#x27; -- 此处说明是普通表，不是分区表，如果是分区表，类型是TABLE PARTITION</span><br><span class="line">group by segment_name, segment_type</span><br><span class="line">having sum(bytes) / 1024 / 1024 / 1024 &gt;= 0.01</span><br><span class="line">order by object_size desc;</span><br><span class="line"></span><br><span class="line">-- 找出有建触发器的表，同时观察该表多大</span><br><span class="line">select trigger_name, table_name, tab_size</span><br><span class="line">from user_triggers t1</span><br><span class="line">   , (select segment_name, sum(bytes / 1024 / 1024 / 1024) tab_size</span><br><span class="line">      from user_segments t</span><br><span class="line">      where t.segment_type = &#x27;TABLE&#x27;</span><br><span class="line">      group by segment_name) t2</span><br><span class="line">where t1.TABLE_NAME = t2.segment_name;</span><br></pre></td></tr></table></figure><p>注：<br>触发器是一种存储在数据库中的程序，它定义了一组SQL语句，当特定的事件发生时自动执行这组SQL语句。<br>这些事件通常是数据操作语言（DML）事件，如INSERT、UPDATE或DELETE操作。触发器可以用来强制执行复杂的业务规则或者维护数据完整性，例如级联更新或删除相关的行，或者记录审计日志等。</p><p>为什么大表不要有触发器？</p><ol><li><strong>性能影响</strong>：<ul><li>当对大表进行大量的DML操作时，触发器会在每个受影响的行上被执行，这会导致额外的CPU和I&#x2F;O负载。如果触发器内含有复杂的逻辑或者需要访问其他表，则性能影响会更加严重。</li><li>在高并发环境下，多个事务同时尝试修改大表中的数据，触发器的执行可能导致更多的锁等待，从而增加事务处理的时间。</li></ul></li><li><strong>可扩展性问题</strong>：<ul><li>随着表的增长，触发器的开销也会变得越来越显著。对于大规模的数据修改操作，触发器可能导致长时间的锁定，进而影响整个系统的响应时间和吞吐量。</li></ul></li><li><strong>维护复杂性</strong>：<ul><li>触发器使得数据库逻辑变得复杂，特别是在涉及多表或多步骤操作的情况下。维护触发器代码的正确性和效率也变得更加困难。</li></ul></li></ol><hr><p>表结构</p><ol><li>注释<ul><li>表必须要有注释</li><li>列尽量要有注释</li></ul></li><li>列类型<ul><li>避免使用LONG字段。可以说，现在的应用中，LONG字段几乎是有百害而无一利，所以尽量要杜绝在设计中出现LONG,一般考虑CLOB字段来替代。</li><li>避免用CHAR字段。CHAR字段的应用场合非常少，一般现在都考虑用VARCHAR2来替代。</li><li>列类型和值尽量匹配<ul><li>时间取值放入 date 列。</li><li>数字取值放入 number 列。</li><li>字符串取值放入 varchar2 列。</li></ul></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-- 查询那些表未做注释</span><br><span class="line">select TABLE_NAME, T.TABLE_TYPE</span><br><span class="line">from USER_TAB_COMMENTS T</span><br><span class="line">where table_name not like &#x27;BIN$%&#x27;</span><br><span class="line">  and comments is null</span><br><span class="line">order by table_name;</span><br><span class="line"></span><br><span class="line">-- 查询哪些列未做注释（仅供参考)</span><br><span class="line">select TABLE_NAME, COLUMN_NAME</span><br><span class="line">from USER_COL_COMMENTS</span><br><span class="line">where table_name not like &#x27;BIN$%&#x27;</span><br><span class="line">  and comments is null</span><br><span class="line">order by table_name;</span><br><span class="line"></span><br><span class="line">-- 查询哪些列是LONG类型</span><br><span class="line">SELECT TABLE_NAME, COLUMN_NAME, DATA_TYPE</span><br><span class="line">FROM user_tab_columns</span><br><span class="line">WHERE DATA_TYPE = &#x27;LONG&#x27;</span><br><span class="line">ORDER BY 1, 2;</span><br><span class="line"></span><br><span class="line">-- 查询哪些列是CHAR类型</span><br><span class="line">SELECT TABLE_NAME, COLUMN_NAME, DATA_TYPE</span><br><span class="line">FROM user_tab_columns</span><br><span class="line">WHERE DATA_TYPE = &#x27;CHAR&#x27;</span><br><span class="line">ORDER BY 1, 2;</span><br></pre></td></tr></table></figure><h4 id="索引规范"><a href="#索引规范" class="headerlink" title="索引规范"></a>索引规范</h4><p>用不上分区条件的局部索引不宜建<br>分区表建了分区索引后，如果在查询应用中无法用到这个分区索引列的条件，索引读将可能遍历所有的分区。<br>如果有100个分区，相当于遍历了100个小索引，将会严重影响性能，此时需要慎重考虑，判断是否需要修改为全局索引。</p><hr><p>函数索引大多用于列运算，一般需要避免<br>从实际应用情况来分析，应用函数索引大多是因为设计阶段考虑步骤，比如 trunc(时间列) 的写法，往往可以轻易转换成去掉 trunc<br>的写法，所以需要捞取出来验证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查询哪些索引是函数索引</span><br><span class="line">select t.index_name</span><br><span class="line">     , t.index_type</span><br><span class="line">     , t.status</span><br><span class="line">     , t.blevel</span><br><span class="line">     , t.leaf_blocks</span><br><span class="line">from user_indexes t</span><br><span class="line">where index_type in (&#x27;FUNCTION-BASED NORMAL&#x27;);</span><br></pre></td></tr></table></figure><hr><p>位图索引遇到更新将是噩梦，需谨慎设计</p><ol><li>位图索引不适合用在表频繁更新的场合。</li><li>位图索引不适合在所在列重复度很低的场合。</li></ol><p>因为位图索引的应用比较特殊，适用场合比较少，因此有必要捞取出系统中的位图索引，进行核对检测。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查询哪些索引是位图索引</span><br><span class="line">select t.index_name</span><br><span class="line">     , t.index_type</span><br><span class="line">     , t.status</span><br><span class="line">     , t.blevel</span><br><span class="line">     , t.leaf_blocks</span><br><span class="line">from user_indexes t</span><br><span class="line">where index_type in (&#x27;BITMAP&#x27;);</span><br></pre></td></tr></table></figure><hr><p>外键未建索引将引发死锁及影响表连接性能<br>外键未建索引，将有可能导致两个严重的问题：一是<strong>更新相关的表产生死锁</strong>；二是<strong>两表关联查询时性能低下</strong>。<br>因此设计中需要谨慎考虑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">-- 查询外键未建索引的表有哪些</span><br><span class="line">select table_name</span><br><span class="line">     , constraint_name</span><br><span class="line">     , cname1 || nvl2(cname2, &#x27;,&#x27; || cname2, null) ||</span><br><span class="line">       nvl2(cname3, &#x27;,&#x27; || cname3, null) ||</span><br><span class="line">       nvl2(cname4, &#x27;,&#x27; || cname4, null) ||</span><br><span class="line">       nvl2(cname5, &#x27;,&#x27; || cname5, null) ||</span><br><span class="line">       nvl2(cname6, &#x27;,&#x27; || cname6, null) ||</span><br><span class="line">       nvl2(cname7, &#x27;,&#x27; || cname7, null) ||</span><br><span class="line">       nvl2(cname8, &#x27;,&#x27; || cname8, null) columns</span><br><span class="line">from (select b.table_name</span><br><span class="line">           , b.constraint_name</span><br><span class="line">           , max(decode(position, 1, column_name, null)) cname1</span><br><span class="line">           , max(decode(position, 2, column_name, null)) cname2</span><br><span class="line">           , max(decode(position, 3, column_name, null)) cname3</span><br><span class="line">           , max(decode(position, 4, column_name, null)) cname4</span><br><span class="line">           , max(decode(position, 5, column_name, null)) cname5</span><br><span class="line">           , max(decode(position, 6, column_name, null)) cname6</span><br><span class="line">           , max(decode(position, 7, column_name, null)) cname7</span><br><span class="line">           , max(decode(position, 8, column_name, null)) cname8</span><br><span class="line">           , count(*)                                    col_cnt</span><br><span class="line">      from (select substr(table_name, 1, 30)      table_name</span><br><span class="line">                 , substr(constraint_name, 1, 30) constraint_name</span><br><span class="line">                 , substr(column_name, 1, 30)     column_name</span><br><span class="line">                 , position</span><br><span class="line">            from user_cons_columns) a</span><br><span class="line">         , user_constraints b</span><br><span class="line">      where a.constraint_name = b.constraint_name</span><br><span class="line">        and b.constraint_type = &#x27;R&#x27;</span><br><span class="line">      group by b.table_name, b.constraint_name) cons</span><br><span class="line">where col_cnt &gt; ALL</span><br><span class="line">      (select count(*)</span><br><span class="line">       from user_ind_columns i</span><br><span class="line">       where i.table_name = cons.table_name</span><br><span class="line">         and i.column_name in (cname1, cname2, cname3, cname4, cname5,</span><br><span class="line">                               cname6, cname7, cname8)</span><br><span class="line">         and i.column_position &lt;= cons.col_cnt</span><br><span class="line">       group by i.index_name);</span><br></pre></td></tr></table></figure><hr><p>建联合索引需谨慎</p><p>要结合单列查询考虑，决定前缀<br>如：既可以建立col1,col2的联合索引，又可以建立col2,col1的联合索引，此时如果存在col1列单独查询较多的情况下，一般倾向于建立col1,col2的联合索引。</p><p>范围查询影响组合索引<br>组合查询中，如果有等值条件和范围条件组合的情况，等值条件在前，性能更高。<br>如：where col1&#x3D;2 and col2&gt;&#x3D;100 and col2&lt;&#x3D;120,此时是col1,col2的组合索引性能高过col2,col1的组合索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 将有不等值查询的SQL捞取出来分析</span><br><span class="line">select sql_text</span><br><span class="line">     , sql_id</span><br><span class="line">     , service</span><br><span class="line">     , module</span><br><span class="line">     , t.first_load_time</span><br><span class="line">     , t.last_load_time</span><br><span class="line">from v$sql t</span><br><span class="line">where (sql_text like &#x27;%&gt;%&#x27; or sql_text like &#x27;%&lt;%&#x27; or sql_text like &#x27;%&lt;&gt;%&#x27;)</span><br><span class="line">  and sql_text not like &#x27;%=&gt;%&#x27;</span><br><span class="line">  and service not like &#x27;SYS$%&#x27;;</span><br></pre></td></tr></table></figure><p>需考虑回表因素<br>一般情况下，如果建索引可以避免回表（在索引中即可完成检测），也可考虑对多列建组合索引，不过组合索引列不宜超过4个。</p><p>超过4个字段的联合索引需注意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 捞取超过4个字段组合的联合索引</span><br><span class="line">select table_name, index_name, count(*)</span><br><span class="line">from user_ind_columns</span><br><span class="line">group by table_name, index_name</span><br><span class="line">having count(*) &gt;= 4</span><br><span class="line">order by count(*) desc;</span><br></pre></td></tr></table></figure><hr><p>单表索引个数需控制</p><p>索引个数超过5个以上的<br>超过5个以上的索引，在表的记录很大时，将会极大地影响该表的更新，因此在表中建索引时需要谨慎考虑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 单表的索引个数超过5个需注意</span><br><span class="line">select table_name, count(*)</span><br><span class="line">from user_indexes</span><br><span class="line">group by table_name</span><br><span class="line">having count(*) &gt;= 5</span><br><span class="line">order by count(*) desc;</span><br></pre></td></tr></table></figure><p>建后2个月内从未使用过的索引<br>一般来说，在2个月内从未被用到的索引是多余的索引，可以考虑删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 跟踪索引的使用情况，控制索引的数量</span><br><span class="line">select &#x27;alter index &#x27; || index_name || &#x27; monitoring usage;&#x27;</span><br><span class="line">from user_indexes;</span><br><span class="line"></span><br><span class="line">-- 然后观察：</span><br><span class="line">select *</span><br><span class="line">from v$object_usage;</span><br><span class="line"></span><br><span class="line">-- 停止对索引的监控，观察v$object_usage状态变化（以某索引IDX_OBJECT_ID为例）</span><br><span class="line">alter index IDX_OBJECT_ID nomonitoring usage;</span><br></pre></td></tr></table></figure><hr><p>单表无任何索引需重视<br>单表无任何索引的情况一般比较少见，可以捞取出来，再结合SQL应用进行分析，观察该表的大小以及是否有时间字段及编码字段这样的适宜建索引的列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询无任何索引的表</span><br><span class="line">select table_name</span><br><span class="line">from user_tables</span><br><span class="line">where table_name not in (select table_name from user_indexes);</span><br></pre></td></tr></table></figure><hr><p>需注意索引的失效情况</p><ol><li>对表进行move操作，会导致索引失效，操作需考忠索引的重建。</li><li>对分区表进行系列操作，如 split、drop、truncate 分区时，容易导致分区表的全局索引失效，需要考虑增加<code>update global indexes</code><br>的关键字进行操作，或者重建索引。</li><li>分区表SPLIT的时候，如果MAX区中已经有记录了，这个时候SPLIT就会导致有记录的新增分区的局部索引失效。</li></ol><p>普通表及分区表的全局索引失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询失效的普通索引</span><br><span class="line">select index_name, table_name, tablespace_name, index_type</span><br><span class="line">from user_indexes</span><br><span class="line">where status = &#x27;UNUSABLE&#x27;;</span><br></pre></td></tr></table></figure><p>分区表局部索引失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 查询失效的分区局部索引</span><br><span class="line">select t1.index_name</span><br><span class="line">     , t1.partition_name</span><br><span class="line">     , t1.global_stats</span><br><span class="line">     , t2.table_name</span><br><span class="line">     , t2.table_type</span><br><span class="line">from user_ind_partitions t1</span><br><span class="line">   , user_indexes t2</span><br><span class="line">where t2.index_name = t1.index_name</span><br><span class="line">and t1.status =&#x27;UNUSABLE&#x27;;</span><br></pre></td></tr></table></figure><h4 id="环境参数规范"><a href="#环境参数规范" class="headerlink" title="环境参数规范"></a>环境参数规范</h4><p>数据库参数</p><p>SGA及PGA参数</p><p>OLTP应用是主机内存的80%分配数据库，其中 SGA80%,PGA20%。<br>OLAP应用是主机内存的80%分配数据库，其中 SGA50%,PGA50%。<br>如OLTP应用：主机内存30GB,SGA即是 30 X 0.8 X 0.8 &#x3D; 20GB 左右。<br>不过这里还是要注意：并没有什么黄金参数，这些还只能是参考。</p><p>PROCESS&#x2F;SESSION</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 默认连接数是150，这对大多数应用都无法满足，大型应用一般不少于1000个。</span><br><span class="line">show parameter process</span><br><span class="line">show parameter session</span><br><span class="line"></span><br><span class="line">select count(*)</span><br><span class="line">from v$process;</span><br><span class="line"></span><br><span class="line">select count(*)</span><br><span class="line">from v$session;</span><br></pre></td></tr></table></figure><p>OPEN_CURSOR游标参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 默认open_cursors是300，大型应用需设置1000以上，原则上不超过PROCESS设置。</span><br><span class="line">show parameter open_cursor</span><br></pre></td></tr></table></figure><p>日志参数<br>一般来说，Oracle默认的日志参数是3组，大小为500MB,在实际较大的生产应用中往往不够，需要至少考虑在5组以上，大小在1GB以上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 生产系统大多需要开启归档。</span><br><span class="line">archive log list</span><br></pre></td></tr></table></figure><hr><p>表空间规划</p><ol><li>回滚表空间<ul><li>自动管理。</li><li>避免自动扩展。</li><li>尽可能规划大一些。</li></ul></li><li>临时表空间<ul><li>避免自动扩展。</li><li>尽可能大。</li><li>尽可能使用临时表空间组。</li></ul></li><li>业务表空间<ul><li>控制个数，不超过6个为宜。</li><li>尽量避免自动扩展，超阀值由监控来检查。</li><li>根据自己的业务，固定表空间名。</li><li>表空间需良好分类（参数配置表，业务数据表，历史记录表）。</li><li>表空间需合理命名。</li></ul></li></ol><hr><p>RAC系统</p><ol><li>尽量采用BALANCE模式，保证两节点压力大致相当。</li><li>可适当考虑不同类型的业务部署在不同的节点上，避免RAC的CACHE争用。</li><li>尽量考虑不同的节点使用不同的临时表空间。</li></ol><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><p>只是示范，一般都有自己的命名方式，但团队要有统一的规范。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">-- 查询表的前缀是否以t_开头</span><br><span class="line">select*</span><br><span class="line">from user_tables</span><br><span class="line">where substr(table_name, 1, 2) &lt;&gt; &#x27;T_&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询视图的前缀是否以v_开头</span><br><span class="line">select view_name</span><br><span class="line">from user_views</span><br><span class="line">where substr(view_name, 1, 2) &lt;&gt; &#x27;V_&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询同义词的前缀是否以s_开头</span><br><span class="line">select synonym_name, table_owner, table_name</span><br><span class="line">from user_synonyms</span><br><span class="line">where substr(synonym_name, 1, 2) &lt;&gt; &#x27;S_&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询簇表的前缀是否以c_开头</span><br><span class="line">select t.cluster_name, t.cluster_type</span><br><span class="line">from user_clusters t</span><br><span class="line">where substr(cluster_name, 1, 2) &lt;&gt; &#x27;C_&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询序列的前缀是否以seq开头或结尾</span><br><span class="line">select sequence_name, cache_size</span><br><span class="line">from user_sequences</span><br><span class="line">where sequence_name not like &#x27;%SEQ%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询存储过程是否以p_开头</span><br><span class="line">select object_name, procedure_name</span><br><span class="line">from user_procedures</span><br><span class="line">where object_type = &#x27;PROCEDURE&#x27;</span><br><span class="line">  and substr(object_name, 1, 2) &lt;&gt; &#x27;P_&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询函数是否以f_开头</span><br><span class="line">select object_name, procedure_name</span><br><span class="line">from user_procedures</span><br><span class="line">where object_type = &#x27;FUNCTION&#x27;</span><br><span class="line">  and substr(object_name, 1, 2) &lt;&gt; &#x27;F_&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询包是否以pkg开头</span><br><span class="line">select object_name, procedure_name</span><br><span class="line">from user_procedures</span><br><span class="line">where object_type = &#x27;PACKAGE&#x27;</span><br><span class="line">  and substr(object_name, 1, 4) &lt;&gt; &#x27;PKG&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询类是否以typ开头</span><br><span class="line">select object_name, procedure_name</span><br><span class="line">from user_procedures</span><br><span class="line">where object_type = &#x27;TYPE&#x27;</span><br><span class="line">  and substr(object_name, 1, 4) &lt;&gt; &#x27;TYP&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询主键是否以pk_开头</span><br><span class="line">select constraint_name, table_name</span><br><span class="line">from user_constraints</span><br><span class="line">where constraint_type = &#x27;p&#x27;</span><br><span class="line">  and substr(constraint_name, 1, 3) &lt;&gt; &#x27;PK_&#x27;</span><br><span class="line">  and constraint_name not like &#x27;BINS%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询外键是否以fk_开头</span><br><span class="line">select constraint_name, table_name</span><br><span class="line">from user_constraints</span><br><span class="line">where constraint_type = &#x27;R&#x27;</span><br><span class="line">  and substr(constraint_name, 1, 3) &lt;&gt; &#x27;FK_&#x27;</span><br><span class="line">  and constraint_name not like &#x27;BINS%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询唯一索引是否以ux_开头</span><br><span class="line">select constraint_name, table_name</span><br><span class="line">from user_constraints</span><br><span class="line">where constraint_type = &#x27;U&#x27;</span><br><span class="line">  and substr(constraint_name, 1, 3) &lt;&gt; &#x27;UX_&#x27;</span><br><span class="line">  and table_name not like &#x27;BINS%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询普通索引是否以idx_开头</span><br><span class="line">select index_name, table_name</span><br><span class="line">from user_indexes</span><br><span class="line">where index_type = &#x27;NORMAL&#x27;</span><br><span class="line">  and uniqueness = &#x27;NONUNIQUE&#x27;</span><br><span class="line">  and substr(index_name, 1, 4) &lt;&gt; &#x27;IDX_&#x27;</span><br><span class="line">  and table_name not like &#x27;BINS%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询位图索引是否以bx_开头</span><br><span class="line">select index_name, table_name</span><br><span class="line">from user_indexes</span><br><span class="line">where index_type LIKE &#x27;%BIT%&#x27;</span><br><span class="line">  and substr(index_name, 1, 3) &lt;&gt; &#x27;BX_&#x27;</span><br><span class="line">  and table_name not like &#x27;BINS%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询函数索引是否以fx_开头</span><br><span class="line">select index_name, table_name</span><br><span class="line">from user_indexes</span><br><span class="line">where index_type = &#x27;FUNCTION-BASED NORMAL&#x27;</span><br><span class="line">  and substr(index_name, 1, 3) &lt;&gt; &#x27;FX_&#x27;</span><br><span class="line">  and table_name not like &#x27;BINS%&#x27;;</span><br></pre></td></tr></table></figure><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p>终于是结束了，算是第一本静下心来读完的技术相关的书。<br>从git提交记录也可以看出，读了快两个月，中间有半个多月的空窗。是有点看不到下去了，是最艰难的索引章节，一章就占了全书的四分之一还多。<br>前面体系结构、逻辑结构里的sql还能基本都在自己搭的测试环境中验证下，但到索引很多都没有去验证，实在是太多了。算是个偷懒的地方吧，不过最后还是读完了。</p><p>这本书的作者 梁敬彬、梁敬弘 后面还写了一本 《收获，不止SQL优化》，等缓一缓，后面肯定会继续读的。<br>先整点非技术相关的书，或者非数据库相关的书调节一下。<br>就这样，Bye</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下篇的章节，主要是作者多年优化工作中的经验总结。&lt;br&gt;主要是关于解决问题的思路，如何定位问题等。技术相关的其实不多。我也觉得&lt;strong&gt;会发现问题比会解决问题的人更厉害&lt;/strong&gt;。&lt;br&gt;这几章经典的优化操作，主要的思想就是以下这些。（我读完的总结，不一定全。</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://cooooing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据库" scheme="https://cooooing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="《收获，不止Oracle》" scheme="https://cooooing.github.io/tags/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B/"/>
    
    <category term="Oracle" scheme="https://cooooing.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>《收获，不止Oracle》读书笔记上篇-表连接</title>
    <link href="https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E8%A1%A8%E8%BF%9E%E6%8E%A5/"/>
    <id>https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E8%A1%A8%E8%BF%9E%E6%8E%A5/</id>
    <published>2024-08-28T01:35:14.000Z</published>
    <updated>2024-08-28T01:35:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第六章-经典，表的连接学以致用"><a href="#第六章-经典，表的连接学以致用" class="headerlink" title="第六章 - 经典，表的连接学以致用"></a>第六章 - 经典，表的连接学以致用</h2><h3 id="三种连接类型"><a href="#三种连接类型" class="headerlink" title="三种连接类型"></a>三种连接类型</h3><p>嵌套循环连接（Nested Loop Join）、哈希连接（Hash Join）和排序合并连接（Sort Merge Join）是Oracle数据库中最常用的三种连接算法。</p><h4 id="嵌套循环连接（Nested-Loop-Join）"><a href="#嵌套循环连接（Nested-Loop-Join）" class="headerlink" title="嵌套循环连接（Nested Loop Join）"></a>嵌套循环连接（Nested Loop Join）</h4><p>嵌套循环连接是最简单的连接方法之一，它通过遍历一个表（外部表），对于外部表中的每一行，再遍历另一个表（内部表）来查找匹配的行。</p><ol><li>选择一个较小的表作为外部表。通常，外部表是较小的表或已经被索引访问的表。</li><li>遍历外部表的每一行。</li><li>对于外部表中的每一行，遍历内部表以查找匹配的行。如果找到匹配的行，则将这两行组合在一起作为结果的一部分。</li></ol><p>当一个表很小或者已经被索引访问时，嵌套循环连接可以非常高效。<br>如果内部表很大，则嵌套循环连接可能会非常慢。对于大数据量的表，嵌套循环连接可能会导致性能问题。</p><h4 id="哈希连接（Hash-Join）"><a href="#哈希连接（Hash-Join）" class="headerlink" title="哈希连接（Hash Join）"></a>哈希连接（Hash Join）</h4><p>哈希连接是一种高效的连接算法，它通过在内存中创建哈希表来查找匹配的行。</p><ol><li>选择一个较大的表作为内部表。对于内部表中的每一行，根据连接键计算哈希值，并将该行存储在一个哈希表中。</li><li>遍历外部表。对于外部表中的每一行，根据连接键计算哈希值，并在哈希表中查找匹配的行。如果找到匹配的行，则将这两行组合在一起作为结果的一部分。</li></ol><p>当内部表可以完全装入内存时很高效，可以处理较大的数据集。<br>但如果内部表太大以至于无法完全装入内存，则性能可能会受到影响。哈希表的构建可能会消耗较多的内存资源。</p><h4 id="排序合并连接（Sort-Merge-Join）"><a href="#排序合并连接（Sort-Merge-Join）" class="headerlink" title="排序合并连接（Sort Merge Join）"></a>排序合并连接（Sort Merge Join）</h4><p>排序合并连接是一种连接算法，它通过先对两个表进行排序，然后通过比较排序后的键值来查找匹配的行。</p><ol><li>对两个表按照连接键进行排序。如果表已经排序或可以通过索引访问，则可以跳过此步骤。</li><li>遍历两个排序后的表。比较两个表中当前行的连接键值。如果键值相同，则将这两行组合在一起作为结果的一部分。</li></ol><p>当连接键的值有序时，排序合并连接非常高效。可以处理大数据量。<br>但如果表未排序，则需要额外的排序步骤，这可能会消耗时间和磁盘空间。当表很大时，排序可能会很慢。</p><h3 id="各类连接访问次数差异"><a href="#各类连接访问次数差异" class="headerlink" title="各类连接访问次数差异"></a>各类连接访问次数差异</h3><p>可以使用<code>alter session set statistics_level = all</code>进行跟踪。<br>这条命令用于设置会话级别的统计信息级别。作用是开启尽可能多的统计信息收集，以便于诊断和性能调优。<br>可以知道表的访问次数。</p><h4 id="嵌套循环的表访问次数"><a href="#嵌套循环的表访问次数" class="headerlink" title="嵌套循环的表访问次数"></a>嵌套循环的表访问次数</h4><p>准备表和数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE t1 CASCADE CONSTRAINTS PURGE;</span><br><span class="line">DROP TABLE t2 CASCADE CONSTRAINTS PURGE;</span><br><span class="line">execute dbms_random.seed(0);</span><br><span class="line">create table t1 as</span><br><span class="line">SELECT rownum                      id,</span><br><span class="line">       rownum                      n,</span><br><span class="line">       dbms_random.string(&#x27;a&#x27;, 50) contents</span><br><span class="line">FROM dual</span><br><span class="line">CONNECT BY level &lt;= 100</span><br><span class="line">ORDER BY dbms_random.random;</span><br><span class="line">create table t2 as</span><br><span class="line">SELECT rownum                      id,</span><br><span class="line">       rownum                      t1_id,</span><br><span class="line">       rownum                      n,</span><br><span class="line">       dbms_random.string(&#x27;b&#x27;, 50) contents</span><br><span class="line">FROM dual</span><br><span class="line">CONNECT BY level &lt;= 100000</span><br><span class="line">ORDER BY dbms_random.random;</span><br></pre></td></tr></table></figure><p>查看嵌套循环的连接次数。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; set linesize 1000</span><br><span class="line">SQL&gt; alter session set statistics_level = all;</span><br><span class="line"></span><br><span class="line">Session altered.</span><br><span class="line"></span><br><span class="line">SQL&gt; SELECT /*+leading(t1) use_nl(t1 t2)*/ * FROM t1,t2 WHERE t1.id = t2.t1_id;</span><br><span class="line">-- 省略结果集</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from table(dbms_xplan.display_cursor(null,null,&#x27;allstats last&#x27;));</span><br><span class="line"></span><br><span class="line">PLAN_TABLE_OUTPUT</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">SQL_ID  f7haq9xwppqqf, child number 0</span><br><span class="line">-------------------------------------</span><br><span class="line">SELECT /*+leading(t1) use_nl(t1 t2)*/ * FROM t1,t2 WHERE t1.id = t2.t1_id</span><br><span class="line"></span><br><span class="line">Plan hash value: 1967407726</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation          | Name | Starts | E-Rows | A-Rows |   A-Time   | Buffers |</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT   |      |      1 |        |    100 |00:00:00.33 |   98515 |</span><br><span class="line"></span><br><span class="line">PLAN_TABLE_OUTPUT</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">|   1 |  NESTED LOOPS      |      |      1 |    100 |    100 |00:00:00.33 |   98515 |</span><br><span class="line">|   2 |   TABLE ACCESS FULL| T1   |      1 |    100 |    100 |00:00:00.01 |       9 |</span><br><span class="line">|*  3 |   TABLE ACCESS FULL| T2   |    100 |      1 |    100 |00:00:00.33 |   98506 |</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   3 - filter(&quot;T1&quot;.&quot;ID&quot;=&quot;T2&quot;.&quot;T1_ID&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">21 rows selected.</span><br></pre></td></tr></table></figure><p>Starts 这列表示表访问的次数。这里 t1 被访问了1次，t2 被访问了 100 次。</p><p>下面还有三条不同i情况的语句，就不一一贴详细执行过程，直接说结果了。<br><code>SELECT /*+leading(t1) use_nl(t1 t2)*/ * FROM t1,t2 WHERE t1.id = t2.t1_id and t1.n in (17,19);</code> t2 表被访问2次<br><code>SELECT /*+leading(t1) use_nl(t1 t2)*/ * FROM t1,t2 WHERE t1.id = t2.t1_id and t1.n 19;</code> t2 表被访问1次<br><code>SELECT /*+leading(t1) use_nl(t1 t2)*/ * FROM t1,t2 WHERE t1.id = t2.t1_id and t1.n = 999999999;</code> t2 表被访问0次</p><p>原因也很简单，和 t1 表中返回的数据数量有关。<br><strong>在嵌套循环连接中，驱动表返回多少条记录，被驱动表就访问多少次。</strong></p><p>此外，这里使用 <code>/*+leading(t1) use_nl(t1 t2)*/</code> 这个 HINT。<br>其中<code>use_nl</code>表示强制用嵌套循环连接方式。<code>leading(t1)</code>表示强制先访问 t1 表，也就是 t1 表作为驱动表。</p><h4 id="哈希连接的表访问次数"><a href="#哈希连接的表访问次数" class="headerlink" title="哈希连接的表访问次数"></a>哈希连接的表访问次数</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; SELECT /*+leading(t1) use_hash(t1 t2)*/ * FROM t1,t2 WHERE t1.id = t2.t1_id;</span><br><span class="line">-- 省略结果集</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from table(dbms_xplan.display_cursor(null,null,&#x27;allstats last&#x27;));</span><br><span class="line"></span><br><span class="line">PLAN_TABLE_OUTPUT</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">SQL_ID  bgn80s3r4xwq9, child number 0</span><br><span class="line">-------------------------------------</span><br><span class="line">SELECT /*+leading(t1) use_hash(t1 t2)*/ * FROM t1,t2 WHERE t1.id =</span><br><span class="line">t2.t1_id</span><br><span class="line"></span><br><span class="line">Plan hash value: 1838229974</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation          | Name | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT   |      |      1 |        |    100 |00:00:00.02 |     994 |       |       |          |</span><br><span class="line"></span><br><span class="line">PLAN_TABLE_OUTPUT</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|*  1 |  HASH JOIN         |      |      1 |    100 |    100 |00:00:00.02 |     994 |  1000K|  1000K| 1329K (0)|</span><br><span class="line">|   2 |   TABLE ACCESS FULL| T1   |      1 |    100 |    100 |00:00:00.01 |       2 |       |       |          |</span><br><span class="line">|   3 |   TABLE ACCESS FULL| T2   |      1 |    100K|    100K|00:00:00.01 |     992 |       |       |          |</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   1 - access(&quot;T1&quot;.&quot;ID&quot;=&quot;T2&quot;.&quot;T1_ID&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">21 rows selected.</span><br></pre></td></tr></table></figure><p><strong>在HASH连接中，驱动表和被驱动表都只会访问0次或者1次。</strong></p><p>哈希连接中，只有构建哈希表这一步需遍历驱动表一次。哈希表构建完成后，后续的查找阶段不再需要访问驱动表，而是直接在哈希表中查找匹配项。被驱动表同理。<br>当驱动表中没有符合条件的数据时，便不会访问被驱动表。当查询条件始终不成立时（比如 where 1 &#x3D; 2），也不会访问驱动表。</p><h4 id="排序合并的表访问次数"><a href="#排序合并的表访问次数" class="headerlink" title="排序合并的表访问次数"></a>排序合并的表访问次数</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; SELECT /*+ordered use_merge(t1 t2)*/ * FROM t1,t2 WHERE t1.id = t2.t1_id;</span><br><span class="line">-- 省略结果集</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from table(dbms_xplan.display_cursor(null,null,&#x27;allstats last&#x27;));</span><br><span class="line"></span><br><span class="line">PLAN_TABLE_OUTPUT</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">SQL_ID  bgs49pws4vu8d, child number 0</span><br><span class="line">-------------------------------------</span><br><span class="line">SELECT /*+ordered use_merge(t1 t2)*/ * FROM t1,t2 WHERE t1.id = t2.t1_id</span><br><span class="line"></span><br><span class="line">Plan hash value: 412793182</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation           | Name | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |  OMem |  1Mem | Used-Mem |</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT    |      |      1 |        |    100 |00:00:00.07 |     987 |    982 |       |       |          |</span><br><span class="line">|   1 |  MERGE JOIN         |      |      1 |    100 |    100 |00:00:00.07 |     987 |    982 |       |       |          |</span><br><span class="line"></span><br><span class="line">PLAN_TABLE_OUTPUT</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">|   2 |   SORT JOIN         |      |      1 |    100 |    100 |00:00:00.01 |       2 |      1 | 13312 | 13312 |12288  (0)|</span><br><span class="line">|   3 |    TABLE ACCESS FULL| T1   |      1 |    100 |    100 |00:00:00.01 |       2 |      1 |       |       |          |</span><br><span class="line">|*  4 |   SORT JOIN         |      |    100 |    100K|    100 |00:00:00.07 |     985 |    981 |  9762K|  1209K| 8677K (0)|</span><br><span class="line">|   5 |    TABLE ACCESS FULL| T2   |      1 |    100K|    100K|00:00:00.05 |     985 |    981 |       |       |          |</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   4 - access(&quot;T1&quot;.&quot;ID&quot;=&quot;T2&quot;.&quot;T1_ID&quot;)</span><br><span class="line">       filter(&quot;T1&quot;.&quot;ID&quot;=&quot;T2&quot;.&quot;T1_ID&quot;)</span><br><span class="line"></span><br><span class="line">PLAN_TABLE_OUTPUT</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">23 rows selected.</span><br></pre></td></tr></table></figure><p>在访问次数上，排序合并连接和HASH连接是一样的，<strong>两表都只会访问0次或者1次</strong>。关于0次的试验这里就不再举例了。<br><strong>排序合并连接根本就没有驱动和被驱动的概念，而嵌套循环和哈希连接要考虑驱动和被驱动情况。</strong></p><p>排序合并连接，也只有在排序时才需要访问表，排序完成后，后续的合并阶段不需要访问表，只需要从排序结果中查找匹配项即可。</p><h3 id="各类连接驱动顺序区别"><a href="#各类连接驱动顺序区别" class="headerlink" title="各类连接驱动顺序区别"></a>各类连接驱动顺序区别</h3><p>观察两表的前后访问顺序对调后的性能差异。</p><h4 id="嵌套循环的表驱动顺序"><a href="#嵌套循环的表驱动顺序" class="headerlink" title="嵌套循环的表驱动顺序"></a>嵌套循环的表驱动顺序</h4><p><code>SELECT /*+leading(t1) use_nl(t1 t2)*/ * FROM t1,t2 WHERE t1.id = t2.t1_id and t1.n = 19;</code> t1 表被访问 1 次，t2 表被访问 1 次。使用 Buffers 989<br><code>SELECT /*+leading(t2) use_nl(t1 t2)*/ * FROM t1,t2 WHERE t1.id = t2.t1_id and t1.n = 19;</code> t1 表被访问 100k 次，t2 表被访问 1 次。使用 Buffers 200k</p><p>在嵌套循环连接中驱动表的顺序非常重要，性能差异十分明显。<br><strong>嵌套循环连接要特别注意驱动表的顺序，小的结果集先访问，大的结果集后访问，才能保证被驱动表的访问次数降到最低，从而提升性能。</strong></p><h4 id="哈希连接的表驱动顺序"><a href="#哈希连接的表驱动顺序" class="headerlink" title="哈希连接的表驱动顺序"></a>哈希连接的表驱动顺序</h4><p><code>SELECT /*+leading(t1) use_hash(t1 t2)*/ * FROM t1,t2 WHERE t1.id = t2.t1_id and t1.n = 19;</code> t1 表被访问 1 次，t2 表被访问 1 次。使用 Buffers 988，Used-Mem 416k ，耗时 0.02s<br><code>SELECT /*+leading(t2) use_hash(t1 t2)*/ * FROM t1,t2 WHERE t1.id = t2.t1_id and t1.n = 19;</code> t1 表被访问 1 次，t2 表被访问 1 次。使用 Buffers 988，Used-Mem 13M ，耗时 0.03s</p><p>其中 Buffers 相同，但 Used-Mem 差异非常大，说明排序尺寸差异明显。时间也可以看出一些<br>哈希连接中驱动表的顺序非常重要，性能也差别明显。</p><h4 id="排序合并的表驱动顺序"><a href="#排序合并的表驱动顺序" class="headerlink" title="排序合并的表驱动顺序"></a>排序合并的表驱动顺序</h4><p><code>SELECT /*+leading(t1) use_merge(t1 t2)*/ * FROM t1,t2 WHERE t1.id = t2.t1_id and t1.n = 19;</code> t1 表被访问 1 次，t2 表被访问 100k 次。使用 Buffers 987，Used-Mem 分别是 2048 和 8677k ，耗时 0.04s<br><code>SELECT /*+leading(t2) use_merge(t2 t1)*/ * FROM t1,t2 WHERE t1.id = t2.t1_id and t1.n = 19;</code> t1 表被访问 1 次，t2 表被访问 100k 次。使用 Buffers 987，Used-Mem 分别是 2048 和 8677k ，耗时 0.05s</p><p><strong>嵌套循环连接和哈希连接有驱动顺序，驱动表的顺序不同将影响表连接的性能，而排序合并连接没有驱动的概念，无论哪张表在前都无妨。</strong></p><h3 id="各类连接排序情况分析"><a href="#各类连接排序情况分析" class="headerlink" title="各类连接排序情况分析"></a>各类连接排序情况分析</h3><h4 id="嵌套循环和哈希连接无需排序"><a href="#嵌套循环和哈希连接无需排序" class="headerlink" title="嵌套循环和哈希连接无需排序"></a>嵌套循环和哈希连接无需排序</h4><p>嵌套循环的执行计划中没有 Used-Mem 信息，说明没有排序。<br>哈希连接也没有排序，虽然执行计划中有 Used-Mem 信息。但消耗的内存是用于建立哈希表的。</p><h4 id="排序只需取部分字段"><a href="#排序只需取部分字段" class="headerlink" title="排序只需取部分字段"></a>排序只需取部分字段</h4><p><code>SELECT /*+leading(t1) use_merge(t1 t2)*/ t1.id FROM t1,t2 WHERE t1.id = t2.t1_id and t1.n = 19;</code><br><code>SELECT /*+leading(t1) use_merge(t1 t2)*/ * FROM t1,t2 WHERE t1.id = t2.t1_id and t1.n = 19;</code></p><p>上面第一条sql只取部分字段，比第二条sql取全部字段所消耗的内存更小。<br>在PGA空间不足以容纳排序区，导致排序需要在磁盘上进行时，那么性能会出现数量级的下降。</p><h3 id="各类连接限制场景对比"><a href="#各类连接限制场景对比" class="headerlink" title="各类连接限制场景对比"></a>各类连接限制场景对比</h3><p>一般来说 HINT 是 Oracle 提供的用来强制走某执行计划的一个工具，比如你不想让 Oracle 的某查询走索引而要走全表扫描，你使用 full() 的提示就可以达成目的，反之亦是如此。<br>但是如果你用 HINT 将导致 Oracle 的运行结果有错，或者是 Oracle 在特定场景下无法支持这个 HINT 的执行计划，那就无法如你所愿。<br>比如之前的 COUNT(*) 的优化，如果你的索引列没有定义为非空属性，无论如何使用 INDEX() 的 HINT ，都不可能让 Oracle 走索引的，因为索引不能存储空值，用索引来统计将得到一个错误的结果，这是无法容忍的，所以 HINT 是无法生效的。<br>同样，这里与表连接相关的三个 HINT 分别是 use_nl、use_hash 和 use_merge ，如果在特定的写法下，用这些 HINT 也无法达成所愿。</p><h4 id="哈希连接的限制"><a href="#哈希连接的限制" class="headerlink" title="哈希连接的限制"></a>哈希连接的限制</h4><p><strong>哈希连接不支持不等值连接<code>&lt;&gt;</code>，不支持<code>&gt;</code>和<code>&lt;</code>的连接方式，也不支持<code>LIKE</code>的连接方式。</strong></p><h4 id="排序合并的限制"><a href="#排序合并的限制" class="headerlink" title="排序合并的限制"></a>排序合并的限制</h4><p><strong>排序合并连接不支持<code>&lt;&gt;</code>的连接条件，也不支持<code>LIKE</code>的连接条件，但是比起哈希连接，支持面要广一些，支持<code>&gt;</code>之类的连接条件。</strong></p><h4 id="嵌套循环无限制"><a href="#嵌套循环无限制" class="headerlink" title="嵌套循环无限制"></a>嵌套循环无限制</h4><p><strong>嵌套循环支持所有的sql连接条件写法，没有任何限制。</strong></p><h3 id="索引与各表连接经典优化"><a href="#索引与各表连接经典优化" class="headerlink" title="索引与各表连接经典优化"></a>索引与各表连接经典优化</h3><h4 id="嵌套循环与索引"><a href="#嵌套循环与索引" class="headerlink" title="嵌套循环与索引"></a>嵌套循环与索引</h4><p>嵌套索引的原理前面有写过，先从驱动表过滤出符合条件的记录，再去被驱动表匹配符合条件的记录，最后将结果组合在一起返回。<br>从两个表中匹配数据的过程可以使用索引提高性能，在过滤条件或连接条件有索引时，可以大大提高查询效率。<br>一般在驱动表的过滤条件加索引、在被驱动表的连接条件加索引比较合理。</p><p>适合嵌套循环连接的场景</p><ol><li>两表关联返回的记录不多，最佳情况是驱动表结果集仅返回1条或少量几条记录，而被驱动表仅匹配到1条或少量几条记录，这种情况即便T1表和T2表的记录奇大无比，也是非常迅速的。</li><li>遇到一些不等值查询导致哈希和排序合并连接被限制使用，不得不使用L连接。</li><li>驱动表的限制条件所在的列有索引。</li><li>被驱动表的连接条件所在的列有索引。</li></ol><h4 id="哈希连接与索引"><a href="#哈希连接与索引" class="headerlink" title="哈希连接与索引"></a>哈希连接与索引</h4><p>哈希连接、排序合并连接和嵌套循环连接最大的差别在于，连接条件的索引对它们起不到<strong>传递</strong>的作用。<br>对于哈希连接和排序合并连接来说，索引的连接条件起不到快速检索的作用，但是限制条件列如果有适合的索引可以快速检索到少量记录，还是可以提升性能的。<br><strong>因此关于哈希连接与索引的关系可以理解为单表索引的设置技巧</strong>，这在之前的索引章节中己经详细叙说过了。</p><p>此外两表关联等值查询，在没有任何索引的情况下，Oracle 倾向于走哈希连接这种算法，因为哈希连接的算法本身还是比较高效先进的。<br>哈希连接需要在 PGA 中的HASH AREA SIZE中完成，因此增大HASH AREA SIZE也是优化哈希连接的一种有效的途径，一般在内存自动管理的情况下，只要加大PGA区大小即可。</p><h4 id="排序合并与索引"><a href="#排序合并与索引" class="headerlink" title="排序合并与索引"></a>排序合并与索引</h4><p><strong>排序合并连接上的连接条件虽然没有检索的作用，却有消除排序的作用。</strong><br>索引本身排序，可以有效地避免排序合并连接中的排序。<br>此外，还有一个和哈希连接类似的优化思路，就是增大内存排序区，避免在排序尺寸过大时在磁盘中排序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第六章-经典，表的连接学以致用&quot;&gt;&lt;a href=&quot;#第六章-经典，表的连接学以致用&quot; class=&quot;headerlink&quot; title=&quot;第六章 - 经典，表的连接学以致用&quot;&gt;&lt;/a&gt;第六章 - 经典，表的连接学以致用&lt;/h2&gt;&lt;h3 id=&quot;三种连接类型&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://cooooing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据库" scheme="https://cooooing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="《收获，不止Oracle》" scheme="https://cooooing.github.io/tags/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B/"/>
    
    <category term="Oracle" scheme="https://cooooing.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>言叶之庭</title>
    <link href="https://cooooing.github.io/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/"/>
    <id>https://cooooing.github.io/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/</id>
    <published>2024-08-25T11:46:47.000Z</published>
    <updated>2024-08-25T11:46:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>片尾曲 Rain （好像很久之前听过，片尾曲出来的时候就有感觉了）<br><meting-js    server="netease"    type="song"    id="1950516520"><br></meting-js></p><p>片中引用的出自万叶集的短诗：</p><p>原文：<br>鸣神の　少しとよみて　さし昙り　雨も降らんか　君を留めん<br>鸣神の　少しとよみて　降らずとも　我は止まらん　妹し留めば</p><p>译文：<br>隐约雷鸣，阴霾天空，但盼风雨来，能留你在此。<br>隐约雷鸣，阴霾天空，即使天无雨，我亦留此地。</p><p>很喜欢新海诚的画风，食物以及最后的片尾。（不知不觉看到片尾才意识到结束了，原来只有四十几分钟。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/1.jpg"                                        ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/2.jpg"                                        ></p><p>最后，不可多得的好动画。<br>云之彼端，约定的地方 和 追逐星星的孩子 挺久之前也都看过了。<br>越来越好了，片中歌曲也是。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;片尾曲 Rain （好像很久之前听过，片尾曲出来的时候就有感觉了）&lt;br&gt;&lt;meting-js
    server=&quot;netease&quot;
    type=&quot;song&quot;
    id=&quot;1950516520&quot;&gt;&lt;br&gt;&lt;/meting-js&gt;&lt;/p&gt;
&lt;p&gt;片中引用的出自万</summary>
      
    
    
    
    <category term="记录生活" scheme="https://cooooing.github.io/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="电影" scheme="https://cooooing.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
    <category term="新海诚" scheme="https://cooooing.github.io/tags/%E6%96%B0%E6%B5%B7%E8%AF%9A/"/>
    
  </entry>
  
  <entry>
    <title>《收获，不止Oracle》读书笔记上篇-索引</title>
    <link href="https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E7%B4%A2%E5%BC%95/"/>
    <id>https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E7%B4%A2%E5%BC%95/</id>
    <published>2024-08-02T10:05:52.000Z</published>
    <updated>2024-08-02T10:05:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五章-惊叹，索引天地妙不可言"><a href="#第五章-惊叹，索引天地妙不可言" class="headerlink" title="第五章 - 惊叹，索引天地妙不可言"></a>第五章 - 惊叹，索引天地妙不可言</h2><h3 id="BTREE-索引"><a href="#BTREE-索引" class="headerlink" title="BTREE 索引"></a>BTREE 索引</h3><h4 id="BTREE-索引结构图"><a href="#BTREE-索引结构图" class="headerlink" title="BTREE 索引结构图"></a>BTREE 索引结构图</h4><p>索引和表一样，都是前面描述的逻辑体系结构中的段的一种，当建一个T表，就产生一个T表的表SEGMENT，当在T表的某些列上建索引DXT，就产生一个DXT的索引SEGMENT。<br>索引是建在表的具体列上，其存在的目的是让表的查询更快，效率更高。表记录丢失关乎生死，而索引丢失只需重建即可，似乎听起来索引只是表的一个附属产品，可有可无。<br>但索引却是数据库学习中最实用的技术之一。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%9B%BE.png"                        alt="索引结构图.png"                 ></p><p>以上结构图说明索引是由Root(根块)，Branch(茎块)和Leaf(叶子块)三部分组成的。<br><strong>其中Leaf(叶子块)主要存储了key column value(索引列具体值)，以及能具体定位到数据块所在位置的rowid(注意区分索引块和数据块)。</strong><br>比如：<code>select * from t where id = 12;</code> 该test表的记录有10050条，而id&#x3D;12仅返回1条，test表的id列建了一个索引，索引是如何快速检索到数据的呢，接下来分析这个索引查询示例图</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E7%A4%BA%E4%BE%8B%E5%9B%BE.png"                        alt="索引结构图.png"                 ></p><p>通过分析该图片，可以大致理解，定位到<code>select * from t where id = 12;</code>大致只需要3个IO(此处只是举个例子，1万多条记录实际情况可能只需要2个IO,这个和索引的高度有关，后续会深入讨论)。<br>首先查询定位到索引的根部，这里是第1次IO<br>接下来根据根块的数据分布，定位到索引的茎部（查询到12的值的大致范围，11..19的部分），这是第2次IO<br>然后定位到叶子块，找到 id&#x3D;12 的部分，此处为第3次IO。<br>假设Oracle在全表扫描记录，遍历所有的数据块，IO的数量必然将大大超过3次。有了这个索引，Oracle只会去扫描部分索引块，而非全部，少做事，必然能大大提升性能。</p><p>根据id列上的索引来查询数据只需要访问索引块，不需要访问数据块吗？<br>显然不是的，这里的语句是<code>select * from t where id=12</code>，这个*表示要展现t表的所有字段，显然只访问索引是不可能包含表的所有字段的，因为该索引只是对id列建索引，也就存储了id列的信息而已。<br>因此上述查询访问完索引块后，必然要再访问数据块，比较快捷的方法是用索引块存储的rowid来快速检索数据块（具体在后续章节会描述）<br>所以3次IO显然是不对的，理应增加一次从索引块到数据块获取各个列信息的检索动作，至少是4次IO才对。</p><p>什么情况下查询可以只访问索引而不访问表呢？<br>如果查询只检索索引列信息，就可以不访问表了，比如查询改成 <code>select id from t where id=12</code> 时就是这种情况。</p><h4 id="建立索引的步骤"><a href="#建立索引的步骤" class="headerlink" title="建立索引的步骤"></a>建立索引的步骤</h4><p>有一张test表，该表有大致name(varchar22(20),id(number),height(number),age(number)等字段。<br>当前该表有记录，我们要对test表的id列建索引，<code>create index idx id on test(id);</code></p><h5 id="要建索引先排序"><a href="#要建索引先排序" class="headerlink" title="要建索引先排序"></a>要建索引先排序</h5><p>未建索引的test表大致记录如下图所示，NULL表示该字段为空值，此外省略号表示略去不显示内容。注意rowid伪列，这个是每一行的唯一标记，每一行的rowid值绝对不重复，可定位到行的记录在数据库中的位置（具体在后续的章节中详细介绍)。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E7%B4%A2%E5%BC%95/%E6%9C%AA%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84test%E8%A1%A8.png"                        alt="未建索引的test表.png"                 ></p><p>建索引后，先从test表的id列的值顺序取出数据放在内存中（这里需注意，除了id列的值外，还要注意到取该列的值的同时，该行的rowid也被一并取出)，如下图所示。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E7%B4%A2%E5%BC%95/%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%AD%A5%E9%AA%A4%E4%B8%80.png"                        alt="建索引步骤一.png"                 ></p><h5 id="列值入块成索引"><a href="#列值入块成索引" class="headerlink" title="列值入块成索引"></a>列值入块成索引</h5><p>依次将内存中的顺序存放的列的值和对应的rowid存进Oracle空闲的BLOCK中，形成了索引块。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E7%B4%A2%E5%BC%95/%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%AD%A5%E9%AA%A4%E4%BA%8C.png"                        alt="建索引步骤二.png"                 ></p><h5 id="填满一块接一块"><a href="#填满一块接一块" class="headerlink" title="填满一块接一块"></a>填满一块接一块</h5><p>随着索引列的值的不断插入，index block1(L1)很快就被插满了，比如接下来取出的id&#x3D;9的记录无法插入index block1L1)中，就只有插入到新的Oracle块中，index block2(L2)。<br>与此同时，发生了一件非常重要的事情，就是新写数据到另一个块index block3(B1)，这是为啥呢？<br>原来L1和L2平起平坐，谁都不服谁，打起来了，不得了了，无组织无纪律哪能行，赶紧得有人管啊，于是index block3(B1)就担负起管理的角色，这个BLOCK记录了L1和L2的信息，并不记录具体的索引列的键值，目前只占用了B1一点点空间。<br>L3用于管理L2和L2的信息，用于快速定位。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E7%B4%A2%E5%BC%95/%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%AD%A5%E9%AA%A4%E4%B8%89.png"                        alt="建索引步骤三.png"                 ></p><h5 id="同级两块需人管"><a href="#同级两块需人管" class="headerlink" title="同级两块需人管"></a>同级两块需人管</h5><p>随着叶子块的不断增加，B1块中虽然仅是存放叶子块的标记，但也挡不住量大，最终也容纳不下了。<br>怎么办？接着装呗，到下一个块B2块去寻找空间容纳。这时B1和B2也平起平坐了。<br>这时又需要另一个块来记录B1、B2的信息，最上层的oot根块诞生了。<br>后续还会出现B3、B4…如果有一天，这些Bn把root块撑满了，root块就不是root块了，他的上面就又有别的块来记录它的信息。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E7%B4%A2%E5%BC%95/%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%AD%A5%E9%AA%A4%E5%9B%9B.png"                        alt="建索引步骤四.png"                 ></p><h4 id="索引结构的三大重要特点"><a href="#索引结构的三大重要特点" class="headerlink" title="索引结构的三大重要特点"></a>索引结构的三大重要特点</h4><h5 id="索引高度较低"><a href="#索引高度较低" class="headerlink" title="索引高度较低"></a>索引高度较低</h5><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E4%BB%8E%E4%B8%8B%E5%BE%80%E4%B8%8A%E7%9C%8B.png"                        alt="索引从下往上看.png"                 ></p><p>从下往上看，这个索引树的高度不会很高<br>最底层的叶子块index block因为装具体的数据，所以比较容易被填满，特别是对长度很长的列建索引时更是如此。<br>但是第1层之上的第2层的index block就很不容易装满了吧，因为第2层只是装第1层的指针而已，而第3层是装第2层的index block的指针，更不容易了…<br>因此，这个树如果有很多层，那么表的数据量应该非常大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- 查询占用表空间最大的表（排序）</span><br><span class="line">select t.owner,t.segment_name,t.tablespace_name,bytes/1024/1024/1024 as sizes,q.num_rows,t.segment_type</span><br><span class="line">from dba_segments t</span><br><span class="line">         left join dba_tables q</span><br><span class="line">                   on t.segment_name=q.table_name</span><br><span class="line">                       and t.owner=q.owner</span><br><span class="line">where t.segment_type=&#x27;TABLE&#x27;</span><br><span class="line">  and t.tablespace_name=&#x27;TBS_FCCENTER_DATA&#x27;  --需要查看的表空间</span><br><span class="line">order by 4 desc</span><br><span class="line">-- 查询表索引的高度</span><br><span class="line">select index_name,</span><br><span class="line">       blevel,</span><br><span class="line">       leaf_blocks,</span><br><span class="line">       num_rows,</span><br><span class="line">       distinct_keys,</span><br><span class="line">       clustering_factor</span><br><span class="line">from user_ind_statistics</span><br><span class="line">where table_name in( &#x27;T&#x27;)</span><br><span class="line">order by blevel desc;</span><br></pre></td></tr></table></figure><p>看了下测试环境最大的一张表28G大小，快六百万数据，某列索引才4层。<br>书中说有500G一张，记录有几百亿条，但是该表上某列索引的高度才不过6层而已。</p><blockquote><p>BLEVEL&#x3D;0这个层面表示只有叶子块，第1个索引块还没有装满，无须填入第2个块，所以没有上层块来管理，是1层高。<br>而BLEVEL&#x3D;1这个层面表示这个阶段已经到第2层了，同理，BLEVEL&#x3D;2表示已经到第3层，只是还没有将其填满。</p></blockquote><h5 id="索引存储列值"><a href="#索引存储列值" class="headerlink" title="索引存储列值"></a>索引存储列值</h5><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E4%BB%94%E7%BB%86%E8%A7%82%E5%AF%9F%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9.png"                        alt="索引仔细观察叶子节点.png"                 ></p><p>索引存储了表的索引所在列的具体信息，还包含了标记定位行数据在数据库中位置的rowid取值。</p><h5 id="索引本身有序"><a href="#索引本身有序" class="headerlink" title="索引本身有序"></a>索引本身有序</h5><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E4%BB%8E%E5%B7%A6%E5%90%91%E5%8F%B3%E7%9C%8B.png"                        alt="索引从左向右看.png"                 ></p><p>索引是顺序从表里取出数据，再顺序插入到块里形成索引块的，所以说索引块是有序的。</p><h4 id="索引高度较低的用处"><a href="#索引高度较低的用处" class="headerlink" title="索引高度较低的用处"></a>索引高度较低的用处</h4><p>这里实验省略，语言描述。<br>对于同样高度索引树的表进行查询，如果返回记录是1条。那么走索引查询的效率是差不多的。<br>因为索引高度一样，所以产生的IO次数一样。</p><p>而在没有索引的情况下，查询则会全表扫描，数据量大的话，会十分缓慢。<br>索引的这个高度不高的特性给查询带来了巨大的便捷，<strong>但这里的查询只返回1条记录，如果查询返回绝大部分的数据，那用索引反而要慢得多。</strong><br>因为通过索引查到一条数据需要多次IO，取决于索引树的高度。通过索引查表的全量数据的话，需要的IO次数是全表扫描的数倍。<br>同时，全表扫描可以对块进行多块读，进一步提高速度。</p><p>表字段数量也会影响查询的效率。<br><strong>如果表字段很少，同一个块中所能存放的数据也就越多，全表扫描的逻辑读也不会太多。所以会快。</strong><br><strong>相反，如果表字段很多，同一个块中存放的数据就会越少，全表扫描所需遍历的数据块也会增加，速度也就满下来了。</strong></p><hr><p>下面是分区索引的设计误区。<br>分区表的系分为两中，一种是局部索引，一种是全局索引。<br>局部索引等同于为每个分区段建分区的索引，从user_segment的数据字典中，可以观察到表有多少个分区，就有多少个分区索引的segment。段的类型为 TABLE PARTITION。每个分区索引也是一个段，每个段的类型为 INDEX PARTITION。<br>而全局索引，也就是普通索引。仅有一个段，段的类型为 INDEX。</p><p>针对分区表的查询逻辑读相比于针对普通表的逻辑读会多好几倍，COST也一样。<br>因为分区表的索引等同于查询了多个小索引，而小索引虽然体积比整个大索引小很多，但是高度却相差无几。<br>这就导致单个小索引的查询和全局大索引的查询的IO数量差不多，而分区索引的IO个数还要乘以分区个数，所产生的IO会远大于全局索引产生的IO。<br>所以分区索引的性能会低。</p><p>因此分区表索引的设计是有讲究的，如果设置了分区索引，但是却用不到分区条件，性能将继续下降。<br>如果建了分区索引，但是又根本无法加上分区字段的条件，那建议不要建分区索引。<br>但如果查询中使用了分区字段的条件，那么结果就不一样了。只需要遍历其中的几个分区即可，效率也大幅提升。</p><h4 id="索引存储列值的用处"><a href="#索引存储列值的用处" class="headerlink" title="索引存储列值的用处"></a>索引存储列值的用处</h4><h5 id="count-优化"><a href="#count-优化" class="headerlink" title="count(*) 优化"></a>count(*) 优化</h5><p>下面介绍索引存储列值及rowid的特性，其实身边最常见的语句性能的提升却往往是基于对这个特点的认识。</p><p><code>select count(*) from t;</code> 是否能用到索引？</p><p>表的情况和索引情况的差别在于表是把整行的记录依次放进BLOCK形成DATA BLOCK，而索引是把所在列的记录排序后依次放进BLOCK里形成INDEX BLOCK。既然在没有索引的情况下，DATA BLOCK中可以统计出表记录数，那INDEX BLOCK肯定也可以。<br>方法就是前者汇总各个DATA BLOCK中的行的插入记录数，后者汇总各个INDEX BLOCK中的索引列的插入记录数。<br>最关键的是，INDEX BLOCK里存放的值是表的特定的索引列，一列或者就几列，所需容纳空间要比存放整行也就是所有列的DATA BLOCK要少得多，所以这个查询用索引会很高效。</p><p>但Oracle并不会选择走索引，而是选择了全表扫描。<del>（实验略</del><br>主要原因是<strong>索引不能存储空记录</strong>，这样如果表的索引列有空的记录，那依据索引来统计表的记录数肯定是不对的，所以Oracle才会选择全表扫描的执行计划。<br>改变一下写法，<code>select count(*) from t where id is not null;</code>便可以让Oracle选择走索引。</p><blockquote><p><strong>将索引列设为非空</strong>、或者设为主键（主键是非空的），也可以解决这个问题。</p></blockquote><p>什么时候在表的非空列建有索引时，COUNT(*)语句用索引效率不如全表扫描？<br>如果一张表仅有一个字段，这个索引比表还大（多了rowid)，那从索引中查询，效率会不如全表扫描。</p><p>什么时候COUNT(*)查询语句用索引扫描比全表扫描高效很多呢？<br>表的字段很多，并且字段长度大多都很长，其中有一个非空且长度很短的列建了一个索引，这时索引的体积相对表来说特别小，那索引读效率就高多了。</p><h5 id="SUM-AVG-优化"><a href="#SUM-AVG-优化" class="headerlink" title="SUM&#x2F;AVG 优化"></a>SUM&#x2F;AVG 优化</h5><p><code>select sum(id) from t;</code> 是否能用到索引？<br>是不能的，原因和上面一样，空值的问题。</p><p><code>select sum(id), avg(id), count(id) from t where id is not null;</code>只需要一次索引扫描即可完成。</p><p>因为一次扫描索引块，可以同时解决三个问题，所以效率与单个分别执行时一样高。<br>不过列有空值理应不影响在索引中进行SUM和AVG等运算的，这里未指明非空则无法用到索引，其实是不应该的，这是优化器的缺陷。<del>不知道新版本有没有优化</del></p><h5 id="MAX-MIN-优化"><a href="#MAX-MIN-优化" class="headerlink" title="MAX&#x2F;MIN 优化"></a>MAX&#x2F;MIN 优化</h5><p><code>select max(id) from t;</code> 是否能用到索引？<br>是可以的。<br>这个列的属性是否为空不应该影响能否使用索引作为‘瘦表’查询，但是奇怪的是MAX&#x2F;MIN时无论列是否为空都可以用到索引，而SUM&#x2F;AVG等聚合查询却必须要列为空方可用到索引。<br>其实此类语句在运算时有无加上<code>is not null</code>的取值都是等价查询的，而COUNT(*)则不一样，有无<code>is not null</code>的取值可是不等价的！<br><del>所以大概是优化器的问题</del></p><p>执行计划中走索引的查询方式，索引的扫描方式会有很多种。这里先解释 <code>INDEX FULL SCAN(MIN/MAX)</code><br>这个<code>INDEX FULL SCAN (MIN/MAX)</code>只需要个位数的逻辑读就完成查询的秘密在于，MAX取值只需要往最右边的叶子块看一下，MAX的取值一定在最右边的块上，块里的最后一行就是。<br>而MIN取值，仅往最左边的块里去望一望即可了，最小值一定在里头，块里的第一行记录就是。<br>其中既包含了索引可以存储空值的技巧，又结合了索引是有序的技巧。<br>查询只与索引树的高度有关，无论记录如何增大，查询效率都不会太低。</p><p>但是，<code>select min(id), max(id) from t;</code>就变成全表扫描了。是null值的问题吗？<br><code>select min(id), max(id) from t where id is not null;</code> 走索引了，但走的是 <code>INDEX FAST FULL SCAN</code>并不是<code>INDEX FULL SCAN (MIN/MAX)</code>。<br>改写成 <code>select max, min from(select max(object_id)max from t) a, (select min(object_id)min from t) b;</code> 就可以走<code>INDEX FULL SCAN (MIN/MAX)</code>了。虽然这种写法很奇怪。 </p><h5 id="索引回表与优化"><a href="#索引回表与优化" class="headerlink" title="索引回表与优化"></a>索引回表与优化</h5><p>索引回表读(TABLE ACCESS BY INDEX ROWID)<br>它表示通过索引访问表中的数据行。当执行计划中出现这种操作时，意味着Oracle使用索引找到特定行的ROWID（行标识符），然后使用这个ROWID直接访问表中的行。</p><p>从索引中可以读到索引列的信息，但是不可能读到该列以外的其他列的信息.<br>当查询是<code>select * from t where object_id &lt;= 5</code>时，这个*表示该表所有字段都需要返回。<br>因此必然是在扫描索引块中定位到具体object_id&lt;&#x3D;5这部分索引块后，再根据这部分索引块的rowid定位到t表所在的数据块，然后从数据块中获取到其他字段的记录。</p><p><strong>所以只返回需要的字段，而不是使用*。有时可以避免回表读，以提高性能。</strong></p><p>关于TABLE ACCESS BY INDEX ROWID最佳的优化方式是，如果业务允许，可以巧妙地消除这个动作的产生，但是如果存在有些非索引的字段必须展现，可是又不多的情况，该如何优化呢？<br>前面在业务允许的情况下，可以将<code>select * from t where object_id &lt;= 5</code>修正为<code>select object_id from t where object_id&lt;=5</code>从而消除回表，提升性能，假如有些字段必须展现，但又不多，该怎么办呢？<br>比如<code>select object_id,object_name from t where object_id &lt;= 5</code>这个写法，非得展现object_name。<br>可以考虑在object_id和object_name列建组合索引，即可消除回表动作。</p><blockquote><p>联合索引（Composite Index 或 Compound Index）是在多个列上创建的索引。它允许根据多个列的组合来对数据进行排序和快速访问。联合索引在Oracle数据库中非常常见，因为它们可以用于多种查询条件，从而提高查询效率。<br>联合索引基于多个列的组合来构建索引树。当创建联合索引时，Oracle会根据索引定义中列的顺序来生成键值。键值由索引定义中的所有列组成，按照定义的顺序进行排序。<br>联合索引的列顺序很重要。Oracle将按照列定义的顺序来构建键值。通常，将查询中最常用的列放在前面可以提高索引的利用率。</p></blockquote><p>建联合索引后，回表的动作TABLE ACCESS BY INDEX ROWID在执行计划中就没有了。<br>不过这里要注意平衡，·如果联合索引的联合列太多，必然导致索引过大，虽然消减了回表动作，但是索引块变多，在索引中的查询可能就要遍历更多的BLOCK了，所以要全面考虑，联合索引不宜列过多，一般超过3个字段组成的联合索引都是不合适的。</p><p>实际上，回表查询的速度也是有差异的，这里引出一个重要概念叫聚合因子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- 建立无序的表</span><br><span class="line">drop table t_colocated purge;</span><br><span class="line">create table t_colocated (id number,col2 varchar2(100));</span><br><span class="line">begin</span><br><span class="line">    for i in 1..100000</span><br><span class="line">        loop</span><br><span class="line">            insert into t_colocated(id,col2)</span><br><span class="line">            values (i,rpad(dbms_random.random,95,&#x27;*&#x27;));</span><br><span class="line">    end loop;</span><br><span class="line">end;</span><br><span class="line">alter table t_colocated add constraint pk_t_colocated primary key(id);</span><br><span class="line">-- </span><br><span class="line">-- 建立有序的表</span><br><span class="line">drop table t_disorganized purge;</span><br><span class="line">create table t_disorganized as select id,col2 from t_colocated order by col2;</span><br><span class="line">alter table t_disorganized add constraint pk_t_disorg primary key (id);</span><br></pre></td></tr></table></figure><p>两张表中，id一个是按顺序插入的，一个是乱序的。而我们都知道，索引是有排列的，此时id列上的索引存放的数据也是有序的。<br>表和索引两者的排列顺序相似度很高，就称之为聚合因子比较低。<br>表和索引两者之间的排列顺序相似度差异明显，就称之为聚合因子比较高。</p><p>通过数据字典来判断索引的聚合因子情况</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select index_name,blevel,leaf_blocks,num_rows,distinct_keys,clustering_factor from user_ind_statistics where table_name in(&#x27;T_COLOCATED&#x27;,&#x27;T_DISORGANIZED&#x27;);</span><br><span class="line"></span><br><span class="line">INDEX_NAME                                                                                                                           BLEVEL LEAF_BLOCKS   NUM_ROWS DISTINCT_KEYS CLUSTERING_FACTOR</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------- ---------- ----------- ---------- ------------- -----------------</span><br><span class="line">PK_T_COLOCATED                                                                                                                            1         208     100000        100000              1469</span><br><span class="line">PK_T_DISORG                                                                                                                               1         208     100000        100000             99940</span><br></pre></td></tr></table></figure><p>这里说明一下CLUSTERING_FACTOR的官方解释：表明有多少临近的索引条目指到不同的数据块。<br>取值99944接近表记录的100000，说明绝大部分的临近索引条目都指向了不同的数据块。<br>取值为1469说明总共只有1469个临近的索引条目指到了不同的数据块，总体还算不错。</p><p>表的插入顺序和索引列的顺序基本一致，从索引中回表查找数据块将会更容易查找，其实通俗地说就是索引块A里装10行列信息及ROWID,这就可以理解为索引条目。<br>然后根据索引条目的ROWID找到表记录时，如果聚合因子很小，10行索引条目可以全部在数据块B块中完整地找到。<br>如果聚合因子很大，或许这10行索引条目对应的数据块的10行记录，分布在10个不同的数据块里。那就要访问了C块，D块，E块等等，回表查询的性能当然就低了。</p><p>所以，当某列的读取频率远高于其他列，那就保证表的排列顺序和这列一致，按照这列的顺序，重组一下表记录来优化即可了。</p><h4 id="索引有序的用处"><a href="#索引有序的用处" class="headerlink" title="索引有序的用处"></a>索引有序的用处</h4><h5 id="order-by-排序优化"><a href="#order-by-排序优化" class="headerlink" title="order by 排序优化"></a>order by 排序优化</h5><p>真正决定性能的是COST的高低和真实完成的时间，一般COST越小性能越高，Oracle执行计划的选择就是由COST来决定的。<br>而时间也是非常简单的衡量的方式，完成时间越短性能越高。<br>而逻辑读方面，是作为参考，在绝大部分情况下（甚至可以说90%以上的场合），逻辑读越少性能越快，但在这里却不适用了。<br>排序算法有些特别，内部的机制导致性能和逻辑读关系不是太大，主要是消耗在CPU性能上，开销极大。<br>此外如果PGA区无法容纳下排序的尺寸而进入磁盘排序，那将成为更大的性能杀手。</p><p><strong>因为索引是有序的，所以排序的查询走索引的话，可以减少排序次数，从而提高性能。</strong></p><h5 id="distinct-排重优化"><a href="#distinct-排重优化" class="headerlink" title="distinct 排重优化"></a>distinct 排重优化</h5><p>distinct 这个常见的排除重复数据的写法，会用到排序。排过序的数据更容易去重。</p><p>从含有distinct的查询语句执行计划中，可以发现以及排序次数是0。<br>但TempSpe却是有值的。TempSpc是临时表空间。<br>实际上，DISTINCT是有排序的，只是在 AUTOTRACE 的 SORTS 关键字中不会显现而已。</p><p>DISTINCT 会因为排序而影响性能，不过这里要注意一点，DISTINCT采用的是HASH UNIQUE的算法。<br>其实如果语句修改为<code>select distinct object id_from t where object_id=2</code>这样的等值查询而非范围查询时，将产生<code>SORT UNIQUE NOSORT</code>的算法。</p><p>含有 distinct 的查询语句，走索引查询时，是可以消除其所产生的排序的。<br>不过现实中，DISTINCT语句靠索引来优化往往收效是不明显的，因为大多数情况用到DISTINCT都是因为表记录有重复，因此首要的是要考虑为什么重复。</p><h5 id="索引全扫与快速扫描"><a href="#索引全扫与快速扫描" class="headerlink" title="索引全扫与快速扫描"></a>索引全扫与快速扫描</h5><p><code>INDEX FULL SCAN (MIN/MAX)</code>，是针对最大最小取值的一种特别的索引扫描方式。<br><code>INDEX RANGE SCAN</code>，是一种针对索引高度较低这个特性实现的一种范围扫描，在返回记录很少时相当高效。</p><p><code>INDEX FULL SCAN</code>和<code>INDEX FAST FULL SCAN</code>的相同点，都是针对整个索引的全扫描，从头到尾遍历索引，而非局部的INDEX FULL SCAN(MIN&#x2F;MAX)和INDEX RANGE SCAN。<br>INDEX FAST FULL SCAN比INDEX FULL SCAN多了一个FAST，所以差别就是索引快速全扫描INDEX FAST FULL SCAN比索引全扫描INDEX FULL SCAN更快。<del>好像是废话</del><br>那么为什么INDEX FAST FULL SCAN会比INDEX FULL SCAN更快，<strong>是因为索引快速全扫描一次读取多个索引块，而索引全扫一次只读取一个块</strong>。<br>一次读取多个块不容易保证有序，而一次读取一个块可以保证有序，因此在有排序的场合，INDEX FULL SCAN的顺序读可以让排序消除，而INDEX FAST FULL SCAN虽然减少了逻辑读，但是排序这个动作却无法消除。</p><p>所以说COUNT(*)和SUM之类的统计根本无须使用排序，一般都走INDEX FAST FULL SCAN，而涉及排序语句时，就要开始权衡利弊，也许使用INDEX FAST FULL SCAN更快，也许使用INDEX FULL SCAN更快，由Oracle的优化器计算出成本来选择。</p><h5 id="UNION-合并的优化"><a href="#UNION-合并的优化" class="headerlink" title="UNION 合并的优化"></a>UNION 合并的优化</h5><p><strong>UNION 合并后没有重复数据，和 DISTINCT 类似，是有排序操作的。</strong><br><strong>UNION ALL 合并后有重复数据，只是简单的合并，不会有排序操作。</strong></p><p>但是这里的 union 是不能利用索引消除排序的。这是因为 union 操作的是两个不同的结果集的筛选，各自的索引当然没法生效。<br>在某些业务场景下，两个 union 的表数据不可能出现重复时，使用 union all 而不使用 union，会提高查询效率。</p><h4 id="主外键设计"><a href="#主外键设计" class="headerlink" title="主外键设计"></a>主外键设计</h4><p>主外键有三大特点：</p><ol><li>主键本身是一种索引</li><li>可以保证表中主键所在列的唯一性</li><li>可以有效地限制外键依赖的表的记录的完整性。</li></ol><p>其中前两个特点和<code>CREATE UNIQUE INDEX</code>建立的唯一性索引基本相同。</p><p>外键建索引后，效率会更高，这和表连接的NESTED LOOPS连接方式有关，在后续表连接章节细说。</p><p><strong>在外键上建索引，还能有效避免锁的竞争。</strong></p><p>主外键最基本的一个功能：<strong>外键所在表的外键列取值必须在主表中的主键列有记录。</strong><br>否则会报错：<code>ORA-02292 integrity constraint (string.string) violated - child record found</code><br>Oracle提供的这些功能保证了多表记录之间记录的制约性。</p><p>同样，如果子表中有记录，要删除主表中对应的主键记录，也会报错：<code>ORA-02292 integrity constraint (string.string) violated - child record found</code><br>级联删除的设置：<code>ALTER TABLE t_c ADD CONSTRAINT fk_t_c_id FOREIGN KEY (t_id) REFERENCES t (id) ON DELETE CASCADE;</code>。添加 ON DELETE CASCADE 关键字。<br><strong>设置级联删除后，删除主表的记录后，会自动将子表中对应的记录一起删除。慎用。</strong></p><p>如果有一张表的某字段没有重复记录，并且只有一个普通索引，该如何改造为主键？<br>因为建主键的动作其实就是建了一个唯一性索引，再增加一个约束。<br>所以 <code>alter table t add constraint t_id_pk primary key(ID);</code> 即可。</p><h4 id="组合索引设计"><a href="#组合索引设计" class="headerlink" title="组合索引设计"></a>组合索引设计</h4><p><strong>当查询的列在索引或组合索引中时，可以避免回表。</strong><br>回表在执行计划中叫 <code>TABLE ACCESS BY INDEX ROWID</code></p><p><strong>当组合列返回的记录比较少时，组合索引的效率会比较高。</strong><br>类似 <code>select * from t where a = 1 and b = 2</code> 这种情况，如果在a和b字段建联合索引是不可能消除回表的，因为返回的是所有字段。<br>但是只要 a&#x3D;1 返回较多， b&#x3D;2 返回也较多，组合起来返回很少，就适合建联合索引。<br>但过多的字段建联合索引往往是不可取的，因为这样会导致索引过大，不仅影响了定位数据，更严重影响了更新性能，一般不超过三个字段。</p><p>如果 a &#x3D; 1 and b &#x3D; 2 的返回和前面的单独 a &#x3D; 1 或者单独 b &#x3D; 2 的返回记录数差别不大，那组合索引的快速检索就失去意义了，单独建某列索引更好，因为单独建立的索引体积比组合索引要小，检索的索引块也更少。<br>但如果不是返回所有的列，就是回表的范畴了。组合索引可能更合适。</p><hr><p><strong>在等值查询的情况下，组合索引的列无论哪列在前，性能都一样。</strong><br>组合索引在第一字段进行排序，值相同的情况下，对第二个字段进行排序。<br>等值查询时，组合索引无论哪个在前都是一样的。查询到第一个条件的值后，查询第二个条件的值，因为是确定的值，同时索引是有序的，所以条件的顺序不影响查询效率。</p><p><strong>组合索引的两列，当一列是范围查询，一列是等值查询的情况下，等值查询列在前，范围查询列在后，这样的索引最高效。</strong><br>但范围查询不同，范围条件在前时，需要逐个去查符合范围条件的第二个等值条件，它在每个符合范围的值中都是有序的（每个部分都是有序的）<br>而等值条件在前时，去查询符合等值条件的第二个范围条件，则要更简单。因为它整体是有序的。所以查询效率也更高。</p><p><strong>范围查询改写为in查询，in查询的效率更高。因为in可以看作多个等值查询，定位到记录后可以停止继续搜索。</strong></p><p><strong>如果单列的查询列和联合索引的前置列一样，那单列可以不建索引，直接利用联合索引来进行检索数据。</strong></p><p>如果单列的取值不多，可能会用到索引，这种扫描被称为跳跃索引，不过应用场景不多。<br>跳跃索引（Index Skip Scan）是Oracle数据库中的一种特殊的索引访问方式，用于处理包含空值（NULL）的多列索引。跳跃索引可以提高查询性能，尤其是在索引列中存在大量空值的情况下。<br>跳跃索引的工作原理是让Oracle能够跳过那些不包含有效键值的节点，直接访问包含有效键值的节点。这样可以减少不必要的索引扫描，提高查询性能。</p><hr><p>不过索引也不是越多越好，虽然可以增加查询效率，减少查询的时间。但会影响更新效率，因为索引的维护需要时间。<br>特别是大量的无序插入，在索引很多的情况下会十分的慢。<br><strong>可以先将索引失效，插入完成后重建索引。可以提升性能。</strong></p><ol><li>对INSERT语句负面影响最大，有百害而无一利，只要有索引，插入就慢，越多越慢！</li><li>对DELETE语句来说，有好有坏，在海量数据库定位删除少数记录时，这个条件列是索引列显然是必要的，但是过多列有索引还是会影响明显，因为其他列的索引也要因此被更新。在经常要删除大量记录的时候，危害加剧！</li><li>对UPDATE语句的负面影响最小，快速定位少量记录并更新的场景和DELETE类似，但是具体修改某列时却有差别，不会触及其他索引列的维护。</li></ol><hr><p>除了索引会影响更新语句外，建索引动作也需要谨慎。<strong>建索引会排序，而排序是非常耗CPU的一个动作</strong>，如果在系统繁忙时再增加大量排序，对系统来说无疑是雪上添霜。<br>另外<strong>建索引的过程会产生锁，而且不是行级锁，是把整个表锁住，任何该表的DML操作都将被阻止。</strong><br>建索引是需要把当前索引列的列值都取出来，排序后依次插入块中形成索引块的，加上锁是为了避免此时列值被更新，导致顺序又变化了，影响了建索引的工作。</p><p><code>alter index index_name monitoring usage;</code> 对索引进行监控。<br><code>select * from v$object_usage;</code> 查询监控记录。其中 USED 字段表示索引是否被使用过。<br><code>alter index index_name nomonitoring usage;</code> 对索引解除监控。<br>另外，要注意监控也是有代价的。</p><h3 id="位图索引"><a href="#位图索引" class="headerlink" title="位图索引"></a>位图索引</h3><p><code>create bitmap index index_name on table_name(field_name);</code> 创建位图索引。</p><p>位图索引（Bitmap Index）是一种用于数据库中的特殊类型的索引结构。<br><strong>它主要用于低基数（low cardinality）的列，即那些具有相对较少不同值的列。</strong> 位图索引非常适合于数据仓库环境中的大量读取操作，因为它能够非常高效地处理选择查询。</p><p>位图索引的工作原理：<br>位图索引使用一系列位图来表示数据表中的行。对于每一个不同的值，位图索引都会创建一个位图。位图中的每一位对应数据表中的一行记录，如果该行具有相应的值，则对应的位被设置为1；否则，位被设置为0。</p><p>优点：</p><ol><li>位图索引非常节省空间，因为只存储0和1，每个值只占用1位。</li><li>非常适合范围查询和过滤操作。可以通过位运算快速找到匹配的行。</li><li>适合数据仓库中的复杂的、批处理式的查询。</li></ol><p>缺点：</p><ol><li>更新的成本高。低基数的列意味着包含同一值有大量的行，因此更新的影响很大。会导致锁等问题，影响并发。</li><li>不适合高基数的列。对于具有大量不同值的列，位图索引会变得非常大且效率低下。</li><li>对于较小的表，位图索引可能不会带来显著的性能提升，反而会增加额外的管理开销。</li></ol><p>COUNT(*)的性能，在非空列有BTREE索引的情况下，一般用到该索引性能远高于全表扫描。<br>不过性能最高的却是列上有位图索引的情况，甚至比用到普通非空列的BTREE索引时的性能又高出一大截。<br>另外，<strong>位图索引可以存储空值</strong>。</p><p>位图索引的适合场景要满足两个条件：<strong>1. 位图索引列大量重复 2. 该表极少更新</strong></p><h3 id="函数索引"><a href="#函数索引" class="headerlink" title="函数索引"></a>函数索引</h3><p><strong>对索引列做运算导致索引无法使用。</strong><br>比如 <code>select * from table_name where upper(field_name) = &#39;T&#39;;</code><br>当必须要对索引列做函数运算时，可以创建函数索引。</p><p><code>create index index_name on table_name(upper(field_name));</code> 创建函数索引。</p><p>函数索引（Function-Based Index）是一种特殊的索引类型，它允许在数据库中创建基于表达式或函数计算结果的索引。函数索引可以提高某些查询的性能，特别是在查询条件中包含复杂的表达式或函数时。<br>函数索引索的引键是基于表达式的结果，而不是表中的原始列值。当查询包含与函数索引表达式相同的表达式时，Oracle可以使用该索引来加速查询。这可以避免在查询执行时重复计算表达式。</p><p>函数索引的性能介于普通索引和全表扫描之间。因此，能用普通索引就用普通索引。尽量避免列运算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第五章-惊叹，索引天地妙不可言&quot;&gt;&lt;a href=&quot;#第五章-惊叹，索引天地妙不可言&quot; class=&quot;headerlink&quot; title=&quot;第五章 - 惊叹，索引天地妙不可言&quot;&gt;&lt;/a&gt;第五章 - 惊叹，索引天地妙不可言&lt;/h2&gt;&lt;h3 id=&quot;BTREE-索引&quot;</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://cooooing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据库" scheme="https://cooooing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="《收获，不止Oracle》" scheme="https://cooooing.github.io/tags/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B/"/>
    
    <category term="Oracle" scheme="https://cooooing.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>《收获，不止Oracle》读书笔记上篇-表设计</title>
    <link href="https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E8%A1%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E8%A1%A8%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-08-01T02:36:33.000Z</published>
    <updated>2024-08-01T02:36:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四章-祝贺，表设计成就英雄"><a href="#第四章-祝贺，表设计成就英雄" class="headerlink" title="第四章 - 祝贺，表设计成就英雄"></a>第四章 - 祝贺，表设计成就英雄</h2><ul><li><strong>普通堆表</strong>：适合大部分设计场景，有优点也有缺点，需要和其他表设计取长补短。 <ul><li>优点：语法简单方便、适用大部分场景</li><li>缺点：表更新日志开销较大、Delete无法释放空间、表记录太大检索较慢、素引回表读开销很大、即便有序插入，也难以有序读出</li></ul></li><li><strong>全局临时表</strong>：适合接口表设计<ul><li>优点：高效删除、产生日志少、不同SESSION独立，不产生锁</li><li>缺点：语法特别、数据无法得到有效的保护</li></ul></li><li><strong>分区表</strong>：适合日志表<ul><li>优点：有效的分区消除、高效的记录清理、高效的记录转移</li><li>缺点：语法复杂、分区过多对系统有一定的影响</li></ul></li><li><strong>索引组织表</strong>：适合极少更新的配置表<ul><li>优点：表就是索引，可以避免回表、语法复杂</li><li>缺点：更新开销牧大</li></ul></li><li><strong>簇表</strong>：适合使用频繁关联查询的多表<ul><li>优点：可以减少或避免排序</li><li>缺点：语法复杂、表更新开销大</li></ul></li></ul><p>每个人都有每个人的特点和优势，要善于发掘和利用，才可以把事情做好。<br>不同的表也一样，有的适用于这个应用场景，却不适合另外一个场景，要学会选择性地使用技术。<br><strong>技术其实并不难，最难的是如何选择。</strong> 这一章主要就是在强调什么场合该选什么技术。没有高级的技术，只有最合适的技术。</p><h3 id="普通堆表不足之处"><a href="#普通堆表不足之处" class="headerlink" title="普通堆表不足之处"></a>普通堆表不足之处</h3><h4 id="表更新日志开销较大"><a href="#表更新日志开销较大" class="headerlink" title="表更新日志开销较大"></a>表更新日志开销较大</h4><p>下面的脚本是利用 v$statname 和 v$mystat 两个动态性能视图来跟踪当前SESSION操作产生的日志量.<br>使用方法很简单：首次先执行该脚本，查看日志大小，随即执行你的更新语句，再执行该脚本返回的日志大小，两者相减，就是你此次更新语句产生的日志大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看产生多少日志</span><br><span class="line">select a.name, b.value</span><br><span class="line">from v$statname a,</span><br><span class="line">     v$mystat b</span><br><span class="line">where a.statistic# = b.statistic#</span><br><span class="line">  and a.name = &#x27;redo size&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 赋权</span><br><span class="line">grant all on v_$statname to TEST_USER;</span><br><span class="line">grant all on v_$mystat to TEST_USER;</span><br><span class="line">-- 以下创建视图，方便后续直接用 select * from v_redo_size 进行查询</span><br><span class="line">create or replace view v_redo_size as</span><br><span class="line">select a.name, b.value</span><br><span class="line">from v$statname a,</span><br><span class="line">     v$mystat b</span><br><span class="line">where a.statistic# = b.statistic#</span><br><span class="line">  and a.name = &#x27;redo size&#x27;;</span><br></pre></td></tr></table></figure><p>下面观察各个更新操作产生的日志量。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                               600</span><br><span class="line"></span><br><span class="line">SQL&gt; delete from t;</span><br><span class="line"></span><br><span class="line">70927 rows deleted.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                           1152708</span><br><span class="line"></span><br><span class="line">SQL&gt; insert into t select OBJECT_ID from dba_objects;</span><br><span class="line"></span><br><span class="line">71191 rows created.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                           2262512</span><br><span class="line"></span><br><span class="line">SQL&gt; update t set id = rownum;</span><br><span class="line"></span><br><span class="line">71191 rows updated.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                          13080536</span><br></pre></td></tr></table></figure><p>删除操作产生了 1152708 - 600 &#x3D; 1146708 字节，大约1.09M 的日志。<br>插入操作产生了 2262512 - 1152708 &#x3D; 1109804 字节，大约1.06M 的日志。<br>更新操作产生了 13080536 - 2262512 &#x3D; 10818024 字节，大约10.32M 的日志。</p><p>无论是删除、插入还是修改，都会产生日志。前面体系结构中讲过这些日志是用于数据库的备份和恢复的。<br>如果仅从性能角度而不从安全性角度来考虑，更新表写日志就意味着数据库多做了额外的事情而影响了效率，虽说安全第一，不过在某些特定的场合，某些表的记录只是作为中间结果临时运算而根本无须永久保留，这些表无须写日志，那就既高效又安全了！<br>这就是后续会说的全局临时表。</p><h4 id="Delete无法释放空间"><a href="#Delete无法释放空间" class="headerlink" title="Delete无法释放空间"></a>Delete无法释放空间</h4><p>使用 <code>delete from t</code> 删除表，前后查询所产生的逻辑读次数是相同的。只有使用 <code>truncate table t</code> 清空表，才能显著减少逻辑读次数。<br>显然，<strong>delete删除并不能释放空间，虽然delete将很多块的记录删除了，但是空块依然保留，Oracle在查询时依然会去查询这些空块。</strong><br><strong>而truncate是一种释放高水平位的动作，这些空块被回收，空间也就释放了。</strong></p><p>不过truncate显然不能替代delete，因为truncate是一种DDL操作而非DML操作，truncate后面是不能带条件的，truncate table t where…是不允许的。<br>但是如果表中这些where条件能形成有效的分区，Oracle是支持在分区表中做truncate分区的，命令大致为 <code>alter table t truncate partition &#39;分区名&#39;</code>。<br>如果where条件就是分区条件，那等同于换角度实现了truncate table t where…的功能。<br><strong>这就是分区表最实用的功能之一了，高效地清理数据，释放空间。</strong></p><p>此外，当大量delete删除再大量insert插入时，Oracle会去这些delete的空块中首先完成插入（直接路径插入除外），所以频繁delete又频繁insert的应用，是不会出现空块过多的情况的。</p><h4 id="表记录太大检索较慢"><a href="#表记录太大检索较慢" class="headerlink" title="表记录太大检索较慢"></a>表记录太大检索较慢</h4><p>一张表其实就是一个SEGMENT，一般情况下我们都需要遍历该SEGMENT的所有BLOCK来完成对该表进行更新查询等操作，在这种情况下，表越大，更新查询操作就越慢。<br>有没有什么好方法能提升检索的速度呢？主要思路就是缩短访问路径来完成同样的更新查询操作，简单地说就是完成同样的需求访问BLOCK的个数越少越好。<br>Oracle为了尽可能减少访问路径提供了两种主要技术，<strong>一种是索引技术，另一种则是分区技术</strong>。</p><p>以 <code>select * from t where insert_time &gt; xxxx and insert_time &lt; xxxx</code> 为例，如果id是主键，那么Oracle会直接通过索引找到对应的BLOCK，然后直接读取该BLOCK中的记录。</p><p>首先说索引，这是Oracle中最重要也是最实用的技术之一。<br>在本例中，如果 <code>insert_time &gt; xxxx and insert_time &lt; xxxx</code> 返回的记录非常少，或者说T表的总记录相比非常少，则在 insert_time 列建索引能极大提升该语句的效率。<br>比如建了一个 t_id_index 的索引，在该SQL查询时首先会访问 t_id_index 这个新建出来的索引段，然后通过索引段和表段的映射关系，迅速从表中获取行列的信息并返回结果。具体细节后续索引部分细说。<br>索引本身也是一把双刃剑，既能给数据库开发应用带来极大的帮助，也会给数据库带来不小的灾难。</p><p>减少访问路径的第二种技术就是分区技术，把普通表T表改造为分区表，比如以 insert_time 这个时间列为分区字段，比如从 2020年1月到2023年12月按月建36个分区。<br>早先的T表就一个T段，现在情况变化了，从1个大段分解成了36个小段，分别存储了2010年1月到2012年12月的信息，此时假如 <code>insert_time &gt; xxxx and insert_time &lt; xxxx</code> 这个时间跨度正好是落在2020年11月，那Oracle的检索就只要完成一个小段的遍历即可。<br>假设这36个小段比较均匀，我们就可以大致理解为访问量只有原来的三十六分之一，大幅度减少了访问路径，从而高效地提升了性能。</p><h4 id="索引回表读开销很大"><a href="#索引回表读开销很大" class="headerlink" title="索引回表读开销很大"></a>索引回表读开销很大</h4><p>观察下面例子中，<code>TABLE ACCESS BY INDEX ROWID BATCHED</code> 的开销。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">L&gt; drop table t purge;</span><br><span class="line"></span><br><span class="line">Table dropped.</span><br><span class="line"></span><br><span class="line">SQL&gt; create table t as select * from dba_objects where ROWNUM &lt;= 200;</span><br><span class="line"></span><br><span class="line">Table created.</span><br><span class="line"></span><br><span class="line">SQL&gt; create index t_object_id_index on t(object_id);</span><br><span class="line"></span><br><span class="line">Index created.</span><br><span class="line"></span><br><span class="line">SQL&gt; set linesize 1000</span><br><span class="line">SQL&gt; set autotrace traceonly</span><br><span class="line">SQL&gt; select * from t where object_id &lt;= 10;</span><br><span class="line"></span><br><span class="line">9 rows selected.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 632031452</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation                           | Name              | Rows  | Bytes | Cost (%CPU)| Time     |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT                    |                   |     9 |   963 |     2   (0)| 00:00:01 |</span><br><span class="line">|   1 |  TABLE ACCESS BY INDEX ROWID BATCHED| T                 |     9 |   963 |     2   (0)| 00:00:01 |</span><br><span class="line">|*  2 |   INDEX RANGE SCAN                  | T_OBJECT_ID_INDEX |     9 |       |     1   (0)| 00:00:01 |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   2 - access(&quot;OBJECT_ID&quot;&lt;=10)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">       1316  recursive calls</span><br><span class="line">          0  db block gets</span><br><span class="line">       1620  consistent gets</span><br><span class="line">        135  physical reads</span><br><span class="line">          0  redo size</span><br><span class="line">       4319  bytes sent via SQL*Net to client</span><br><span class="line">        108  bytes received via SQL*Net from client</span><br><span class="line">          2  SQL*Net roundtrips to/from client</span><br><span class="line">         96  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">          9  rows processed</span><br></pre></td></tr></table></figure><p>一般来说，根据索引来检索记录，会有一个先从索引中找到记录，再根据索引列上的 ROWID 定位到表中从而返回索引列以外的其他列的动作，这就是<code>TABLE ACCESS BY INDEX ROWID</code>。<br>下面观察如果消除 <code>TABLE ACCESS BY INDEX ROWID BATCHED</code> 的开销。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select object_id from t where object_id &lt;= 10;</span><br><span class="line"></span><br><span class="line">9 rows selected.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 3023054428</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation        | Name              | Rows  | Bytes | Cost (%CPU)| Time     |</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT |                   |     9 |    36 |     1   (0)| 00:00:01 |</span><br><span class="line">|*  1 |  INDEX RANGE SCAN| T_OBJECT_ID_INDEX |     9 |    36 |     1   (0)| 00:00:01 |</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   1 - access(&quot;OBJECT_ID&quot;&lt;=10)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">       1262  recursive calls</span><br><span class="line">          0  db block gets</span><br><span class="line">       1484  consistent gets</span><br><span class="line">        151  physical reads</span><br><span class="line">          0  redo size</span><br><span class="line">        697  bytes sent via SQL*Net to client</span><br><span class="line">        108  bytes received via SQL*Net from client</span><br><span class="line">          2  SQL*Net roundtrips to/from client</span><br><span class="line">         96  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">          9  rows processed</span><br></pre></td></tr></table></figure><p>这里没有 <code>TABLE ACCESS BY INDEX ROWID</code> 了。<br>因为语句从 <code>select * from t where object_id &lt;= 10;</code> 改写为 <code>select object_id from t where object_id &lt;= 10;</code> 了，不用从索引中回到表中获取索引列以外的其他列了。<br>性能上，逻辑读从1620变为1484，代价从2变为1。（每次执行前都清空了共享池和缓存）<br>避免回表从而使性能提升这是一个很简单的道理，少做事性能当然提升了。<br>只是 <code>select * from t</code> 和 <code>select object_id from t</code>毕竞不等价，有没有什么方法可以实现写法依然是 <code>select * from t</code> 但是还是可以不回表呢？<br><strong>普通表是做不到的，能实现这种功能的只有索引组织表。</strong></p><h4 id="有序插入却难以有序读出"><a href="#有序插入却难以有序读出" class="headerlink" title="有序插入却难以有序读出"></a>有序插入却难以有序读出</h4><p>在对普通表的操作中，我们无法保证在有序插入的前提下就能有序读出。<br>最简单的一个理由就是，如果把行记录插入块中，然后删除了该行，接下来插入的行会去填补块中的空余部分，这就无法保证有序了。<br>所以在查询数据时，如果想有序地展现，就必须使用order by，否则根本不能保证顺序展现，而order by操作是开销很大的操作。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select object_id from t;</span><br><span class="line"></span><br><span class="line">200 rows selected.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 1601196873</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     |</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT  |      |   200 |   800 |     3   (0)| 00:00:01 |</span><br><span class="line">|   1 |  TABLE ACCESS FULL| T    |   200 |   800 |     3   (0)| 00:00:01 |</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">          1  recursive calls</span><br><span class="line">          0  db block gets</span><br><span class="line">         20  consistent gets</span><br><span class="line">          4  physical reads</span><br><span class="line">          0  redo size</span><br><span class="line">       4228  bytes sent via SQL*Net to client</span><br><span class="line">        433  bytes received via SQL*Net from client</span><br><span class="line">         15  SQL*Net roundtrips to/from client</span><br><span class="line">          0  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">        200  rows processed</span><br><span class="line"></span><br><span class="line">SQL&gt; select object_id from t order by OBJECT_ID desc;</span><br><span class="line"></span><br><span class="line">200 rows selected.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 961378228</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT   |      |   200 |   800 |     4  (25)| 00:00:01 |</span><br><span class="line">|   1 |  SORT ORDER BY     |      |   200 |   800 |     4  (25)| 00:00:01 |</span><br><span class="line">|   2 |   TABLE ACCESS FULL| T    |   200 |   800 |     3   (0)| 00:00:01 |</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">         50  recursive calls</span><br><span class="line">          6  db block gets</span><br><span class="line">         46  consistent gets</span><br><span class="line">          1  physical reads</span><br><span class="line">       1008  redo size</span><br><span class="line">       4228  bytes sent via SQL*Net to client</span><br><span class="line">        433  bytes received via SQL*Net from client</span><br><span class="line">         15  SQL*Net roundtrips to/from client</span><br><span class="line">          3  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">        200  rows processed</span><br></pre></td></tr></table></figure><p>可以观察到，有排序的操作的统计信息模块有个 3 sorts(memory)，表示发生了排序，执行计划中也有<code>SORT ORDER BY</code>的关键字。<br>不过最重要的是，没排序的操作代价为3，有排序的操作代价为4，性能上是有差异的，在大数量时将会非常明显。<br>关于order by避免排序的方法有两种思路。第一种思路是在order by的排序列建索引，至于为什么，还是留着后续索引部分细说。第二种方法就是，将普通表改造为有序散列聚簇表，这样可以保证顺序插入，order by展现时无须再有排序动作。</p><h3 id="奇特的全局临时表"><a href="#奇特的全局临时表" class="headerlink" title="奇特的全局临时表"></a>奇特的全局临时表</h3><p>从数据安全性来看，对表记录的操作写日志是不可避免的，否则备份恢复就无从谈起了，只是现实中真的有一部分应用对表的某些操作是不需要恢复的，比如运算过程中临时处理的中间结果集，这时就可以考虑用全局临时表来实现。</p><h4 id="全局临时表的类型"><a href="#全局临时表的类型" class="headerlink" title="全局临时表的类型"></a>全局临时表的类型</h4><p>全局临时表分为两种类型，一种是**基于会话的全局临时表(commit preserve rows)<strong>，一种是</strong>基于事务的全局临时表(on commit delete rows)**。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建基于会话的全局临时表</span><br><span class="line">drop table t_tmp_session purge;</span><br><span class="line">create global temporary table T_TMP_session on commit preserve rows as select * from dba_objects where 1 = 2;</span><br><span class="line">select table_name, temporary, duration from user_tables where table_name = &#x27;T_TMP_SESSION&#x27;;</span><br><span class="line">-- 创建基于事务的全局临时表</span><br><span class="line">drop table t_tmp_transaction purge;</span><br><span class="line">create global temporary table t_tmp_transaction on commit delete rows as select * from dba_objects where 1 = 2;</span><br><span class="line">select table_name, temporary, DURATION from user_tables where table_name = &#x27;T_TMP_TRANSACTION&#x27;;</span><br></pre></td></tr></table></figure><h4 id="观察各类DML的REDO日志量"><a href="#观察各类DML的REDO日志量" class="headerlink" title="观察各类DML的REDO日志量"></a>观察各类DML的REDO日志量</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                             43504</span><br><span class="line"></span><br><span class="line">SQL&gt; insert into T_TMP_session select * from dba_objects;</span><br><span class="line"></span><br><span class="line">71208 rows created.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                            605748</span><br><span class="line">-- 基于会话的全局临时表，插入数据时产生了 605748 - 43504 = 562244 ，约0.54MB</span><br><span class="line">SQL&gt; insert into t_tmp_transaction select * from dba_objects;</span><br><span class="line"></span><br><span class="line">71208 rows created.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                           1167932</span><br><span class="line">-- 基于事务的全局临时表，插入数据时产生了 1167932 - 605748 = 562184 ，约0.54MB</span><br><span class="line">SQL&gt; update T_TMP_session set object_id = rownum;</span><br><span class="line"></span><br><span class="line">71208 rows updated.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                           6850608</span><br><span class="line">-- 基于会话的全局临时表，更新数据时产生了 6850608 - 1167932 = 5682676 ，约5.42MB</span><br><span class="line">SQL&gt; update t_tmp_transaction set object_id = rownum;</span><br><span class="line"></span><br><span class="line">71208 rows updated.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                          11516184</span><br><span class="line">-- 基于事务的全局临时表，更新数据时产生了 11516184 - 6850608 = 4665576 ，约4.45MB</span><br><span class="line">SQL&gt; delete from T_TMP_session;</span><br><span class="line"></span><br><span class="line">71208 rows deleted.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                          23298188</span><br><span class="line">-- 基于会话的全局临时表，删除数据时产生了 23298188 - 11516184 = 11782004 ，约11.24MB</span><br><span class="line">SQL&gt; delete from t_tmp_transaction;</span><br><span class="line"></span><br><span class="line">71208 rows deleted.</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from v_redo_size;</span><br><span class="line"></span><br><span class="line">NAME                                                                  VALUE</span><br><span class="line">---------------------------------------------------------------- ----------</span><br><span class="line">redo size                                                          35080104</span><br><span class="line">-- 基于事务的全局临时表，删除数据时产生了 35080104 - 23298188 = 11781916 ，约11.24MB</span><br></pre></td></tr></table></figure><p><strong>可以发现全局临时表，无论插入，修改还是删除，都还是要写日志。</strong><br><strong>只是无论插入更新还是删除，操作普通表产生的日志都比全局临时表要多。</strong><br>具体比较就省略了，比较语句上基本没有差别。</p><h4 id="全局临时表两大特性"><a href="#全局临时表两大特性" class="headerlink" title="全局临时表两大特性"></a>全局临时表两大特性</h4><p>全局临时表最重要的特点有两个。</p><ol><li><strong>高效删除记录</strong>，基于事务的全局临时表COMMIT或者SESSION连接退出后，临时表记录自动删除；基于会话的全局临时表则是SESSION连接退出后，临时表记录自动删除，都无须手动去操作。</li><li><strong>针对不同会话数据独立</strong>，不同的SESSION访问全局临时表，看到的结果不同。</li></ol><h5 id="高效删除记录"><a href="#高效删除记录" class="headerlink" title="高效删除记录"></a>高效删除记录</h5><p><strong>基于事务的全局临时表COMMIT后，记录会被删除。</strong><br>另外，用C0MMT方式删除全局临时表记录所产生的日志量才很小，比起直接用delete方式操作产生的日志量，几乎可以忽略不计了。<br>这点日志其实还是是COMMIT动作本身产生的，所以基本可以理解为全局临时表的COMMIT或者退出SESSION的方式不会产生日志。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; insert into t_tmp_transaction select * from dba_objects;</span><br><span class="line"></span><br><span class="line">71208 rows created.</span><br><span class="line"></span><br><span class="line">SQL&gt; select count(1) from t_tmp_transaction;</span><br><span class="line"></span><br><span class="line">  COUNT(1)</span><br><span class="line">----------</span><br><span class="line">     71208</span><br><span class="line"></span><br><span class="line">SQL&gt; commit;</span><br><span class="line"></span><br><span class="line">Commit complete.</span><br><span class="line"></span><br><span class="line">SQL&gt; select count(1) from t_tmp_transaction;</span><br><span class="line"></span><br><span class="line">  COUNT(1)</span><br><span class="line">----------</span><br><span class="line">         0</span><br></pre></td></tr></table></figure><p><strong>基于会话的全局临时表SESSION退出后，记录会被删除。</strong></p><p>一般来说，基于SESSION的全局临时表的应用会更多一些，少数比较复杂的应用，涉及一次调用中需要记录清空再插入等复杂动作时，才考虑用基于事务的全局临时表。</p><h5 id="不同会话独立"><a href="#不同会话独立" class="headerlink" title="不同会话独立"></a>不同会话独立</h5><p>即每个session会话中查询到的全局临时表数据是相互独立的，相互隔离、互不干扰。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询当前会话信息</span><br><span class="line">select * from v$mystat where ROWNUM = 1;</span><br></pre></td></tr></table></figure><h3 id="神通广大的分区表"><a href="#神通广大的分区表" class="headerlink" title="神通广大的分区表"></a>神通广大的分区表</h3><p>在如今数据量日益增长的海量数据库时代，分区表技术显得尤为重要，甚至可以说使用得当与否将决定到系统的生死。<br>关于普通堆表的不足，其中表记录太大检索慢和delete删除有瑕疵这两个缺点正好可以被分区表的分区消除和可以高效清理分区数据这两大特点给弥补了。</p><p>什么叫分区消除，最通俗的比喻就是，对某表按月份建了范围分区，从1月到12月共12个分区，你查询当前12月的记录，就不会去访问另外11个区，少做事了，这就是分区消除。<br>高效分区清理呢，就是如果要删除某分区的数据，如果直接delete，速度很慢，而且高水平位也不会释放，查询的块依然很多，这时可以直接truncate这个分区，速度非常快。</p><p><strong>在这个Google的时代，语法和知识点都不是问题，搜不到的是体系，是重点，是思想。</strong><br>上面是书中的原话，这里还想说的就是。时代在进步，如今AI的时代，获取知识更加容易。但无论什么时代，都要善于利用工具。</p><h4 id="分区表类型及原理"><a href="#分区表类型及原理" class="headerlink" title="分区表类型及原理"></a>分区表类型及原理</h4><p>首先探讨的是分区表的类型及原理。分区表的类型有范围分区、列表分区、HA$H分区及组合分区4种。<br>其中范围分区应用最为广泛，需要重点学习和掌握，而列表分区次之，在某些场合下也可以考虑使用组合分区，相对而言HASH分区在应用中适用的场景并不广泛，使用的频率比较低。</p><p><a class="link"   href="https://www.cnblogs.com/momoyan/p/9164411.html" >oracle分区表的使用和查询<i class="fas fa-external-link-alt"></i></a></p><h5 id="范围分区"><a href="#范围分区" class="headerlink" title="范围分区"></a>范围分区</h5><p>范围分区最常见的是按时间列进行分区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-- 创建范围分区表</span><br><span class="line">create table range_part_tab</span><br><span class="line">(</span><br><span class="line">    id        number,</span><br><span class="line">    deal_date date,</span><br><span class="line">    area_code number,</span><br><span class="line">    contents  varchar2(4000)</span><br><span class="line">)</span><br><span class="line">    partition by range (deal_date)</span><br><span class="line">(</span><br><span class="line">    partition p1 values less than (TO_DATE(&#x27;2024-02-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p2 values less than (TO_DATE(&#x27;2024-03-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p3 values less than (TO_DATE(&#x27;2024-04-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p4 values less than (TO_DATE(&#x27;2024-05-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p5 values less than (TO_DATE(&#x27;2024-06-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p6 values less than (TO_DATE(&#x27;2024-07-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p7 values less than (TO_DATE(&#x27;2024-08-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p8 values less than (TO_DATE(&#x27;2024-09-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p9 values less than (TO_DATE(&#x27;2024-10-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p10 values less than (TO_DATE(&#x27;2024-11-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p11 values less than (TO_DATE(&#x27;2024-12-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p12 values less than (TO_DATE(&#x27;2025-01-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">    partition p_max values less than (maxvalue)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">-- 插入一整年随机日期和591-599之间的随机数。共100000条数据</span><br><span class="line">insert into range_part_tab(id, deal_date, area_code, contents)</span><br><span class="line">select rownum,</span><br><span class="line">       to_date(to_char(sysdate - 365, &#x27;J&#x27;) + TRUNC(DBMS_RANDOM.VALUE(0, 365)), &#x27;J&#x27;),</span><br><span class="line">       ceil(dbms_random.value(590, 599)),</span><br><span class="line">       rpad(&#x27;*&#x27;, 400, &#x27;*&#x27;)</span><br><span class="line">from dual</span><br><span class="line">connect by rownum &lt;= 100000;</span><br></pre></td></tr></table></figure><ol><li>范围分区的关键字为 <code>partition by range</code> ，即这三个关键字表示该分区为范围分区。后面为范围的字段。</li><li><code>values less than</code> 是范围分区特定的语法，用于指明具体的范围，比如<code>partition p3 values less than (TO_DATE(&#39;2024-04-01&#39;, &#39;YYYY-MM-DD&#39;))</code>，表示小于3月份的记录。partition p1到partition pmax 表示总共建立了13个分区。最后还要注意<code>partition p_max values less than (maxvalue)</code>的部分，表示超出这些范围的记录全部落在这个分区中，包括空值，免得出错。</li><li>分区表的分区可分别指定在不同的表空间里，如果不写即为都在同一默认表空间里。如果将每个分区保存到单独的表空间中，这样数据文件就可以跨越多个物理磁盘。</li></ol><h5 id="列表分区"><a href="#列表分区" class="headerlink" title="列表分区"></a>列表分区</h5><p>列表分区的特点是某列的值只有几个，基于这样的特点我们可以采用列表分区。创建一个按字段数据列表固定可枚举值分区的表。插入记录分区字段的值必须在列表中，否则不能被插入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 创建列表分区表</span><br><span class="line">create table list_part_tab</span><br><span class="line">(</span><br><span class="line">    id        number,</span><br><span class="line">    deal_date date,</span><br><span class="line">    area_code number,</span><br><span class="line">    contents  varchar2(4000)</span><br><span class="line">)</span><br><span class="line">    partition by list (area_code)</span><br><span class="line">(</span><br><span class="line">    partition p_591 values (591),</span><br><span class="line">    partition p_592 values (592),</span><br><span class="line">    partition p_593 values (593),</span><br><span class="line">    partition p_594 values (594),</span><br><span class="line">    partition p_595 values (595),</span><br><span class="line">    partition p_596 values (596),</span><br><span class="line">    partition p_597 values (597),</span><br><span class="line">    partition p_598 values (598),</span><br><span class="line">    partition p_599 values (599),</span><br><span class="line">    partition p_other values (DEFAULT)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>列表分区的关键字为<code>partition by list</code>，即这三个关键字表示该分区为列表分区。</li><li>不同于之前范围分区的<code>values less than</code>，列表分区仅需values即可确定范围，值得注意的是，<code>partition p592 values(592)</code>并不是说明取值只能写一个，也可写为多个，比如<code>partition p_union values (592,593,594)</code>。</li><li>partition p_591到partition p_other表示总共建立了10个分区。</li><li><code>partition p_other values(default)</code>，表示不在刚才591到S99范围的记录全部落在这个默认分区中，包括空值，避免应用出错。</li><li>分区表的分区可分别指定在不同的表空间里，如果不写即为都在同一默认表空间里。</li></ol><h5 id="散列分区（Hash分区）"><a href="#散列分区（Hash分区）" class="headerlink" title="散列分区（Hash分区）"></a>散列分区（Hash分区）</h5><p>hash分区最主要的机制是根据hash算法来计算具体某条纪录应该插入到哪个分区中，hash算法中最重要的是hash函数，Oracle中如果你要使用hash分区，只需指定分区的数量即可。<br>建议分区的数量采用2的n次方，这样可以使得各个分区间数据分布更加均匀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 创建hash分区表</span><br><span class="line">create table hash_part_tab</span><br><span class="line">(</span><br><span class="line">    id        number,</span><br><span class="line">    deal_date date,</span><br><span class="line">    area_code number,</span><br><span class="line">    contents  varchar2(4000)</span><br><span class="line">)</span><br><span class="line">    partition by hash (deal_date)</span><br><span class="line">    PARTITIONS 16;</span><br></pre></td></tr></table></figure><ol><li>散列分区的关键字为<code>partition by hash</code>，出现这三个关键字即表示当前分区为散列分区。</li><li>散列分区与之前两种分区的明显差别在于：没有指定分区名，而仅仅是指定了分区个数，如<code>PARTITIONS 16</code>。</li><li>散列分区的分区数量采用2的n次方，这样可以使得各个分区间数据分布更加均匀。</li><li>可以指定散列分区的分区表空间，比如增加如下一小段，<code>STORE IN(ts1,ts2,ts3,ts4,ts5,ts6,ts7,ts8,ts9,ts10,ts11,ts12,ts13,ts14,ts15,ts16)</code>表示分别存在在12个不同的表空间里，当然不写出表空间就是都在同一默认表空间里。</li></ol><h5 id="组合分区"><a href="#组合分区" class="headerlink" title="组合分区"></a>组合分区</h5><p>组合分区结合了两种或多种不同的分区方法，如范围分区（Range Partitioning）、列表分区（List Partitioning）和散列分区（Hash Partitioning）。<br>通过组合使用这些方法，可以实现更高效的查询性能和更好的数据管理。</p><p>基于范围分区和列表分区，表首先按某列进行范围分区，然后再按某列进行列表分区，分区之中的分区被称为子分区。<br>基于范围分区和散列分区，表首先按某列进行范围分区，然后再按某列进行散列分区。<br>以此类推，其实就是分区中的分区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">-- 创建基于范围和列表的组合分区表</span><br><span class="line">CREATE TABLE range_list_part_tab</span><br><span class="line">(</span><br><span class="line">    id        number,</span><br><span class="line">    deal_date date,</span><br><span class="line">    area_code number,</span><br><span class="line">    contents  varchar2(4000)</span><br><span class="line">)</span><br><span class="line">    partition by range (deal_date) -- 第一级分区：按年份范围分区</span><br><span class="line">    SUBPARTITION by list (area_code) -- 第二级分区：按地区编号列表分区</span><br><span class="line">(</span><br><span class="line">    PARTITION rlp1 VALUES LESS THAN (TO_DATE(&#x27;2024-06-01&#x27;, &#x27;YYYY-MM-DD&#x27;))</span><br><span class="line">        (</span><br><span class="line">        subpartition rlp1_595 values (595),</span><br><span class="line">        subpartition rlp1_other values (DEFAULT)</span><br><span class="line">        ),</span><br><span class="line">    partition rlp2 values less than (maxvalue)</span><br><span class="line">        (</span><br><span class="line">        subpartition rlp2_595 values (595),</span><br><span class="line">        subpartition rlp2_other values (DEFAULT)</span><br><span class="line">        )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">-- 简化</span><br><span class="line"></span><br><span class="line">CREATE TABLE range_list_part_tab</span><br><span class="line">(</span><br><span class="line">  id        number,</span><br><span class="line">  deal_date date,</span><br><span class="line">  area_code number,</span><br><span class="line">  contents  varchar2(4000)</span><br><span class="line">)</span><br><span class="line">  partition by range (deal_date) -- 第一级分区：按年份范围分区</span><br><span class="line">  SUBPARTITION by list (area_code) -- 第二级分区：按地区编号列表分区</span><br><span class="line">  subpartition template</span><br><span class="line">(</span><br><span class="line">  subpartition p_591 values (591),</span><br><span class="line">  subpartition p_592 values (592),</span><br><span class="line">  subpartition p_593 values (593),</span><br><span class="line">  subpartition p_594 values (594),</span><br><span class="line">  subpartition p_595 values (595),</span><br><span class="line">  subpartition p_596 values (596),</span><br><span class="line">  subpartition p_597 values (597),</span><br><span class="line">  subpartition p_598 values (598),</span><br><span class="line">  subpartition p_599 values (599),</span><br><span class="line">  subpartition p_other values (DEFAULT)</span><br><span class="line">)(</span><br><span class="line">  partition p1 values less than (TO_DATE(&#x27;2024-02-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p2 values less than (TO_DATE(&#x27;2024-03-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p3 values less than (TO_DATE(&#x27;2024-04-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p4 values less than (TO_DATE(&#x27;2024-05-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p5 values less than (TO_DATE(&#x27;2024-06-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p6 values less than (TO_DATE(&#x27;2024-07-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p7 values less than (TO_DATE(&#x27;2024-08-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p8 values less than (TO_DATE(&#x27;2024-09-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p9 values less than (TO_DATE(&#x27;2024-10-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p10 values less than (TO_DATE(&#x27;2024-11-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p11 values less than (TO_DATE(&#x27;2024-12-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p12 values less than (TO_DATE(&#x27;2025-01-01&#x27;, &#x27;YYYY-MM-DD&#x27;)),</span><br><span class="line">  partition p_max values less than (maxvalue)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li>组合分区是由主分区和从分区组成的，比如范围列表分区，就表示主分区是范围分区，而从分区是列表分区，从分区的关键字为<code>subpartition</code>,比如本例中的<code>subpartition by list (area_code)</code>。</li><li>为了避免在每个主分区中都写相同的从分区，可以考虑用模版方式，比如简化中的<code>subpartition TEMPLATE</code>关键字。</li><li>只要涉及子分区模块，都需要有<code>subpartition</code>关键字。</li><li>关于表空间和之前的没有差别，依然是可以指定，也可以不指定。</li></ol><h5 id="分区原理"><a href="#分区原理" class="headerlink" title="分区原理"></a>分区原理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 创建普通表作为对照</span><br><span class="line">create table norm_tab(id number,deal_date date,area_code number,contents varchar2(4000));</span><br><span class="line">insert into norm_tab(id, deal_date, area_code, contents)</span><br><span class="line">select rownum,</span><br><span class="line">       to_date(to_char(sysdate - 365, &#x27;J&#x27;) + TRUNC(DBMS_RANDOM.VALUE(0, 365)), &#x27;J&#x27;),</span><br><span class="line">       ceil(dbms_random.value(590, 599)),</span><br><span class="line">       rpad(&#x27;*&#x27;, 400, &#x27;*&#x27;)</span><br><span class="line">from dual</span><br><span class="line">connect by rownum &lt; 100000;</span><br></pre></td></tr></table></figure><p>比较普通表与分区表在段分配上的差异</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; set linesize 1000</span><br><span class="line">SQL&gt; set pagesize 5000</span><br><span class="line">SQL&gt; column segment_name format a20</span><br><span class="line">SQL&gt; column partition_name format a20</span><br><span class="line">SQL&gt; column segment_type format a20</span><br><span class="line">SQL&gt; select segment_name,partition_name,segment_type,bytes/1024/1024,tablespace_name from user_segments where segment_name IN(&#x27;RANGE_PART_TAB&#x27;,&#x27;NORM_TAB&#x27;);</span><br><span class="line"></span><br><span class="line">SEGMENT_NAME         PARTITION_NAME       SEGMENT_TYPE         BYTES/1024/1024 TABLESPACE_NAME</span><br><span class="line">-------------------- -------------------- -------------------- --------------- ------------------------------</span><br><span class="line">RANGE_PART_TAB       P1                   TABLE PARTITION                   23 SYSTEM</span><br><span class="line">RANGE_PART_TAB       P4                   TABLE PARTITION                    4 SYSTEM</span><br><span class="line">RANGE_PART_TAB       P3                   TABLE PARTITION                    4 SYSTEM</span><br><span class="line">RANGE_PART_TAB       P7                   TABLE PARTITION                    4 SYSTEM</span><br><span class="line">RANGE_PART_TAB       P6                   TABLE PARTITION                    4 SYSTEM</span><br><span class="line">RANGE_PART_TAB       P2                   TABLE PARTITION                    4 SYSTEM</span><br><span class="line">RANGE_PART_TAB       P5                   TABLE PARTITION                    4 SYSTEM</span><br><span class="line">RANGE_PART_TAB       P8                   TABLE PARTITION                .1875 SYSTEM</span><br><span class="line">NORM_TAB                                  TABLE                             46 SYSTEM</span><br><span class="line"></span><br><span class="line">9 rows selected.</span><br></pre></td></tr></table></figure><p>分区表会产生多个SEGMENT，而且是建了几个分区就有几个SEGMENT，而普通表仅有一个SEGMENT。<br>分区表一个很简单的思想：化整为零，将大对象切割成多个小对象，从而使得在指定的小对象中定位到数据成为一种可能，最终达到减少访问路径，尽量少做事就能解决问题的目的。</p><p>HASH分区表无法让指定的数据到指定的分区去，这对快速检索数据并不是很有利，因此HASH分区在实际的工作中应用得相对较少一些。<br>不过任何事情存在即合理，HASH分区会用在什么场合呢？<br>其实HASH分区最大的好处在于，将数据根据一定HASH算法，均匀分布到不同的分区中去，避免查询数据时集中在某一个地方，从而避免热点块的竞争，改善IO。<br>此外，HASH可以精确匹配，无法范围扫描。<br>现实中我们可以针对某些本身就无法有效执行分区范围的列进行HASH分区，比如ID列之类的，在出现热点块竞争严重时，可考虑如此设计。</p><p>组合分区的分区数量比起非组合分区会多很多。比如上面创建的<code>range_list_part_tab</code>表，有130个分区。<br>组合分区存在的意义，就是化整为零思想的升级版，将一个大对象切割得更细更小了。这对于一个超级大表来说，也是有一定的意义的。<br>不过分区表也是有额外开销的，如果分区数量过多，Oracle就需要管理过多的段，在操作分区表时也容易引发Oracle内部大量的递归调用，此外本身的语法也有一定的复杂度。所以一般来说，只有大表才建议建分区，记录数在100万以下的表，基本上不建议建分区。</p><h4 id="分区表最实用的特性"><a href="#分区表最实用的特性" class="headerlink" title="分区表最实用的特性"></a>分区表最实用的特性</h4><h5 id="高效的分区清除"><a href="#高效的分区清除" class="headerlink" title="高效的分区清除"></a>高效的分区清除</h5><p>分区表存在最大的意义就在于，可以有效地做到分区消除，比如你对地区号做了分区，查询福州就只会在福州的分区中查找数据，而不会到厦门、漳州、泉州等其他分区中查找，这就是分区消除，消除了福州以外的所有其他分区。<br>原理很简单，就是因为分区表其实是将一个大对象分成了多个小对象，通过分区的规则，可以确定数据在哪个或哪几个小对象中，从而减少访问路径。</p><p>比较相同语句，普通表无法用到 DEAL_DATE 条件进行分区消除的情况。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from range_part_tab where deal_date &gt;= TO_DATE(&#x27;2024-02-04&#x27;, &#x27;YYYY-MM-DD&#x27;) and deal_date &lt; TO_DATE(&#x27;2024-02-07&#x27;, &#x27;YYYY-MM-DD&#x27;);</span><br><span class="line"></span><br><span class="line">853 rows selected.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.16</span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 16125146</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation              | Name           | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT       |                |   832 |  1655K|   129   (0)| 00:00:01 |       |       |</span><br><span class="line">|   1 |  PARTITION RANGE SINGLE|                |   832 |  1655K|   129   (0)| 00:00:01 |     2 |     2 |</span><br><span class="line">|*  2 |   TABLE ACCESS FULL    | RANGE_PART_TAB |   832 |  1655K|   129   (0)| 00:00:01 |     2 |     2 |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   2 - filter(&quot;DEAL_DATE&quot;&gt;=TO_DATE(&#x27; 2024-02-04 00:00:00&#x27;, &#x27;syyyy-mm-dd hh24:mi:ss&#x27;) AND</span><br><span class="line">              &quot;DEAL_DATE&quot;&lt;TO_DATE(&#x27; 2024-02-07 00:00:00&#x27;, &#x27;syyyy-mm-dd hh24:mi:ss&#x27;))</span><br><span class="line"></span><br><span class="line">Note</span><br><span class="line">-----</span><br><span class="line">   - dynamic statistics used: dynamic sampling (level=2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">         50  recursive calls</span><br><span class="line">          3  db block gets</span><br><span class="line">        652  consistent gets</span><br><span class="line">          0  physical reads</span><br><span class="line">        620  redo size</span><br><span class="line">      29086  bytes sent via SQL*Net to client</span><br><span class="line">       1508  bytes received via SQL*Net from client</span><br><span class="line">         58  SQL*Net roundtrips to/from client</span><br><span class="line">          2  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">        853  rows processed</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from norm_tab where deal_date &gt;= TO_DATE(&#x27;2024-02-04&#x27;, &#x27;YYYY-MM-DD&#x27;) and deal_date &lt; TO_DATE(&#x27;2024-02-07&#x27;, &#x27;YYYY-MM-DD&#x27;);</span><br><span class="line"></span><br><span class="line">800 rows selected.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.21</span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 278673677</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation         | Name     | Rows  | Bytes | Cost (%CPU)| Time     |</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT  |          |  1494 |  2971K|  1596   (1)| 00:00:01 |</span><br><span class="line">|*  1 |  TABLE ACCESS FULL| NORM_TAB |  1494 |  2971K|  1596   (1)| 00:00:01 |</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   1 - filter(&quot;DEAL_DATE&quot;&gt;=TO_DATE(&#x27; 2024-02-04 00:00:00&#x27;, &#x27;syyyy-mm-dd</span><br><span class="line">              hh24:mi:ss&#x27;) AND &quot;DEAL_DATE&quot;&lt;TO_DATE(&#x27; 2024-02-07 00:00:00&#x27;,</span><br><span class="line">              &#x27;syyyy-mm-dd hh24:mi:ss&#x27;))</span><br><span class="line"></span><br><span class="line">Note</span><br><span class="line">-----</span><br><span class="line">   - dynamic statistics used: dynamic sampling (level=2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">         24  recursive calls</span><br><span class="line">         27  db block gets</span><br><span class="line">       6019  consistent gets</span><br><span class="line">          0  physical reads</span><br><span class="line">       4456  redo size</span><br><span class="line">      27437  bytes sent via SQL*Net to client</span><br><span class="line">       1433  bytes received via SQL*Net from client</span><br><span class="line">         55  SQL*Net roundtrips to/from client</span><br><span class="line">          0  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">        800  rows processed</span><br></pre></td></tr></table></figure><p>同样的语句，相似记录的表，分区表的代价仅为129，逻辑读只有652，而普通表代价为1596，逻辑读为6019。<br>差别如此之大，和分区表查询只遍历了13个分区中的一个有关。在分区表查询的执行计划中看到p_start和p_stop都标记上2，表示只遍历了第2个分区。这样避开了对其余12个分区的查询。</p><p>下面来看组合分区相同语句的执行计划。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from range_list_part_tab where deal_date &gt;= TO_DATE(&#x27;2024-02-04&#x27;, &#x27;YYYY-MM-DD&#x27;) and deal_date &lt; TO_DATE(&#x27;2024-02-07&#x27;, &#x27;YYYY-MM-DD&#x27;);</span><br><span class="line"></span><br><span class="line">864 rows selected.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.30</span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 3813662781</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation              | Name                | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |</span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT       |                     |   692 |  1376K|   135   (2)| 00:00:01 |       |       |</span><br><span class="line">|   1 |  PARTITION RANGE SINGLE|                     |   692 |  1376K|   135   (2)| 00:00:01 |     2 |     2 |</span><br><span class="line">|   2 |   PARTITION LIST ALL   |                     |   692 |  1376K|   135   (2)| 00:00:01 |     1 |    10 |</span><br><span class="line">|*  3 |    TABLE ACCESS FULL   | RANGE_LIST_PART_TAB |   692 |  1376K|   135   (2)| 00:00:01 |    11 |    20 |</span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   3 - filter(&quot;DEAL_DATE&quot;&gt;=TO_DATE(&#x27; 2024-02-04 00:00:00&#x27;, &#x27;syyyy-mm-dd hh24:mi:ss&#x27;) AND</span><br><span class="line">              &quot;DEAL_DATE&quot;&lt;TO_DATE(&#x27; 2024-02-07 00:00:00&#x27;, &#x27;syyyy-mm-dd hh24:mi:ss&#x27;))</span><br><span class="line"></span><br><span class="line">Note</span><br><span class="line">-----</span><br><span class="line">   - dynamic statistics used: dynamic sampling (level=2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">         10  recursive calls</span><br><span class="line">          3  db block gets</span><br><span class="line">        803  consistent gets</span><br><span class="line">          0  physical reads</span><br><span class="line">        620  redo size</span><br><span class="line">      26324  bytes sent via SQL*Net to client</span><br><span class="line">       1533  bytes received via SQL*Net from client</span><br><span class="line">         59  SQL*Net roundtrips to/from client</span><br><span class="line">          0  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">        864  rows processed</span><br></pre></td></tr></table></figure><p>组合分区的代价为135，比范围分区稍高。按理说组合分区的粒度更细，代价应该更低才对，为什么呢？<br>是因为分区数过多，调用有开销。但由于这里表总记录不过10万，全表扫描开销都不是太大，这时Oracle内部调用的开销影响就相对较大。<br>如果表是一张超级大表，比如有上亿，那这些开销相比而言就可以忽略不计了。<br>所以分区表应用在大表会更合适。</p><h5 id="强大的分区操作"><a href="#强大的分区操作" class="headerlink" title="强大的分区操作"></a>强大的分区操作</h5><h6 id="分区-truncate"><a href="#分区-truncate" class="headerlink" title="分区 truncate"></a>分区 truncate</h6><p>delete无法释放空间，而truncate却有效地释放了空间。但可惜的是，针对普通表而言，truncate往往不能轻易使用，因为delete往往是针对某些条件的局部记录删除，而truncate显然不能带上条件，无法做到局部删除。<br>这时分区表就发挥作用了，Oracle可以实现只truncate某个分区，这就等同于实现了局部删除。</p><p><code>alter table range_part_tab truncate partition p9;</code> 删除分区表range_part_tab的p9分区</p><h6 id="分区数据转移"><a href="#分区数据转移" class="headerlink" title="分区数据转移"></a>分区数据转移</h6><p>关于分区表的历史记录的处理，其实是可以分成删除和转移两部分的，关于转移备份的方案，Oracle提供了一个非常棒的工具，就是分区交换，可以实现普通表和分区表的某个分区之间数据的相互交换，他们之间的交换非常快，基本上在瞬间就可以完成。<br><strong>实际上只是Oracle在内部数据字典做的一些小改动而已。</strong></p><p>命令：<code>alter table range_part_tab exchange partition p8 with table mid_table;</code> 不过要注意的一点是，这两张表的字段必须是完全一样的。<br>另外，exchange 是交换的含义，两个表的记录会互换，而不是覆盖。</p><h6 id="分区切割"><a href="#分区切割" class="headerlink" title="分区切割"></a>分区切割</h6><p><code>alter table range_part_tab split partition p_max at (TO_DATE(&#39;2024-02-01&#39;,&#39;YYYY-MM-DD&#39;)) into (PARTITION p2024_01,PARTITION P_MAX);</code></p><ol><li>分区切割的三个关键字是split、at&#x2F;values和into。</li><li>如果是RANGE类型的，at部分在此处说明了具体的范围，小于某个指定的值。如果是LIST类型的，使用values。</li><li>into 部分说明分区被切割成两个分区，比如 <code>into (PARTITION p2024_01,PARTITION P_MAX);</code> 表示将 P_MAX 切割成 PARTITION p2024_01 和 PARTITION P_MAX 两部分，其中括号里的 P_MAX 可以改为新的名字，也可以保留原来的名字。</li><li><strong>不能对HASH类型的分区进行拆分。</strong></li></ol><h6 id="分区合并"><a href="#分区合并" class="headerlink" title="分区合并"></a>分区合并</h6><p><code>alter table range_part_tab merge partitions p2024_02,p_max into partition p_max;</code></p><ol><li>分区合并的关键字是 merge 和 into。</li><li>merge 后面跟着的是需要合并的两个分区名。</li><li>into 部分为合并后的分区名，可以是新的分区名，也可以沿用已存在的分区名。</li><li>合并分区是将相邻的分区合并成一个分区，结果分区将采用较高分区的界限，值得注意的是，不能将分区合并到界限较低的分区。</li></ol><h6 id="分区的增与删"><a href="#分区的增与删" class="headerlink" title="分区的增与删"></a>分区的增与删</h6><p><code>alter table range_part_tab add partition p2025_01 values less than (TO_DATE(&#39;2025-02-01&#39;,&#39;YYYY-MM-DD&#39;));</code></p><p>上述语句可以增加分区，不过执行会报错：<code>ORA-14074: Partition Bound Must Collate Higher Than That Of The Last Partition</code><br>这是因为最后一个分区是<code>less than(maxvalue)</code>的情况下，是不能追加分区的，只能SPLIT分裂。<br>因为追加的分区界限比这个p_max还要低，显然不能允许。不过可以改成先试验分区删除，把这个p_max给删除了，然后追加自然就没问题了。</p><p><code>alter table range_part_tab drop partition p_max;</code></p><ol><li>分区增加的关键字是add partition，而分区别除的关键字是drop partition。</li><li>由于 max value 分区的存在，无法追加新的分区，必须删除了才可以追加。</li></ol><h4 id="分区索引类型"><a href="#分区索引类型" class="headerlink" title="分区索引类型"></a>分区索引类型</h4><h5 id="全局索引"><a href="#全局索引" class="headerlink" title="全局索引"></a>全局索引</h5><p>全局索引和普通的建索引无异，基本上可以理解为就是普通索引。</p><p><code>create index idx_part_tab_date on range_part_tab(deal_date);</code></p><h5 id="局部索引"><a href="#局部索引" class="headerlink" title="局部索引"></a>局部索引</h5><p>局部索引其实就是针对各个分区所建的索引。和局部索引相比，全局索引好比一个大索引，而局部索引好比13个小索引。</p><p><code>create index idx_part_tab_area on range_part_tab(area_code) local;</code></p><h4 id="分区表相关陷阱"><a href="#分区表相关陷阱" class="headerlink" title="分区表相关陷阱"></a>分区表相关陷阱</h4><h5 id="索引频频失效"><a href="#索引频频失效" class="headerlink" title="索引频频失效"></a>索引频频失效</h5><p>其中最容易出问题的当属分区表的不当操作导致分区索引失效，这些操作就是前面分区操作，这些动作全部都会导致分区索引中的全局索引失效。<br>以下是查看range_part_tab表的索引情况，其中STATUS是N&#x2F;A表示是局部索引，需要进一<br>步在user_ind partitions中分析其索引的状态，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查看索引情况，其中STATUS是N/A表示是局部索引，需要进一步在user_ind_partitions中分析其索引的状态</span><br><span class="line">select index_name, status</span><br><span class="line">from user_indexes</span><br><span class="line">where index_name in (&#x27;IDX_PART_TAB_DATE&#x27;, &#x27;IDX_PART_TAB_AREA&#x27;);</span><br><span class="line">-- 查看局部索引状态</span><br><span class="line">select index_name, partition_name, status</span><br><span class="line">from user_ind_partitions</span><br><span class="line">where index_name = &#x27;IDX_PART_TAB AREA&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>status USABLE 表示索引可用，UNUSABLE 表示索引不可用</p></blockquote><p>其实分区表的分区操作，对局部索引一般都没有影响，但是对全局索引影响比较大。Oracle 在提供这些分区操作时提供了一个很有用的参数 <code>update global indexes</code>,可以有效地避免全局索引失效。<br>其实这个参数的本质动作是在分区操作做完后，暗暗执行了索引重建的工作。使用方式：<code>alter table range_part_tab truncate partition p2 update global indexes;</code></p><h5 id="有索引反而效率更低"><a href="#有索引反而效率更低" class="headerlink" title="有索引反而效率更低"></a>有索引反而效率更低</h5><p>有时加上索引，分区表的查询效率反而不如普通表。<br>这个问题涉及索引的特性，<strong>就是索引的高度一般比较低。</strong><br>下一章索引里细说，下一章有整整136页。索引真是数据库一大知识点啊</p><h5 id="无法应用分区条件"><a href="#无法应用分区条件" class="headerlink" title="无法应用分区条件"></a>无法应用分区条件</h5><p>在分区设计时，往往没有预先规划好如何应用分区，这是很不应该的。<br>操作分区表时，应该用上分区条件，否则无法做到分区消除，这就浪费了分区表的宝贵特性，应该避免出现。<br><strong>有无分区条件性能差别很大。</strong></p><h3 id="有趣的索引组织表"><a href="#有趣的索引组织表" class="headerlink" title="有趣的索引组织表"></a>有趣的索引组织表</h3><p>普通堆表操作时，如果有用到索引，需要先从索引中获取rowid,然后定位到表中，获取id以外的其他列，这就是回表。<br>如果查询列含索引列以外的列，回表就不可避免。</p><p>分别建普通表和索引组织表并插入部分数据，其中的<code>organization index</code>关键字就是索引组织表的语法，<strong>索引组织表必须有主键</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">drop table heap_addresses purge;</span><br><span class="line">drop table iot_addresses purge;</span><br><span class="line">create table heap_addresses</span><br><span class="line">(</span><br><span class="line">    empno     number(10),</span><br><span class="line">    addr_type varchar2(10),</span><br><span class="line">    street    varchar2(10),</span><br><span class="line">    city      varchar2(10),</span><br><span class="line">    state     varchar2(2),</span><br><span class="line">    zip       number,</span><br><span class="line">    primary key (empno)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">create table iot_addresses</span><br><span class="line">(</span><br><span class="line">    empno     number(10),</span><br><span class="line">    addr_type varchar2(10),</span><br><span class="line">    street    varchar2(10),</span><br><span class="line">    city      varchar2(10),</span><br><span class="line">    state     varchar2(2),</span><br><span class="line">    zip       number,</span><br><span class="line">    primary key (empno)</span><br><span class="line">)</span><br><span class="line">    organization index</span><br><span class="line"></span><br><span class="line">insert into heap_addresses</span><br><span class="line">select object_id, &#x27;WORK&#x27;, &#x27;123street&#x27;, &#x27;washington&#x27;, &#x27;DC&#x27;, 20123</span><br><span class="line">from all_objects;</span><br><span class="line"></span><br><span class="line">insert into iot_addresses</span><br><span class="line">select object_id, &#x27;WORK&#x27;, &#x27;123street&#x27;, &#x27;washington&#x27;, &#x27;DC&#x27;, 20123</span><br><span class="line">from all_objects;</span><br></pre></td></tr></table></figure><p>下面是简单的查询性能比较。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from heap_addresses where empno = 22;</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.29</span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 128237854</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation                   | Name           | Rows  | Bytes | Cost (%CPU)| Time     |</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT            |                |     1 |    50 |     1   (0)| 00:00:01 |</span><br><span class="line">|   1 |  TABLE ACCESS BY INDEX ROWID| HEAP_ADDRESSES |     1 |    50 |     1   (0)| 00:00:01 |</span><br><span class="line">|*  2 |   INDEX UNIQUE SCAN         | SYS_C008415    |     1 |       |     1   (0)| 00:00:01 |</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   2 - access(&quot;EMPNO&quot;=22)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">          2  recursive calls</span><br><span class="line">          3  db block gets</span><br><span class="line">          7  consistent gets</span><br><span class="line">          0  physical reads</span><br><span class="line">        716  redo size</span><br><span class="line">        935  bytes sent via SQL*Net to client</span><br><span class="line">         83  bytes received via SQL*Net from client</span><br><span class="line">          1  SQL*Net roundtrips to/from client</span><br><span class="line">          0  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">          1  rows processed</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from iot_addresses where empno = 22;</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.33</span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 268113143</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation         | Name              | Rows  | Bytes | Cost (%CPU)| Time     |</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT  |                   |     1 |    50 |     1   (0)| 00:00:01 |</span><br><span class="line">|*  1 |  INDEX UNIQUE SCAN| SYS_IOT_TOP_72627 |     1 |    50 |     1   (0)| 00:00:01 |</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   1 - access(&quot;EMPNO&quot;=22)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">          1  recursive calls</span><br><span class="line">          0  db block gets</span><br><span class="line">          4  consistent gets</span><br><span class="line">          0  physical reads</span><br><span class="line">        140  redo size</span><br><span class="line">       1084  bytes sent via SQL*Net to client</span><br><span class="line">        108  bytes received via SQL*Net from client</span><br><span class="line">          2  SQL*Net roundtrips to/from client</span><br><span class="line">          0  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">          1  rows processed</span><br></pre></td></tr></table></figure><p>索引组织表的逻辑读是4而普通表的逻辑读是7，另外普通表读取主键索引后，为了获取索引列以外的列信息，产生了回表<code>TABLE ACCESS BY INDEX ROWID</code>，而索引组织表没有。<br><strong>索引组织表最大的特点就是，表就是索引，索引就是表，这是一种很特别的设计，所以无须访问表。</strong><br>不过这种设计的表的更新要比普通表开销更大。因为表要和索引一样有序地排列，更新负担将会非常严重。<br>因此这种设计一般适用在很少更新、频繁读的应用场合，比如配置表，这种表数据一般很少变动，却大量读取。</p><h3 id="簇表的介绍及应用"><a href="#簇表的介绍及应用" class="headerlink" title="簇表的介绍及应用"></a>簇表的介绍及应用</h3><p>普通表还有一点缺陷，就是ORDER BY语句中的排序不可避免。<br>实际上有序族表可以避免排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Drop table cust_orders;</span><br><span class="line">Drop cluster shc;</span><br><span class="line"></span><br><span class="line">CREATE CLUSTER shc</span><br><span class="line">(</span><br><span class="line">    cust_id NUMBER,</span><br><span class="line">    order_dt timestamp SORT</span><br><span class="line">)</span><br><span class="line">HASHKEYS 10000</span><br><span class="line">HASH IS cust_id</span><br><span class="line">SIZE 8192</span><br><span class="line"></span><br><span class="line">CREATE TABLE cust_orders</span><br><span class="line">(</span><br><span class="line">    cust_id      number,</span><br><span class="line">    order_dt     timestamp SORT,</span><br><span class="line">    order_number number,</span><br><span class="line">    username     varchar2(30),</span><br><span class="line">    ship_addr    number,</span><br><span class="line">    bill_addr    number,</span><br><span class="line">    invoice_num  number</span><br><span class="line">)</span><br><span class="line">    CLUSTER shc (cust_id, order_dt)</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; set autotrace traceonly explain</span><br><span class="line">SQL&gt; variable x number</span><br><span class="line">SQL&gt; select cust_id,order_dt,order_number from cust_orders where cust_id =:x order by order_dt;</span><br><span class="line">Elapsed: 00:00:00.31</span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 465084913</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">| Id  | Operation         | Name        | Rows  | Bytes | Cost (%CPU)|</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT  |             |     1 |    39 |     0   (0)|</span><br><span class="line">|*  1 |  TABLE ACCESS HASH| CUST_ORDERS |     1 |    39 |            |</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   1 - access(&quot;CUST_ID&quot;=TO_NUMBER(:X))</span><br><span class="line"></span><br><span class="line">Note</span><br><span class="line">-----</span><br><span class="line">   - dynamic statistics used: dynamic sampling (level=2)</span><br></pre></td></tr></table></figure><p>关于避免排序，还有另外一种方法，也是更常见的方法：排序列正好是索引列时，可避免排序。<br>关于索引避免排序这个知识，也会在下一章与索引相关的部分做详细的介绍。<br>簇表和索引组织表一样，由于结构的特殊导致更新操作开销非常大，所以也需要谨慎使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第四章-祝贺，表设计成就英雄&quot;&gt;&lt;a href=&quot;#第四章-祝贺，表设计成就英雄&quot; class=&quot;headerlink&quot; title=&quot;第四章 - 祝贺，表设计成就英雄&quot;&gt;&lt;/a&gt;第四章 - 祝贺，表设计成就英雄&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;普通堆表</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://cooooing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据库" scheme="https://cooooing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="《收获，不止Oracle》" scheme="https://cooooing.github.io/tags/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B/"/>
    
    <category term="Oracle" scheme="https://cooooing.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>《收获，不止Oracle》读书笔记上篇-逻辑体系</title>
    <link href="https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E9%80%BB%E8%BE%91%E4%BD%93%E7%B3%BB/"/>
    <id>https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E9%80%BB%E8%BE%91%E4%BD%93%E7%B3%BB/</id>
    <published>2024-07-28T06:07:40.000Z</published>
    <updated>2024-07-28T06:07:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-神奇，走进逻辑体系世界"><a href="#第三章-神奇，走进逻辑体系世界" class="headerlink" title="第三章 - 神奇，走进逻辑体系世界"></a>第三章 - 神奇，走进逻辑体系世界</h2><h3 id="逻辑体系结构"><a href="#逻辑体系结构" class="headerlink" title="逻辑体系结构"></a>逻辑体系结构</h3><p>上一章中讲的Oracle体系的物理结构都是一些看得见摸到着的东西。<br>登录数据库所在的主机，实实在在地体验了SGA共享内存段是如何被开辟而又如何消亡、后台进程是如何被唤起而又如何退出。<br>此外也清楚地看到了数据文件、参数文件、控制文件、日志文件、归档文件的大小及位置。<br>因此物理结构实质上可以理解为我们在物理上可以实实在在看得见的东西。</p><p>而这一章说的体系结构的逻辑结构正是从体系物理结构图中的数据文件部分展开描述的。<br>如下图圆圈标记处所示</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E9%80%BB%E8%BE%91%E4%BD%93%E7%B3%BB/%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E4%BB%8E%E6%AD%A4%E5%B1%95%E5%BC%80.png"                        alt="逻辑结构从此展开.png"                 ></p><p>这里数据文件是存放数据之处，也是数据库存在的根本！<br>下面介绍的逻辑结构是：表空间(TABLESPACE)、段(SEGMENT)、区(EXTENT)、块(BLOCK)。<br>ORACLE SERVER 正是条理地通过表空间以及段、区、块控制磁盘空间的合理高效的使用，看下图</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E9%80%BB%E8%BE%91%E4%BD%93%E7%B3%BB/%E4%BD%93%E7%B3%BB%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.png"                        alt="逻辑结构.png"                 ></p><p>数据库(DATABASE)由若干表空间(TABLESPACE)组成，表空间(TABLESPACE)由若干段(SEGMENT)组成，段(SEGMENT)由若干区(EXTENT)组成，区(EXTENT)又是由Oracle的最小单元块(BLOCK)组成的。<br>其中表空间又包含系统表空间、回滚段表空间、临时表空间、用户表空间。<br>除了用户表空间外其他三种表空间有各自特定的用途，不可随意更改和破坏，尤其是系统表空间更是需要小心谨慎保护。</p><blockquote><p>块 -&gt; 区 -&gt; 段 -&gt; 表空间 -&gt; 数据库</p></blockquote><p>刚才是从大说到小，现在按照从小到大的方向再将它们描述一遍。<br>一系列连续的BLOCK组成了EXTENT,一个或多个EXTENT组成了SEGMENT,一个或多个SEGMENT组成了TABLESPACE,而一个或多个TABLESPACE组成了DATABASE(一个DATABASE想存在，至少需要有SYSTEM及UNDO表空间)。</p><p>到这里还是十分的抽象，理解不了一点。<br>比如之前执行的 <code>update t set object_id=92 where object_id=29;</code> 这里的t表对应的就是逻辑结构，而数据则是写入数据文件 datafile 里。<br>面对表操作肯定比面对数据文件直观形象得多，这个表是就从数据文件里直观抽象出来的逻辑结构。</p><p>前面说到 Oracle 的逻辑结构从大到小分为表空间、段、区、数据库块这4部分。<br>上面建的表是和段(SEGMENT)直接对应。但是表并不是只对应一个段，有数据段和索引段。此外，如果表有分区，每个分区又都独立成段。</p><p>段(SEGMENT)是由区(EXTENT)组成的，而区又是由一系列数据块(BLOCK)组成的。<br>那么为什么要存在区呢？块是数据库的最小单位，为什么不直接由块组成段呢？</p><p>Oracle的这个区(EXTENT)的设计是为了避免过度扩展。<br>因为块的尺寸太小了，如果以这个块的尺寸为单位进行扩展，那么拓展会过于频繁，从而影响性能。</p><h4 id="块"><a href="#块" class="headerlink" title="块"></a>块</h4><p>虽然说<strong>BLOCK是Oracle的最小逻辑数据单位</strong>，但是所有数据在文件系统层面最小物理存储单位是字节，操作系统也有一个类似Oracle的块容量的参数(block size),但是Oracle总是访问整个Oracle BLOCK,而不是按照操作系统的block size来访问的。<br>一般情况下大多数操作系统OS的块容量为512字节大小或其整数倍，而数据库块一般默认设置为8KB,除此之外也有系统将其设置为2KB、4KB、16KB、32KB、64KB等其他大小。<br>但是数据库的BLOCK一般要设置为操作系统OS块容量的整数倍，这样可以减少IO操作。</p><p>这个很好理解，和操作系统内存管理的分页有些类似。<br>比如IO的大小设置为512字节(0.5KB),本来如果DB的BLOCK设置为1KB正好是其2倍。但是设置为0.8KB,这时由于操作系统的单个块大小为0.5KB,只有2个操作系统块才可容纳下，于是就动用了2个OS块去容纳，相当于占用了1KB大小的OS空间，浪费了0.2KB。</p><p>Oracle的数据库块并不是简单地往里插数据，插满了装不下了就插入另一个数据块这么简单，而是额外提供了一定的管理功能。<br>数据库的组成分为数据块头（包括标准内容和可变内容）(common and variable header)、表目录区(tabledirectory)、行目录区(row directory)、可用空间区(free space)、行数据区(row data)这5个部分，如下图：</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E9%80%BB%E8%BE%91%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE%E5%9D%97%E7%BB%93%E6%9E%84.png"                        alt="数据块结构.png"                 ></p><ol><li>数据块头(header)中包含了此数据块的概要信息，例如块地址(block address)及此数据块所属的段(segment)的类型（比如到底是表还是索引）。</li><li>表目录存放了块中行数据所在的表的信息。</li><li>行目录存放了插入的行的地址。</li><li>可用空间区就是块中的空余空间.这个空余的多少由Oracle的PCTFREE参数设置，如果是1O,表示该块将会空余10%左右的空间。此外如果是表或者索引块，该区域还会存储事务条目，大致有23字节左右开销。至于为什么要有空余，后面会有解释。</li><li>行数据区域就是存储具体的行的信息或者索引的信息，这部分占用了数据块绝大部分的空间。</li></ol><p>这里数据块头(data block header)、表目录区(table directory)、行目录区(row directory)被统称为管理开销(overhead),其中有些开销的容量是固定的，而有些开销的总容量是可变的。<br>数据块中固定及可变管理开销的容量平均在84到107字节(byte)之间。</p><h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>一些连续的数据块(data block)组合在一起，就形成了区(EXTENT)。<br><strong>EXTENT是Oracle数据库分配空间的最小单位</strong>，请注意分配这两个字眼。</p><p>当某用户创建一张表T时，实质就是建了一个数据段segment T。<br>在Oracle数据库中，<strong>只要segment创建成功，数据库就一定为其分配了包含若干数据块(data block)的初始数据扩展(initial extent)</strong>,即便此时表中还没数据，但是这些初始数据扩展中的数据块已经为即将插入的数据做好准备了。<br>接下来T表（也就是SEGMENT T)中开始插入数据，很快初始数据扩展中的数据块都装满了，而且又有新数据插入需要空间，此时Oracle会自动为这个段分配一个新增数据扩展(incremental extent),这个新增数据扩展是一个段中已有数据扩展之后分配的后续数据扩展，容量大于或等于之前的数据扩展。</p><p>每个段(segment)的定义中都包含了数据扩展(extent)的存储参数(storage parameter)。存储参数适用于各种类型的段。这个参数控制着Oracle如何为段分配可用空间。<br>例如，用户可以在CREATE TABLE语句中使用STORAGE子句设定存储参数，决定创建表时为其数据段(data segment)分配多少初始空间，或限定一个表最多可以包含多少数据扩展。<br>如果用户没有为表设定存储参数，那么表在创建时使用所在表空间(tablespace)的默认存储参数。</p><p>在一个本地管理的表空间中（注：还有一种数据字典管理的表空间，因为是一种要被淘汰的技术，这里就不提及了)，其中所分配的数据扩展(extent)的容量既可以是用户设定的固定值，也可以是由系统自动决定的可变值，取决于用户创建tablespace时用UNIFORM指令（固定大小）还是AUTOALLOCATE指令（由系统管理）。<br>对于固定容量(UNIFORM)的数据扩展，用户可以为数据扩展设定容量（比如100MB、1GB等随你设定)或使用默认大小(1MB)。用户必须确保每个数据扩展的容量至少能包含5个数据库块(database block)。<br>本地管理(locally managed)的临时表空间(temporary tablespace)在分配数据扩展时只能使用此种方式。<br>对于由系统管理(AUTOALLOCATE)的数据扩展，就无从插手干预了，Oracle或许一个区申请20M,下一个区忽然申请100M,Oracle在运行过程中自行决定新增数据扩展的最佳容量，我们无从得知规律。不过还是有一个下限的，即区的扩展过程中其最小容量不能低于64KB,假如数据块容量大于等于16KB,这个下限将从64KB转变为1MB。</p><h4 id="表空间分类"><a href="#表空间分类" class="headerlink" title="表空间分类"></a>表空间分类</h4><p>在 Oracle 数据库中，表空间（Tablespace）是组织和管理数据文件的逻辑容器。表空间是数据库中最大的逻辑存储单元，所有的数据库对象（如表、索引、回滚段等）都存储在表空间中。<br>Oracle 支持多种类型的表空间，每种类型有不同的用途和特点。</p><h5 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h5><p>系统表空间是数据库中默认创建的表空间之一，用于存储数据库的数据字典和其他重要元数据。</p><ul><li>包含数据库的数据字典信息，如表、视图、存储过程等。</li><li>包含数据库的控制信息。</li><li>通常不应用于存储用户数据。</li></ul><h5 id="临时表空间"><a href="#临时表空间" class="headerlink" title="临时表空间"></a>临时表空间</h5><p>临时表空间用于存储临时数据，如排序操作、临时表等。</p><ul><li>数据是非持久的，会在会话结束或事务提交后自动清除。</li><li>临时表空间中的数据文件称为临时文件（Temporary Files）。</li><li>通常用于支持临时表和排序操作。</li></ul><h5 id="回滚表空间"><a href="#回滚表空间" class="headerlink" title="回滚表空间"></a>回滚表空间</h5><p>回滚表空间用于存储事务回滚所需的信息。</p><ul><li>用于支持事务的回滚操作。</li><li>通常包含一个或多个数据文件。</li></ul><h3 id="逻辑结构初次体会"><a href="#逻辑结构初次体会" class="headerlink" title="逻辑结构初次体会"></a>逻辑结构初次体会</h3><p>上面都是概念性的东西，下面开始实操。</p><h4 id="Block-块"><a href="#Block-块" class="headerlink" title="Block 块"></a>Block 块</h4><p>查询数据库的块(BLOCK)大小为8KB,这是Oracle的最小逻辑单位。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; show parameters db_block_size;</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">db_block_size                        integer     8192</span><br></pre></td></tr></table></figure><p>也可以通过观察表空间视图 dba_tablespaces 的 block_size 值获取。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select block_size from dba_tablespaces where tablespace_name=&#x27;SYSTEM&#x27;;</span><br><span class="line"></span><br><span class="line">BLOCK_SIZE</span><br><span class="line">----------</span><br><span class="line">      8192</span><br></pre></td></tr></table></figure><h4 id="Tablespace-表空间"><a href="#Tablespace-表空间" class="headerlink" title="Tablespace 表空间"></a>Tablespace 表空间</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-- 创建普通数据表空间</span><br><span class="line">CREATE TABLESPACE &quot;test&quot;</span><br><span class="line">    DATAFILE &#x27;/opt/oracle/oradata/FREE/test.dbf&#x27;</span><br><span class="line">    SIZE 100M -- 数据文件的初始大小</span><br><span class="line">    AUTOEXTEND ON -- 允许数据文件自动扩展</span><br><span class="line"></span><br><span class="line">-- 创建临时表空间</span><br><span class="line">CREATE TEMPORARY TABLESPACE test_temp</span><br><span class="line">    TEMPFILE &#x27;/opt/oracle/oradata/FREE/test_temp.dbf&#x27;</span><br><span class="line">    SIZE 50M</span><br><span class="line">    AUTOEXTEND ON</span><br><span class="line"></span><br><span class="line">-- 创建回滚段表空间</span><br><span class="line">CREATE UNDO TABLESPACE test_undo</span><br><span class="line">    DATAFILE &#x27;/opt/oracle/oradata/FREE/test_undo.dbf&#x27;</span><br><span class="line">    SIZE 100M</span><br><span class="line">    AUTOEXTEND ON</span><br><span class="line"></span><br><span class="line">-- 系统表空间</span><br><span class="line">SELECT file_name,</span><br><span class="line">       tablespace_name,</span><br><span class="line">       autoextensible,</span><br><span class="line">       bytes / 1024 / 1024</span><br><span class="line">FROM DBA_DATA_FILES</span><br><span class="line">WHERE TABLESPACE_NAME LIKE &#x27;SYS%&#x27;</span><br><span class="line">order by substr(file_name, -12);</span><br></pre></td></tr></table></figure><p>系统表空间查询结果：</p><table><thead><tr><th>FILE_NAME</th><th>TABLESPACE_NAME</th><th>AUTOEXTENSIBLE</th><th>BYTES&#x2F;1024&#x2F;1024</th></tr></thead><tbody><tr><td>&#x2F;opt&#x2F;oracle&#x2F;oradata&#x2F;FREE&#x2F;sysaux01.dbf</td><td>SYSAUX</td><td>YES</td><td>1450</td></tr><tr><td>&#x2F;opt&#x2F;oracle&#x2F;oradata&#x2F;FREE&#x2F;system01.dbf</td><td>SYSTEM</td><td>YES</td><td>1090</td></tr></tbody></table><p>SYSAUX 表空间用于存储数据库的辅助数据，如索引组织表（Index Organized Tables, IOTs）、LOB 数据、数据字典视图快照等。它是 Oracle 10g 及以后版本引入的表空间，用于减轻 SYSTEM 表空间的压力。</p><blockquote><p>系统表空间和用户表空间属于永久保留数据的表空间。</p></blockquote><h4 id="User-用户"><a href="#User-用户" class="headerlink" title="User 用户"></a>User 用户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建用户</span><br><span class="line">drop user &quot;test&quot; cascade;</span><br><span class="line">create user &quot;test&quot;</span><br><span class="line">    identified by &quot;test_password&quot;</span><br><span class="line">    default tablespace &quot;test&quot;</span><br><span class="line">    temporary tablespace test_temp;</span><br><span class="line">-- 赋权</span><br><span class="line">grant dba to &quot;test&quot;;</span><br></pre></td></tr></table></figure><p>上述创建用户的命令会报错：<code>ORA-65096: 公用用户或角色名称必须以前缀 C## 开头</code><br>这是因为 Oracle Database 12c 引入了一项重要的新特性：多租户架构，其中包括容器数据库（CDB）和可插入数据库（PDB）。这项特性极大地改变了数据库管理的方式，提供了更好的资源隔离、简化了数据库部署和维护，并增强了安全性。<br>在书中并未这部分，可能作者使用的版本较低。所以这部分是查资料所得。</p><p>容器数据库（Container Database, CDB）是一个包含多个可插入数据库（Pluggable Databases, PDBs）的数据库。CDB 包括根容器（Root Container）和种子容器（Seed Container），以及一个或多个可插入数据库。</p><ul><li><strong>根容器</strong>：CDB 的根容器包含全局数据库对象和管理信息。根容器通常不包含用户数据。</li><li><strong>种子容器</strong>：CDB 的种子容器是一个特殊的 PDB，用于创建新的 PDB 时作为模板。每个 CDB 都有一个种子容器，通常命名为 <code>PDB$SEED</code>。</li></ul><p>可插入数据库（Pluggable Database, PDB）是 CDB 中的独立数据库环境，可以像传统的独立数据库一样使用，但它们共享同一套物理文件和资源。每个 PDB 都有自己的表空间、用户、角色、对象等。</p><ul><li><strong>独立性</strong>：每个 PDB 都是一个完整的数据库环境，拥有自己的表空间、用户、角色和数据。</li><li><strong>资源隔离</strong>：PDB 之间相互隔离，可以配置资源限制，以防止一个 PDB 影响其他 PDB 的性能。</li><li><strong>可移植性</strong>：PDB 可以轻松地在不同的 CDB 之间移动，甚至可以在不同的 Oracle 数据库版本之间移动。</li><li><strong>共享资源</strong>：尽管每个 PDB 都是独立的，但它们共享 CDB 的物理文件和资源，从而减少了管理开销和提高了资源利用率。</li></ul><p>使用 CDB 和 PDB 带来的好处</p><ul><li><strong>简化管理</strong>：通过将多个数据库作为 PDB 放入单个 CDB 中，可以大大简化数据库的管理。例如，补丁更新、备份和恢复等操作只需要在 CDB 层级执行即可。</li><li><strong>资源隔离</strong>：PDB 之间的资源可以被隔离，从而确保每个 PDB 都有稳定的资源使用环境。</li><li><strong>安全性增强</strong>：每个 PDB 都可以有自己的安全策略，从而增强了整个系统的安全性。</li><li><strong>成本节省</strong>：多个 PDB 共享 CDB 的资源，可以减少硬件成本和许可证费用。</li></ul><p>下面是相关的 sql 语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- 查看当前容器</span><br><span class="line">show con_name</span><br><span class="line">select sys_context(&#x27;USERENV&#x27;,&#x27;CON_NAME&#x27;) conname from dual;</span><br><span class="line"></span><br><span class="line">-- 查看PDB</span><br><span class="line">select con_id, dbid, name, open_mode from v$pdbs;</span><br><span class="line"></span><br><span class="line">-- 新建 PDB (PDB有多种创建方式，这里是通过PDB$SEED创建PDB。此外还有通过PDB创建PDB等多种方式，毕竟PDB是可插拔的，注定它的管理方式是多种多样的。)</span><br><span class="line">-- 其中 oracledb 是可插接式数据库名称，TEST_USER 是创建的该PDB的管理员用户，123456 是密码。file_name_convert 指定了文件名转换规则，用于将种子 PDB (PDB$SEED) 的数据文件路径转换为目标 PDB (oracledb) 的数据文件路径。</span><br><span class="line">create pluggable database oracledb admin user TEST_USER identified by 123456 file_name_convert = (&#x27;/opt/oracle/oradata/ORCLCDB/pdbseed&#x27;,&#x27;/opt/oracle/oradata/orclcdb/oracledb&#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建完成后的 PDB 数据库还不能直接使用，因为此时他的状态是 MOUNTED。使用下面的sql更改其状态。</span><br><span class="line">alter pluggable database oracledb open;</span><br><span class="line">alter pluggable database all open;</span><br><span class="line"></span><br><span class="line">-- 切换容器</span><br><span class="line">alter session set container=PDB$SEED;</span><br><span class="line">alter session set container=oracledb;</span><br></pre></td></tr></table></figure><p>创建完成之后，就可以使用新的用户连接到数据库里。<br><code>jdbc:oracle:thin:@//127.0.0.1:1521/oracledb</code></p><p>这里简单叙述下 PDB 和 CDB 的概念，和基本的用户创建。下面回到书中，继续体会逻辑结构。</p><h4 id="EXTENT-区"><a href="#EXTENT-区" class="headerlink" title="EXTENT 区"></a>EXTENT 区</h4><p><strong>Oracle的最小逻辑单位是块(BLOCK),而最小的扩展单位是区(EXTENT).</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 创建表 如果没有指定表空间，则使用该用户默认的表空间</span><br><span class="line">drop table t purge;</span><br><span class="line">create table t (id int) tablespace default_dataspace;</span><br><span class="line"></span><br><span class="line">-- 查询数据字典获取extent相关信息</span><br><span class="line">select segment_name,</span><br><span class="line">       extent_id,</span><br><span class="line">       tablespace_name,</span><br><span class="line">       bytes/1024/1024,blocks</span><br><span class="line">from user_extents</span><br><span class="line">where segment_name=&#x27;T&#x27;;</span><br></pre></td></tr></table></figure><p>插入 2000000 条数据后，有39个区。</p><table><thead><tr><th>SEGMENT_NAME</th><th>EXTENT_ID</th><th>TABLESPACE_NAME</th><th>BYTES&#x2F;1024&#x2F;1024</th><th>BLOCKS</th></tr></thead><tbody><tr><td>T</td><td>0</td><td>SYSTEM</td><td>0.0625</td><td>8</td></tr><tr><td>T</td><td>1</td><td>SYSTEM</td><td>0.0625</td><td>8</td></tr><tr><td>T</td><td>2</td><td>SYSTEM</td><td>0.0625</td><td>8</td></tr><tr><td>T</td><td>3</td><td>SYSTEM</td><td>0.0625</td><td>8</td></tr><tr><td>T</td><td>4</td><td>SYSTEM</td><td>0.0625</td><td>8</td></tr><tr><td>T</td><td>5</td><td>SYSTEM</td><td>0.0625</td><td>8</td></tr><tr><td>T</td><td>6</td><td>SYSTEM</td><td>0.0625</td><td>8</td></tr><tr><td>T</td><td>7</td><td>SYSTEM</td><td>0.0625</td><td>8</td></tr><tr><td>T</td><td>8</td><td>SYSTEM</td><td>0.0625</td><td>8</td></tr><tr><td>T</td><td>9</td><td>SYSTEM</td><td>0.0625</td><td>8</td></tr><tr><td>T</td><td>10</td><td>SYSTEM</td><td>0.0625</td><td>8</td></tr><tr><td>T</td><td>11</td><td>SYSTEM</td><td>0.0625</td><td>8</td></tr><tr><td>T</td><td>12</td><td>SYSTEM</td><td>0.0625</td><td>8</td></tr><tr><td>T</td><td>13</td><td>SYSTEM</td><td>0.0625</td><td>8</td></tr><tr><td>T</td><td>14</td><td>SYSTEM</td><td>0.0625</td><td>8</td></tr><tr><td>T</td><td>15</td><td>SYSTEM</td><td>0.0625</td><td>8</td></tr><tr><td>T</td><td>16</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>17</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>18</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>19</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>20</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>21</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>22</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>23</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>24</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>25</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>26</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>27</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>28</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>29</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>30</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>31</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>32</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>33</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>34</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>35</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>36</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>37</td><td>SYSTEM</td><td>1</td><td>128</td></tr><tr><td>T</td><td>38</td><td>SYSTEM</td><td>1</td><td>128</td></tr></tbody></table><h4 id="SEGMENT-段"><a href="#SEGMENT-段" class="headerlink" title="SEGMENT 段"></a>SEGMENT 段</h4><p>观察数据段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查询数据字典获取segment相关信息</span><br><span class="line">select segment_name,</span><br><span class="line">       segment_type,</span><br><span class="line">       tablespace_name,</span><br><span class="line">       blocks,</span><br><span class="line">       extents,bytes/1024/1024</span><br><span class="line">from user_segments</span><br><span class="line">where segment_name =&#x27;T&#x27;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>SEGMENT_NAME</th><th>SEGMENT_TYPE</th><th>TABLESPACE_NAME</th><th>BLOCKS</th><th>EXTENTS</th><th>BYTES&#x2F;1024&#x2F;1024</th></tr></thead><tbody><tr><td>T</td><td>TABLE</td><td>SYSTEM</td><td>3072</td><td>39</td><td>24</td></tr></tbody></table><p>2000000 条数据，占用了24M空间，用了39个区，3072个块。</p><p>观察索引段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 创建索引</span><br><span class="line">create index idx_id on t(id);</span><br><span class="line">-- 查询数据字典获取segment相关信息</span><br><span class="line">select segment_name,</span><br><span class="line">       segment_type,</span><br><span class="line">       tablespace_name,</span><br><span class="line">       blocks,</span><br><span class="line">       extents,</span><br><span class="line">       bytes/1024/1024</span><br><span class="line">from user_segments</span><br><span class="line">where segment_name =&#x27;IDX_ID&#x27;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>SEGMENT_NAME</th><th>SEGMENT_TYPE</th><th>TABLESPACE_NAME</th><th>BLOCKS</th><th>EXTENTS</th><th>BYTES&#x2F;1024&#x2F;1024</th></tr></thead><tbody><tr><td>IDX_ID</td><td>INDEX</td><td>SYSTEM</td><td>4608</td><td>51</td><td>36</td></tr></tbody></table><h3 id="逻辑结构二次体会"><a href="#逻辑结构二次体会" class="headerlink" title="逻辑结构二次体会"></a>逻辑结构二次体会</h3><h4 id="BLOCK的大小和调整"><a href="#BLOCK的大小和调整" class="headerlink" title="BLOCK的大小和调整"></a>BLOCK的大小和调整</h4><p>一般来说，Oracle默认的数据库块大小就是8KB,是在创建数据库时决定的，所以如果想改变块的大小，就必须在建库时指定。<br>Oracle9i以后的版本中，Oracle支持用户在新建用户表空间时指定块的大小，这意味着数据库有多个表空间，他们各自的BLOCK大小有可能各不相同。<br>切记只是新建的用户表空间，原有的已经建好的表空间是不可以更改的，系统表空间更不可能更改或调整。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; show parameters cache_size</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">client_result_cache_size             big integer 0</span><br><span class="line">data_transfer_cache_size             big integer 0</span><br><span class="line">db_16k_cache_size                    big integer 0</span><br><span class="line">db_2k_cache_size                     big integer 0</span><br><span class="line">db_32k_cache_size                    big integer 0</span><br><span class="line">db_4k_cache_size                     big integer 0</span><br><span class="line">db_8k_cache_size                     big integer 0</span><br><span class="line">db_cache_size                        big integer 0</span><br><span class="line">db_flash_cache_size                  big integer 0</span><br><span class="line">db_keep_cache_size                   big integer 0</span><br><span class="line">db_recycle_cache_size                big integer 0</span><br></pre></td></tr></table></figure><p>上面的参数意味着可以设置2KB、4KB、8KB、16KB、32KB的块大小。<br>如果将 db_16k_cache_size 设置为 1OOMB，就意味着SGA中的 DATA BUFFER 数据缓存区中将会有10OMB的大小让内存块可以以16KB的大小进行访问了，同时也意味着16KB大小的设置从此生效了。<br>然后建表空间，切记加上 <code>blocksize 16K</code> 的关键字即可。这里就不演示了。</p><h4 id="PCTFREE-参数、调整和生效范围"><a href="#PCTFREE-参数、调整和生效范围" class="headerlink" title="PCTFREE 参数、调整和生效范围"></a>PCTFREE 参数、调整和生效范围</h4><p>之前有说 BLOCK 块有一个FREE空间，是由PCTFREE参数决定的，设置这个参数来控制BLOCK保留一些空间。为什么要保留是之前留下的问题。<br>下面举例子来解答：<br>假如数据库中有某表T有900行记录，如果一个块最多可以装10行记录，最终需要90个块将T表记录装满。<br>如果PCTFREE为10，表示会预留10%的空间，那就是每个块都只能装9行数据，最终需要100个块才可以把T表记录装满。<br>这时做全表扫描的查询，查询T表的所有记录，如果PCTFREE设置为1O，将会遍历100个数据块。如果为0，将遍历90个数据块。<br>这种情况下，当然是PCTFREE设置为0的效率更高。<br>但是只有在只读数据库或者说只有插入删除很少更新的数据库环境中，才合适将PCTFREE设置为0。<br>预留的空间是为了更新操作。</p><p>有的表频繁更新，有的表几乎是只读的，从不更新。<br>所以不同类型的表就应该设置不同的PCTFREE，表在数据库中就是SEGMENT，因此PCTFREE这个参数其实是可以只针对某个具体段的系列区包含的BLOCK生效。<br>Oracle有一个默认的属性，就是PCTFREE&#x3D;1O，在整个数据库层面生效。<br>但是具体到建T表时，可以指定PCTFREE为别的值，比如20，那这个T表或者说SEGMENT T的所有块的属性，就是PCTFREE为20。</p><h4 id="EXTENT-尺寸与调整"><a href="#EXTENT-尺寸与调整" class="headerlink" title="EXTENT 尺寸与调整"></a>EXTENT 尺寸与调整</h4><p>区的大小是可以设置的，之前在区的逻辑结构中可以看到区的大小有时是0.0625MB(扩展8个块)，有时是1MB(128个块)，这是表空间区拓展大小设置的是自动拓展的缘故。<br>如果想要自定义，可以在创建表空间时添加 <code>uniform size 1OM</code> 的关键字，表示扩展是统一尺寸，大小都是1OMB。</p><h3 id="逻辑结构三次体会"><a href="#逻辑结构三次体会" class="headerlink" title="逻辑结构三次体会"></a>逻辑结构三次体会</h3><h4 id="以用和未用表空间情况"><a href="#以用和未用表空间情况" class="headerlink" title="以用和未用表空间情况"></a>以用和未用表空间情况</h4><p>查看表空间剩余情况</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select tablespace_name,sum(bytes)/1024/1024 from dba_free_space group by tablespace_name;</span><br><span class="line"></span><br><span class="line">TABLESPACE_NAME                SUM(BYTES)/1024/1024</span><br><span class="line">------------------------------ --------------------</span><br><span class="line">SYSTEM                                       2.4375</span><br><span class="line">SYSAUX                                      28.3125</span><br><span class="line">UNDOTBS1                                    92.3125</span><br></pre></td></tr></table></figure><p>查看表空间总体空间情况</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select tablespace_name,sum(bytes)/1024/1024 from dba_data_files group by tablespace_name;</span><br><span class="line"></span><br><span class="line">TABLESPACE_NAME                SUM(BYTES)/1024/1024</span><br><span class="line">------------------------------ --------------------</span><br><span class="line">SYSAUX                                          430</span><br><span class="line">SYSTEM                                          340</span><br><span class="line">UNDOTBS1                                        100</span><br></pre></td></tr></table></figure><h4 id="表空间大小和自动拓展"><a href="#表空间大小和自动拓展" class="headerlink" title="表空间大小和自动拓展"></a>表空间大小和自动拓展</h4><p>表空间没有开启自动拓展（AUTOEXTENSIBLE &#x3D; NO）或者开启了自动拓展但存储空间不够了，此时会报错：<strong>ORA-01654: 索引 XXX 无法通过 128 (在表空间 xxx 中) 扩展</strong></p><p>磁盘还有存储空间，但没有开启自动拓展导致表空间不足。<br>这时手动添加数据文件可以解决：<code>ALTER TABLESPACE TBS_UB ADD DATAFILE &#39;/opt/oracle/oradata/FREE/db02.dbf&#39;SIZE 100M;</code><br>或者开启自动拓展，让oracle自己拓展：<code>alter database datafile &#39;/opt/oracle/oradata/FREE/db02.dbf&#39;autoextend on;</code></p><p>磁盘不足导致表空间不足的话，可以考虑删除数据（数据是宝贵的，不建议删）或者添加硬件。<br><code>drop tablespace TBS_UB including contents and datafiles;</code> 其中 including contents and datafiles 表示要删除表空间的数据和对应的数据文件，如果表空间有数据，不增加 including contents 将无法删除成功。</p><h4 id="回滚表空间的新建与切换"><a href="#回滚表空间的新建与切换" class="headerlink" title="回滚表空间的新建与切换"></a>回滚表空间的新建与切换</h4><p>Oracle数据库建好后，UNDO表空间和TEMP表空间必然是建好了。但是实际情况是，回滚段和表空间都可以新建，并且用户都可以指定新建的空间。</p><p>查看数据库当前在用回滚段，数据库当前的回滚表空间名为UNDOTBS1:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; show parameters undo</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">temp_undo_enabled                    boolean     FALSE</span><br><span class="line">undo_management                      string      AUTO</span><br><span class="line">undo_retention                       integer     900</span><br><span class="line">undo_tablespace                      string      UNDOTBS1</span><br></pre></td></tr></table></figure><blockquote><p>其中 undo_management 的取值为 AUTO 表示是系统自动管理表空间而非手动管理。</p></blockquote><p>查看当前数据库有几个回滚段</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select tablespace_name,contents,status from dba_tablespaces where contents=&#x27;UNDO&#x27;;</span><br><span class="line"></span><br><span class="line">TABLESPACE_NAME                CONTENTS              STATUS</span><br><span class="line">------------------------------ --------------------- ---------</span><br><span class="line">UNDOTBS1                       UNDO                  ONLINE</span><br></pre></td></tr></table></figure><p>查看数据库回滚段的大小</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select tablespace_name,sum(bytes)/1024/1024 from dba_data_files where tablespace_name = &#x27;UNDOTBS1&#x27; group by tablespace_name;</span><br><span class="line"></span><br><span class="line">TABLESPACE_NAME                SUM(BYTES)/1024/1024</span><br><span class="line">------------------------------ --------------------</span><br><span class="line">UNDOTBS1                                        100</span><br></pre></td></tr></table></figure><p>切换回滚段的方法 <code>alter system set undo_tablespace=undotbs2 scope=both;</code> </p><blockquote><p>当前使用中的回滚段是无法被删除的<br>回滚表空间是真的可以新建多个，并且自由切换的，但是数据库当前使用的回滚表空间却只能有一个（注：RAC数据库会有多个）</p></blockquote><h4 id="临时表空间的新建和切换"><a href="#临时表空间的新建和切换" class="headerlink" title="临时表空间的新建和切换"></a>临时表空间的新建和切换</h4><p><strong>回滚表空间的特点是，数据库中可以建立多个，但是目前的在用表空间却只能有一个。而临时表空间在数据库中也可以建多个，却可以被同时使用。</strong></p><p>查看临时表空间大小</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select tablespace_name,sum(bytes)/1024/1024 from dba_temp_files group by tablespace_name;</span><br><span class="line"></span><br><span class="line">TABLESPACE_NAME                SUM(BYTES)/1024/1024</span><br><span class="line">------------------------------ --------------------</span><br><span class="line">TEMP                                             20</span><br></pre></td></tr></table></figure><p>查看用户默认表空间和临时表空间</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select DEFAULT_TABLESPACE,TEMPORARY_TABLESPACE,username from dba_users where username=&#x27;TEST_USER&#x27;;</span><br><span class="line"></span><br><span class="line">DEFAULT_TABLESPACE             TEMPORARY_TABLESPACE           USERNAME</span><br><span class="line">------------------------------ ------------------------------ --------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">SYSTEM                         TEMP                           TEST_USER</span><br></pre></td></tr></table></figure><p><code>alter user TEST_USER temporary tablespace TEMP02;</code> 指定用户切换临时表空间<br><code>alter database default temporary tablespace TEMP02;</code> 切换所有用户默认临时表空间</p><p>回滚段建多个的目的是可以瘦身，原先的回滚段一直扩展导致空间浪费太多，新建出来的小一点，切换成功后删除原来旧的回滚表空间，磁盘空间就空余出来了。<br>而临时表空间是为了避免竞争。Oracle可以为每个用户指定不同的临时表空间，每个临时表空间的数据文件都在磁盘的不同位置上，减少了IO竞争。<br>oracle还可以为统一用户不同session设置不同的临时表空间，进一步减少竞争。</p><p>实际上建临时表空间组很简单，只要新建一个临时表空间，然后加上 <code>tablespace group tmp_group</code> ,就默认建成了一个名为 tmp_group 的临时表空间组了。例如：<br><code>create tablespace tmp_group01 datafile &#39;/opt/oracle/oradata/FREE/tmp_group01.dbf&#39; size 100M tablespace group tmp_group;</code><br><code>create tablespace tmp_group02 datafile &#39;/opt/oracle/oradata/FREE/tmp_group02.dbf&#39; size 100M tablespace group tmp_group;</code><br><code>create tablespace tmp_group03 datafile &#39;/opt/oracle/oradata/FREE/tmp_group03.dbf&#39; size 100M tablespace group tmp_group;</code></p><p>查询临时表空间情况</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from dba_tablespace_groups;</span><br><span class="line"></span><br><span class="line">GROUP_NAME             TABLESPACE_NAME</span><br><span class="line">---------------------- ------------------------------</span><br><span class="line">TMP_GROUP              TMP_GROUP01                  </span><br><span class="line">TMP_GROUP              TMP_GROUP02                  </span><br><span class="line">TMP_GROUP              TMP_GROUP03                  </span><br></pre></td></tr></table></figure><p>指定某表空间移动到临时表空间组 <code>alter tablespace TMP_GROUP04 tablespace group TMP_GROUP;</code><br>使用 <code>alter user TEST_USER temporary tablespace TMP_GROUP;</code> 将用户切换到临时表空间组后。</p><p>虽然是同一用户登录的，但不同的SESSION都会自动分配到了不同的临时表空间。<br>同时，临时表空间组也可以分配多个。</p><p>临时表空间组可以往表空间组里不断新增临时表空间，让数据库在运行时自动从临时表空间组中选择各个临时表空间，不只是用户层面，而且是在SESSION层面进行IO均衡负载，极大地提升了数据库的性能。</p><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><h4 id="过度拓展与性能"><a href="#过度拓展与性能" class="headerlink" title="过度拓展与性能"></a>过度拓展与性能</h4><p>extent是Oracle数据库扩展的最小单位，而且大小是可以设置的。<br>如果某表（或者说某段）记录增长特别快，就可以考虑把这个EXTENT的大小设置得大一点，比如initial extent和incremental extent都设置比较大，这样申请扩展的次数就会减少，性能可以提高。</p><p>下面来做个实验：<br>首先建两个表空间，TBS_UB_A_01、TBS_UB_B_01，然后分别在两个表空间上建表。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; create tablespace TBS_UB_A datafile &#x27;/home/oracle/TBS_UB_A_01.DBF&#x27; size 10M autoextend on uniform size 64k;</span><br><span class="line"></span><br><span class="line">Tablespace created.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.59</span><br><span class="line">SQL&gt; create tablespace TBS_UB_B datafile &#x27;/home/oracle/TBS_UB_B_01.DBF&#x27; size 2G;</span><br><span class="line"></span><br><span class="line">Tablespace created.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:07.87</span><br><span class="line">SQL&gt; CREATE TABLE t_a (id int)tablespace TBS_UB_A;</span><br><span class="line"></span><br><span class="line">Table created.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.37</span><br><span class="line">SQL&gt; CREATE TABLE t_b (id int)tablespace TBS_UB_B;</span><br><span class="line"></span><br><span class="line">Table created.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.01</span><br></pre></td></tr></table></figure><p>上面创建表空间 TBS_UB_A 大小设置的为10M，想要模拟表空间不足，在大量拓展时的性能如何。书上设置的大小为1M。<br>这里可能由于版本原因，设置1M会报错：<code>ORA-03214: The specified file size is smaller than the minimum blocks 784.</code><br>表示尝试创建的数据文件的大小小于 Oracle 数据库要求的最小大小。因为 Oracle 数据库需要一定的空间来存储元数据和其他管理信息，即使数据文件为空。<br>接下来开始做试验，插入200万数据。分别插入两张表，观察耗时和拓展次数。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; insert into t_a select rownum from dual connect by level&lt;=2000000;</span><br><span class="line"></span><br><span class="line">2000000 rows created.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:01.47</span><br><span class="line">SQL&gt; insert into t_b select rownum from dual connect by level&lt;=2000000;</span><br><span class="line"></span><br><span class="line">2000000 rows created.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:01.64</span><br><span class="line"></span><br><span class="line">SQL&gt; select count(*)from user_extents where segment_name=&#x27;T_A&#x27;;</span><br><span class="line"></span><br><span class="line">  COUNT(*)</span><br><span class="line">----------</span><br><span class="line">       386</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.13</span><br><span class="line">SQL&gt; select count(*)from user_extents where segment_name=&#x27;T_B&#x27;;</span><br><span class="line"></span><br><span class="line">  COUNT(*)</span><br><span class="line">----------</span><br><span class="line">        40</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.13</span><br></pre></td></tr></table></figure><p>这里耗时差不多，但是拓展次数明显表空间小的更多。<br>这里与书上的结果不一致，可能是因为后续的oracle版本对这方面做了优化。不过不可否认的是，拓展的次数少了，少做事也是书中第一章的核心。</p><h4 id="PCTFREE-与性能"><a href="#PCTFREE-与性能" class="headerlink" title="PCTFREE 与性能"></a>PCTFREE 与性能</h4><p>PCTFREE 参数在 Oracle 数据库中用于控制数据块中可用空间的比例，以便在插入或更新数据时保留一定的空闲空间。<br>根据数据库对表更新的频繁程度，对表的 PCTFREE 做设置，避免和链式行产生行迁移，影响性能。</p><p>在 Oracle 数据库中，行迁移和链式行是与数据块管理和行更新相关的概念。当行更新导致其大小发生变化时，可能会发生这两种情况。</p><p><strong>行迁移</strong> 发生在更新行时，更新后的行大小超过了原来所在的块中的可用空间。当这种情况发生时，Oracle 数据库会尝试将更新后的行迁移到同一个数据块内的其他空闲空间中。如果在同一个数据块内找不到足够的空闲空间，Oracle 会尝试将行迁移到其他数据块中。</p><ul><li><strong>性能影响</strong>：行迁移可能导致数据块之间的数据碎片化，增加后续操作的 I&#x2F;O 成本。</li><li><strong>空间浪费</strong>：如果预留的空间不足以容纳更新后的行，可能会导致空间浪费。</li></ul><p><strong>链式行</strong> 发生在行迁移后仍然无法在一个数据块中容纳更新后的行的情况下。在这种情况下，Oracle 会将行分割成多个片段，并将这些片段分布在不同的数据块中。每个片段都会包含指向下一个片段的指针，形成一个链表。</p><ul><li><strong>性能影响</strong>：链式行会增加 I&#x2F;O 成本，因为每次读取或更新行时都需要访问多个数据块。</li><li><strong>空间浪费</strong>：链式行可能导致更多的空间浪费，因为每个片段都需要额外的空间来存储指向下一个片段的指针。</li></ul><p>优化的方法是：</p><ol><li><strong>使用 PCTFREE 参数</strong>：通过设置 <code>PCTFREE</code> 参数，可以在数据块中预留一定比例的空间，以便在行更新时有足够的空间来容纳更新后的行。</li><li><strong>调整数据块大小</strong>：根据数据的特点调整数据块大小，以减少行迁移和链式行的发生。</li><li><strong>合理设计表结构</strong>：合理设计表结构，例如使用变长列和定长列的组合，可以减少行大小的变化，从而降低行迁移和链式行的可能性。</li><li><strong>定期分析和优化表</strong>：定期执行 <code>ANALYZE</code> 和 <code>OPTIMIZE</code> 操作可以帮助减少数据碎片化。见文末。</li></ol><p>这里不进行实验了，简单描述下。（没有测试表，暂时先这样吧）<br>当表的字段类型由 varchar2(20) 改为 varchar2(2000)。这时，往表中填满这些字段，便会产生大量的行迁移。<br>此时，进行查询便会产生大量的逻辑读，导致性能的降低。<br>因为行迁移会导致数据在数据块间分布不均，造成数据碎片化。行链接也是一样，更新后的行无法在一个数据块中完全容纳，Oracle 会将行分割成多个片段，并将这些片段分布在不同的数据块中。每个片段都会包含指向下一个片段的指针，形成一个链表。<br>这都意味着在后续的查询或操作中，Oracle 需要从多个数据块中读取数据，增加了逻辑读的次数。<br><strong>消除行迁移的一个简单方法就是数据重建。<code>CREATE TABLE TABLE_NAME_BK AS select * from TABLE_NAME;</code></strong></p><h4 id="行迁移与优化"><a href="#行迁移与优化" class="headerlink" title="行迁移与优化"></a>行迁移与优化</h4><p>如何发现表存在行迁移？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 首先建chained_rows相关表，这是必需的步骤</span><br><span class="line">@?/rdbms/admin/utlchain.sql</span><br><span class="line">-- 以下命令针对T表做分析，将产生行迁移的记录插入到chained_rows表中</span><br><span class="line">analyze table t list chained rows into chained_rows;</span><br><span class="line">-- 通过分析结果可以看到具体哪条记录产生了行迁移</span><br><span class="line">select count(1) from chained_rows where table_name = &#x27;T&#x27;;</span><br></pre></td></tr></table></figure><p>通过这个方法可以了解到哪些表产生了严重的行迁移，可以适当做出改进。比如重建新表消除行迁移，然后对PCTFREE做适当的调整等。<br>下面可以对当前用户所有表做分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select &#x27;analyze table &#x27; || table_name || &#x27; list chained rows into chained_rows;&#x27; from user_tables;</span><br><span class="line">select * from chained_rows;</span><br></pre></td></tr></table></figure><p><a class="link"   href="https://docs.oracle.com/en/database/oracle/oracle-database/19/refrn/CHAINED_ROWS.html" >Oracle 官网 CHAINED_ROWS<i class="fas fa-external-link-alt"></i></a></p><h4 id="块的大小与应用"><a href="#块的大小与应用" class="headerlink" title="块的大小与应用"></a>块的大小与应用</h4><p>BLOCK除了谈这个PCTFREE属性外，还有本身设置多大的问题。有的系统设置8KB甚至4KB、2KB，而有的系统设置16KB甚至32KB大。<br>BLOCK是Oracle最小的单位。如果Oracle是单块读，则一次读取一个块，就是一个IO，当然如果是一次读取多个块，那还是算一个IO，这称之为多块读。<br>这里有一个问题，如果块越大，装的行记录就越多，那所需要的块就越少，换句话说，读取记录产生的IO就越少。那块越大越好吗？显然不可能这么极端。</p><p>实际情况是，对于数据仓库OLAP的数据库应用，一般倾向于BLOCK尽量大，而OLTP应用，一般倾向于BLOCK尽量不要太大。<br>OLAP和OLTP的差别在于，前者一般查询返回大量的数据，而后者查询返回极少量数据。前者一般用户不多，并发不大，后者一般用户很多，并发很大。<br>因此OLAP系统最多的查询方式应该是全表扫描，而OLTP系统最多的方式应该是索引读。</p><p>其中的原理主要是较大的块可以减少IO，同时提高缓存的命中率，可以提升全表扫描的性能。而较小的块每次IO操作涉及的数据量较小，可以降低锁的竞争，提高并发性能，同时较小的数据块也有助于提高索引的性能，因为索引通常涉及到随机访问，较小的数据块可以更快地定位到所需数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-- 准备两个表空间，块大小分别为8K和16K</span><br><span class="line">drop tablespace TBS_UB_8K INCLUDING CONTENTS AND DATAFILES;</span><br><span class="line">create tablespace TBS_UB_8K</span><br><span class="line">    blocksize 8K</span><br><span class="line">    datafile &#x27;/home/oracle/TBS_UB_8K_01.DBF&#x27;size 1G;</span><br><span class="line">drop tablespace TBS_UB_16K INCLUDING CONTENTS AND DATAFILES;</span><br><span class="line">create tablespace TBS_UB_16K</span><br><span class="line">    blocksize 16K</span><br><span class="line">    datafile &#x27;/home/oracle/TBS_UB_16k_01.DBF&#x27;size 1G;</span><br><span class="line">-- 在两个表空间上分别创建300万数据量的大表，并创建索引。</span><br><span class="line">drop table t_16k purge;</span><br><span class="line">create table t_16k tablespace tbs_ljb_16k as select * from dba_objects;</span><br><span class="line">insert into t_16k select * from t_16k;</span><br><span class="line">-- ...省略插入数据</span><br><span class="line">update t_16k set object_id = rownum;</span><br><span class="line">create index idx_object_id on t_16k (object_id);</span><br><span class="line">commit;</span><br><span class="line">-- ...t_8k 的创建过程同上，略</span><br><span class="line"></span><br><span class="line">-- 然后可以比较两个表在全表扫和索引的读下的性能了。</span><br><span class="line">-- 记得查看执行计划。</span><br><span class="line">select count(*) from t_8k;</span><br><span class="line">select count(*) from t_16k;</span><br><span class="line">select * from t_8k where object_id = 29;</span><br><span class="line">select * from t_16k where object_id = 29;</span><br></pre></td></tr></table></figure><p>书上的预期情况是 全表扫描的性能是大块有优势的，索引读的性能是不分上下的（可能块大小差别没那么大）。<br>最后这里没有实践，不知道Oracle后续版本有没有优化。</p><h2 id="ANALYZE-和-OPTIMIZE"><a href="#ANALYZE-和-OPTIMIZE" class="headerlink" title="ANALYZE 和 OPTIMIZE"></a>ANALYZE 和 OPTIMIZE</h2><p>在 Oracle 数据库中，定期执行 <code>ANALYZE</code> 和 <code>OPTIMIZE</code> 操作可以帮助减少数据碎片化，并保持统计信息的准确性，从而提高查询性能。<br>可以参考的文章 <a class="link"   href="https://www.cnblogs.com/maruidong/p/6410507.html" >Oracle表的分析统计<i class="fas fa-external-link-alt"></i></a><br><del>这部分好像很复杂啊</del></p><h3 id="ANALYZE-操作"><a href="#ANALYZE-操作" class="headerlink" title="ANALYZE 操作"></a>ANALYZE 操作</h3><p><code>ANALYZE</code> 操作用于收集表和索引的统计信息，这些信息用于优化器制定执行计划。通过定期执行 <code>ANALYZE</code>，可以确保优化器拥有最新的统计数据，从而选择最优的查询执行计划。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 分析表</span><br><span class="line">ANALYZE TABLE mytable COMPUTE STATISTICS;</span><br><span class="line"></span><br><span class="line">-- 分析索引</span><br><span class="line">ANALYZE INDEX myindex COMPUTE STATISTICS;</span><br></pre></td></tr></table></figure><h3 id="OPTIMIZE-操作"><a href="#OPTIMIZE-操作" class="headerlink" title="OPTIMIZE 操作"></a>OPTIMIZE 操作</h3><p><code>OPTIMIZE</code> 操作用于重新组织索引，减少碎片并提高索引的效率。对于 B 树索引，<code>OPTIMIZE</code> 操作会压缩索引，减少索引占用的空间并提高查询性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 优化索引</span><br><span class="line">ALTER INDEX myindex REBUILD;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p><strong>性能影响</strong>：执行 <code>ANALYZE</code> 和 <code>OPTIMIZE</code> 操作可能会对数据库性能产生影响，尤其是在大型表和索引上。因此，通常建议在非高峰时段执行这些操作。</p></li><li><p><strong>资源消耗</strong>：这些操作可能会消耗较多的 CPU 和 I&#x2F;O 资源。在执行之前，请确保有足够的资源可用。</p></li><li><p><strong>备份</strong>：在执行 <code>REBUILD</code> 操作之前，建议先备份索引，以防万一出现问题。</p></li><li><p><strong>定期执行</strong>：根据表的使用频率和数据变化情况，定期执行 <code>ANALYZE</code> 和 <code>OPTIMIZE</code> 操作。</p></li><li><p><strong>数据大量更新后</strong>：在对表进行了大量插入、删除或更新操作后，执行 <code>ANALYZE</code> 和 <code>OPTIMIZE</code> 可以帮助减少数据碎片化并更新统计信息。</p></li></ul><p>也可以使用 DBMS_STATS 包查看和修改为数据库对象收集的优化器统计信息。<br><a class="link"   href="https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/DBMS_STATS.html#GUID-01FAB8ED-E4A3-4C3E-8FE2-88717DCDDA06" >Oracle 官方文档 DBMS_STATS<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第三章-神奇，走进逻辑体系世界&quot;&gt;&lt;a href=&quot;#第三章-神奇，走进逻辑体系世界&quot; class=&quot;headerlink&quot; title=&quot;第三章 - 神奇，走进逻辑体系世界&quot;&gt;&lt;/a&gt;第三章 - 神奇，走进逻辑体系世界&lt;/h2&gt;&lt;h3 id=&quot;逻辑体系结构&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://cooooing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据库" scheme="https://cooooing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="《收获，不止Oracle》" scheme="https://cooooing.github.io/tags/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B/"/>
    
    <category term="Oracle" scheme="https://cooooing.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>孤独的根号三</title>
    <link href="https://cooooing.github.io/%E5%85%B6%E4%BB%96/%E5%AD%A4%E7%8B%AC%E7%9A%84%E6%A0%B9%E5%8F%B7%E4%B8%89/"/>
    <id>https://cooooing.github.io/%E5%85%B6%E4%BB%96/%E5%AD%A4%E7%8B%AC%E7%9A%84%E6%A0%B9%E5%8F%B7%E4%B8%89/</id>
    <published>2024-07-14T05:43:44.000Z</published>
    <updated>2024-07-14T05:43:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>作品名称孤独的根号三<br>外文名TheSquareRootofThree<br>作者DavidFeinberg<br>创作年代2008年</p><h2 id="英文"><a href="#英文" class="headerlink" title="英文"></a>英文</h2><p>I fear that I will always be A lonely number like root three<br>A three is all that’s good and right<br>Why must my three keep out of sight Beneath a vicious square-root sign?<br>I wish instead I were a nine<br>For nine could thwart this evil trick With just some quick arithmetic<br>I know I’ll never see the sun<br>As 1.7321<br>Such is my reality A sad irrationality<br>When,hark, just what is this I see?<br>Another square root of a three<br>Has quietly come waltzing by<br>Together now we multiply<br>To form a number we prefer<br>Rejoicing as an integer<br>We break free from our mortal bonds<br>And with a wave of magic wands<br>Our square-root signs become unglued<br>And love for me has been renewed<br>I can’t promise you the kind of lifestyle that fairy tale like<br>And I can’t promise you that I’m gonna mature overnight<br>But what I can promise you is that I will always love you<br>And I will never try and make you into something that you can not</p><h2 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h2><p>我害怕<br>我会永远是那孤独的根号三<br>三本身是一个多么美妙的数字<br>我的这个三<br>为何躲在那难看的根号下<br>我多么希望自己是一个九<br>因为九只需要一点点小小的运算<br>便可摆脱这残酷的厄运<br>我知道自己很难再看到自己的太阳<br>就像这无休无止的1.7321<br>我不愿我的人生如此可悲<br>直到那一天<br>我看到了<br>另一个根号三<br>如此美丽无瑕<br>翩翩舞动而来<br>我们彼此相乘<br>得到那梦寐以求的数字<br>像整数一样圆满<br>我们砸碎命运的枷锁<br>轻轻舞动爱情的魔杖<br>我们的平方根 已经解开<br>我的爱重获新生<br>我无法保证能给你童话般的世界<br>也无法保证自己能在一夜之间长大<br>但是我保证<br>你可以向公主一样永远生活在<br>自由 幸福之中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;作者&quot;&gt;&lt;a href=&quot;#作者&quot; class=&quot;headerlink&quot; title=&quot;作者&quot;&gt;&lt;/a&gt;作者&lt;/h2&gt;&lt;p&gt;作品名称	孤独的根号三&lt;br&gt;外文名	TheSquareRootofThree&lt;br&gt;作者		DavidFeinberg&lt;br&gt;创作年代	2</summary>
      
    
    
    
    <category term="其他" scheme="https://cooooing.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="诗歌" scheme="https://cooooing.github.io/tags/%E8%AF%97%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title>《收获，不止Oracle》读书笔记上篇-开始和物理体系</title>
    <link href="https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E5%BC%80%E5%A7%8B%E5%92%8C%E7%89%A9%E7%90%86%E4%BD%93%E7%B3%BB/"/>
    <id>https://cooooing.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E5%BC%80%E5%A7%8B%E5%92%8C%E7%89%A9%E7%90%86%E4%BD%93%E7%B3%BB/</id>
    <published>2024-07-11T02:31:50.000Z</published>
    <updated>2024-07-11T02:31:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于想深入了解下数据库，包括索引、分区表以及sql优化相关的知识，加上工作使用的是 Oracle 数据库。所以选择这本书开始学习。<br>最开始看的时候，已经看了四章了。但是不做笔记，总是看了后面忘了前面，所以决定重读并且记笔记。主要及一些重点，方便以后查阅和回忆。<br>（当然，可能会有很多引用原文的部分，也会有自己的总结。引用的部分就不一一标注了，不过基本也能看出来）</p><h2 id="第一章-意识，少做事从学习开始"><a href="#第一章-意识，少做事从学习开始" class="headerlink" title="第一章 - 意识，少做事从学习开始"></a>第一章 - 意识，少做事从学习开始</h2><p>这一章的重点就是，<strong>学什么要先了解做什么</strong>。学了没想过怎么用，或者干脆不用，基本上是白学的。<br>先讲下数据库应用的基本功能，再根据具体的角色（DBA、开发、运维等）看具体该如何使用，根据使用的侧重点不同，而对数据库不同进行深度的学习。<br>毕竟数据库体系是庞大的，想要全盘掌握不现实，也不必要。按需学习即可。</p><p>这里作者是以手机的例子，加以二八现象说明。即百分之二十的功能实现百分之八十的需求，数据库也是一样。<br>对于开发人员来说，首先应该了解 SQL 的编写，而不是数据库的备份和恢复。而对于运维或者DBA来说，了解数据库的备份和恢复则更为重要。</p><p>首先，数据库应用的功能主要分为 数据库开发、数据库管理、数据库优化、数据库设计 四类（当然只是大概）。侧重点如下：</p><ol><li>开发：能利用SQL完成数据库的查增删改的基本操作：能用PL&#x2F;SQL完成及各类逻辑的实现。</li><li>管理：能完成数据库的安装、部署、参数调试、备份恢复、数据迁移等系统相关的工作：能完成分配用户、控制权限、表空间划分等管理相关工作：能进行故障定位、问题分析等数据库诊断修复相关工作。</li><li>优化：在深入了解数据库的运行原理的基础上，利用各类工具及手段发现并解决数据库存在的性能问题，从而提升数据库运行效率，这个说着轻巧，其实很不容易。</li><li>设计：深刻理解业务需求和数据库原理，合理高效地完成数据库模型的建设，设计出各类表及索引等数据库对象，让后续应用开发可以高效稳定。</li></ol><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E5%BC%80%E5%A7%8B%E5%92%8C%E7%89%A9%E7%90%86%E4%BD%93%E7%B3%BB/%E5%90%84%E8%A7%92%E8%89%B2%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86%E8%A6%81%E7%82%B9.png"                        alt="各角色需要掌握的知识要点.png"                 ></p><p>我的角色目前是开发，后续笔记中也会侧重于开发的内容。除此之外，也会带一些我感兴趣的内容。</p><h2 id="第二章-震惊，体验物理体系之旅"><a href="#第二章-震惊，体验物理体系之旅" class="headerlink" title="第二章 - 震惊，体验物理体系之旅"></a>第二章 - 震惊，体验物理体系之旅</h2><p>不论什么角色，基础原理都是必学的。首先就是物理体系结构，平时遇到的各种数据库相关问题，很多都可以从中找到解决方法。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E5%BC%80%E5%A7%8B%E5%92%8C%E7%89%A9%E7%90%86%E4%BD%93%E7%B3%BB/Oracle%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png"                        alt="Oracle体系结构图.png"                 ></p><ol><li><strong>Oracle由实例和数据库组成</strong>，我特意用两个虚框标记出来，上半部的直角方框为实例instance,下半部的圆角方框为数据库Database,大家可以看到我在虚线框左上角做的标注。</li><li><strong>实例是由一个开辟的共享内存区SGA(System Global Area)和一系列后台进程组成的</strong>，其中<strong>SGA最主要被划分为共享池(shared pool)、数据缓存区(db cache)和日志缓存(log buffer)三类</strong>。后台进程包括图2-2中所示的PMON、SMON、LCKn、RECO、CKPT、DBWR、LGWR、ARCH等系列进程。</li><li>数据库是由数据文件、参数文件、日志文件、控制文件、归档日志文件等系列文件组成的，其中归档日志最终可能会被转移到新的存储介质中，用于备份恢复使用。大家请注意看图2-2中的圆形虚线框标记部分的一个细节，<strong>PGA(Program Global Area)区，这也是一块开辟出来的内存区，和SGA最明显的差别在于，PGA不是共享内存，是私有不共亨的</strong>，S理解为共享的首字母。用户对数据库发起的无论查询还是更新的任何操作，都是在PGA先预处理，然后接下来才进入实例区域，由SGA和系列后台进程共同完成用户发起的请求。</li><li>PGA起到的其体作用，也就是前面说的预处理，是什么呢？主要有三点：第一，保存用户的连接信息，如会话属性、绑定变量等：第二，保存用户权限等重要信息，当用户进程与数据库建立会话时，系统会将这个用户的相关权限查询出来，然后保存在这个会话区内：第三，当发起的指令需要排序的时候，PGA(Program Global Area)正是这个排序区，如果在内存中可以放下排序的尺寸，就在内存PGA区内完成，如果放不下，超出的部分就在临时表空间中完成排序，也就是在磁盘中完成排序。</li><li>我在图中标识了三块区域（大家注意看虚线框的左下角标注），分别是1区圆形虚线框，2区直角方形虚线框，3区圆角方形虚线框。用户的请求发起经历的顺序一般如下：1区→2区→3区：或者1区→2区。</li></ol><p>从这个体系结构可以提出一些问题，提问很重要！</p><ol><li>为什么会有用户的请求不经过3区数据库的情况，直接从2区实例返回了？</li><li>为什么SGA要划分为共享池、数据缓存区、日志缓存区，它们的作用分别是什么？</li><li>为什么数据量大时排序会导致sql执行非常缓慢？（这个问题从上面的体系结构中显而易见）</li></ol><h3 id="从普通查询-sql-开始"><a href="#从普通查询-sql-开始" class="headerlink" title="从普通查询 sql 开始"></a>从普通查询 sql 开始</h3><p>从简单的查询sql <code>select object_name from t where object_id=29;</code> 开始。<br>当用户发起这个sql指令后，首先会从1区开始做准备。</p><p>PGA区域是仅供当前发起用户使用的私有内存空间，这个区域有三个作用，但这里的连接只完成了<strong>用户连接信息的保存和q权限的保存</strong>。只要该session不断开连接，下次便可以直接从PGA中获取，而不用去硬盘中读取数据。<br>此外，该sql还会匹配成一条唯一的HASH值，然后进入2区域。首先进入SGA区的共享池。<br>进入共享池后，先查询是否有地方存储过这个sql（HASH值，唯一标识一个sql）。</p><p>如果没有，那首先就要查询这个sql语法是否正确（from是否写成form），语义是否正确（字段、表是否存在），是否有权限。都没问题则会生成唯一HASH并保存。<br>接下来开始解析，看是否有索引，是索引读高效还是全表扫描高效？oracle要做出抉择。</p><p>如何做出抉择？将两种方式都估算一下，看那个代价（COST）更低。这里比较并不会真正分别执行两次来比较，具体方法后文会有。将代价更低的执行计划保存起来，并于HASH对应起来。<br>有了执行计划之后，便来到数据缓存区来查询数据了。当数据缓存区找不到需要的数据时，便会去3区的数据库中查找，当然得按照执行计划来，这是圣旨，不可违抗。找到后，回到数据缓存区返回，找不到，就找不到了。</p><ol><li>这里2区中的日志缓存区并没有说到</li><li>3区也只描述了一个数据文件，其他文件并没有被提及</li><li>2区中除了SGA，还有很多进程，他们的作用也没有被提及</li></ol><p>下面开始实践，可以先跳至文末，搭建Oracle的环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">drop table t;</span><br><span class="line">create table t as</span><br><span class="line">select *</span><br><span class="line">from all_objects;</span><br><span class="line">create index idx_object_id on t (object_id);</span><br><span class="line">-- 跟踪SQL的执行计划和执行的统计信息</span><br><span class="line">set autotrace on</span><br><span class="line">-- 设置查询结果在屏幕上显示时每行的最大字符数，使得查询结果不被截断，提高可读性</span><br><span class="line">set linesize 1000</span><br><span class="line">-- 跟踪该语句执行完成的时间</span><br><span class="line">set timing on</span><br><span class="line">select object_name</span><br><span class="line">from t</span><br><span class="line">where object_id = 29;</span><br></pre></td></tr></table></figure><p>第一次查询结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select object_name from t where object_id = 29;</span><br><span class="line"></span><br><span class="line">OBJECT_NAME</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">C_COBJ#</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.67</span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 1296629646</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation                           | Name          | Rows  | Bytes | Cost (%CPU)| Time     |</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT                    |               |     1 |    79 |     2   (0)| 00:00:01 |</span><br><span class="line">|   1 |  TABLE ACCESS BY INDEX ROWID BATCHED| T             |     1 |    79 |     2   (0)| 00:00:01 |</span><br><span class="line">|*  2 |   INDEX RANGE SCAN                  | IDX_OBJECT_ID |     1 |       |     1   (0)| 00:00:01 |</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   2 - access(&quot;OBJECT_ID&quot;=29)</span><br><span class="line"></span><br><span class="line">Note</span><br><span class="line">-----</span><br><span class="line">   - dynamic statistics used: dynamic sampling (level=2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">         11  recursive calls</span><br><span class="line">          0  db block gets</span><br><span class="line">         83  consistent gets</span><br><span class="line">          1  physical reads</span><br><span class="line">          0  redo size</span><br><span class="line">        594  bytes sent via SQL*Net to client</span><br><span class="line">        108  bytes received via SQL*Net from client</span><br><span class="line">          2  SQL*Net roundtrips to/from client</span><br><span class="line">          0  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">          1  rows processed</span><br></pre></td></tr></table></figure><p>第二次查询结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select object_name from t where object_id = 29;</span><br><span class="line"></span><br><span class="line">OBJECT_NAME</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">C_COBJ#</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.27</span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 1296629646</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation                           | Name          | Rows  | Bytes | Cost (%CPU)| Time     |</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT                    |               |     1 |    79 |     2   (0)| 00:00:01 |</span><br><span class="line">|   1 |  TABLE ACCESS BY INDEX ROWID BATCHED| T             |     1 |    79 |     2   (0)| 00:00:01 |</span><br><span class="line">|*  2 |   INDEX RANGE SCAN                  | IDX_OBJECT_ID |     1 |       |     1   (0)| 00:00:01 |</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   2 - access(&quot;OBJECT_ID&quot;=29)</span><br><span class="line"></span><br><span class="line">Note</span><br><span class="line">-----</span><br><span class="line">   - dynamic statistics used: dynamic sampling (level=2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">          0  recursive calls</span><br><span class="line">          0  db block gets</span><br><span class="line">          4  consistent gets</span><br><span class="line">          0  physical reads</span><br><span class="line">          0  redo size</span><br><span class="line">        594  bytes sent via SQL*Net to client</span><br><span class="line">        108  bytes received via SQL*Net from client</span><br><span class="line">          2  SQL*Net roundtrips to/from client</span><br><span class="line">          0  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">          1  rows processed</span><br></pre></td></tr></table></figure><p>先简单介绍下统计信息中各个信息的含义：</p><ul><li>Recursive Calls: 表示查询执行期间数据库内部发生的递归调用次数，这可能包括子查询、视图的重写以及其他内部处理所需的多次查询执行。</li><li>DB Block Gets: 指从数据库缓存区中读取数据块的次数，反映的是从内存中获取数据的频率。</li><li>Consistent Gets: 代表为维护数据一致性而从数据库缓存中获取数据块的次数。这在读一致性要求高的查询中尤为重要，确保查询看到的是事务开始那一刻的数据版本。</li><li>Physical Reads: 指从磁盘上实际读取数据块的次数，发生物理读取通常意味着所需数据未在数据库缓存区中找到，需要从持久存储中加载。</li><li>Redo Size: 记录由于本次操作产生的重做日志大小，单位通常是字节。重做日志用于事务恢复。</li><li>Bytes Sent via SQL<em>Net to Client: 通过SQL</em>Net网络协议发送到客户端的数据量，包括查询结果集等信息。</li><li>Bytes Received via SQL<em>Net from Client: 通过SQL</em>Net网络协议从客户端接收的数据量，主要涉及客户端发送的查询请求等。</li><li>SQL*Net Roundtrips to&#x2F;from Client: 完成查询操作所需的客户端与服务器之间的网络往返次数，每次往返可能涉及请求或响应。</li><li>Sorts (Memory): 在内存中执行的排序操作次数，用于组织数据以便于高效查询或显示。</li><li>Sorts (Disk):当内存不足，需要使用临时表空间在磁盘上进行排序操作的次数，这通常比内存排序效率低。</li><li>Rows Processed: 查询最终处理的行数，即查询结果集中包含的行数。</li></ul><p>第一次执行花费0.67秒，第二次只花费了0.27秒。比第一次快了很多<br>接下来是统计信息的差别<br>第一次执行，产生了11次递归调用、83次逻辑读、1次物理读<br>第二次执行，产生了0次递归调用、4次逻辑读、0次物理读</p><p>下面是描述两次执行的差异：</p><ol><li>用户首次执行该SQL指令时，该指令从磁盘中获取用户连接信息和相关权限信息权限，并保存在PGA内存里。当用户再次执行该指令时，由于SESSION之前未被断开重连，连接信息和相关权限信息就可以在PGA内存中直接获取，避免了物理读。</li><li>首次执行该SQL指令结束后，SGA内存区的共享池里已经保存了该SQL唯一指令HASH值，并保留了语法语意检查及执行计划等相关解析动作的劳动成果，当再次执行该$QL时，由于该SQL指令的HASH值和共享池里保存的相匹配了，所以之前的硬解析动作就无须再做，不仅跳过了相关语法语意检查，对于该选取哪种执行计划也无须考虑，直接拿来主义就好了。</li><li>首次执行该SQL指令时，数据一般不在SGA的数据缓存区里（除非被别的SQL读入内存了)，只能从磁盘中获取，不可避免地产生了物理读，但是由于获取后会保存在数据缓存区里，再次执行就直接从数据缓存区里获取了，完全避免了物理读，就像上面的实践一样，首次执行物理读为4，第2次执行的物理读为0，没有物理读，数据全在缓存中，效率当然高得多！</li></ol><p>即，不用获取用户和权限相关信息、不用进行语法检查和执行计划等相关解析、不用从磁盘获取直接从缓存获取。</p><h3 id="体会Oracle的代价"><a href="#体会Oracle的代价" class="headerlink" title="体会Oracle的代价"></a>体会Oracle的代价</h3><p>在表有索引的情况下，Oracle可以选择索引读，也可以选择全表扫描，这是两种截然不同的执行计划，不见得一定是索引读胜过全表扫，有时索引读的效率会比全表扫更低<br>所以Oracle的选择不是看是啥执行计划，而是判断谁的代价更低。<br>下面来比较下两者的代价</p><p>这里会使用 HINT 的写法。HINT是一种强制写法，让数据库的查询优化器遵循某种特定的执行路径或采用特定的算法来处理查询。详细的介绍，放在文末。<br>使用 <code>/*+full(t)*/</code> 的写法，来强制该sql不走索引，走全表扫描。如下：<br><code>select /*+full(t)*/object_name from t where object_id = 29;</code></p><blockquote><p>多次执行同一个SQL查询，可以解析次数减少、物理读减少甚至递归调用次数</p></blockquote><p>下面是走全表扫描的执行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select /*+full(t)*/object_name from t where object_id = 29;</span><br><span class="line"></span><br><span class="line">OBJECT_NAME</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">C_COBJ#</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.03</span><br><span class="line"></span><br><span class="line">Execution Plan</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Plan hash value: 1601196873</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">| Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     |</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">|   0 | SELECT STATEMENT  |      |     1 |    44 |   410   (0)| 00:00:01 |</span><br><span class="line">|*  1 |  TABLE ACCESS FULL| T    |     1 |    44 |   410   (0)| 00:00:01 |</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Predicate Information (identified by operation id):</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">   1 - filter(&quot;OBJECT_ID&quot;=29)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">          0  recursive calls</span><br><span class="line">          0  db block gets</span><br><span class="line">       1514  consistent gets</span><br><span class="line">          0  physical reads</span><br><span class="line">          0  redo size</span><br><span class="line">        594  bytes sent via SQL*Net to client</span><br><span class="line">        108  bytes received via SQL*Net from client</span><br><span class="line">          2  SQL*Net roundtrips to/from client</span><br><span class="line">          0  sorts (memory)</span><br><span class="line">          0  sorts (disk)</span><br><span class="line">          1  rows processed</span><br></pre></td></tr></table></figure><p>比较走全表扫描和oracle自己选择的使用索引的方式的执行计划和统计信息，发现代价（Cost）410远大于2，1514次逻辑读也远大于4次。<br>显而易见，走索引的方式代价更低。</p><p>同时，选择的操作也比较艰难，缓存选择的结果，也能避免做重复的事情，提高效率。</p><p>第一个问题这里已经有答案了，那就是有缓存的存在，使得后续相同的查询不需要经过3区数据库，直接从2区的缓存中获取结果并返回。</p><h3 id="再探体系结构原理"><a href="#再探体系结构原理" class="headerlink" title="再探体系结构原理"></a>再探体系结构原理</h3><h4 id="从普通更新语句开始"><a href="#从普通更新语句开始" class="headerlink" title="从普通更新语句开始"></a>从普通更新语句开始</h4><p>下面主要是二三问题的解答，即体系结构图中上面没有被提及到的组件、进程的作用是什么？</p><p>sql语句除了上面的查询，还有更新语句，包括插入、修改、删除三类。如果是一个只读数据库，那么是不需要这么多组件的。<br>下面以 <code>update t set object_id=92 where object_id=29;</code> 为例。</p><p>sql执行过程前面和查询语句是一样的</p><ol><li>如果该用户并没有退出原连接去新建立一个连接，PGA区的用户连接信息和权限判断等诸多动作依然不用做，否则需要完成用户连接信息和权限判断等诸多动。</li><li>如果该语句是第一次执行，在共享池里依然需要完成语法语意分析及解析，update t set object_id&#x3D;92 where object_id&#x3D;29指令中想匹配到object_id&#x3D;29的记录既可以用索引读，也可以用全表扫描，到底选用哪种执行计划需要根据代价的大小来选择。</li><li>接下来进入数据缓存区，首次执行该数据一定不在缓存区里，也是和前面一样，先从磁盘中获取到缓存区中…</li></ol><p>到这里，查询语句将查询结果返回给用户，他的工作就结束了。但更新语句还有很多工作。</p><p>在更新语句改写了缓存区的数据后，将<strong>启动DBWR进程将新的数据从内存刷入磁盘</strong>。进行持久化存储，否则内存断点后，数据会消失。</p><p><strong>日志缓存区保存了数据库相关操作的日志</strong>，记录了这个动作，然后由<strong>LGWR后台进程将其从日志缓存区这个内存区写进磁盘的日志文件里</strong>。<br>目的很简单，就是为了便于将来出现异常情况时，可以根据日志文件中记录的动作，再继续执行一遍，从而保护数据的安全。</p><p>Oracle写日志是很重要的，LGWR进程会将日志缓存区持久化保存到日志文件。日志文件通常有多个，当第一个写满时，会写入第二个…<br>当所有的日志文件都写满时，会重新从第一个开始覆写。<strong>所以在日志文件被覆写之前，需要将其备份出去，成为归档文件。由ARCH进程进行归档操作。</strong></p><h4 id="关于提交-Commit"><a href="#关于提交-Commit" class="headerlink" title="关于提交 Commit"></a>关于提交 Commit</h4><p>当执行一条更新语句后，当前session再次查询是可以查询到更新后的数据的。<br>但是其他session无法查询到更新后的，因为没有提交。</p><p>提交 Commit 和 回滚 Rollback ，都是更新操作后，用户的确认。前者表示用户确认无误，确实需要更新；后者表示用户反悔了，撤销之前的操作。<br>其中涉及到的细节会很多，这里只是简单描述。</p><p>Commit操作，按照正常的逻辑，应该是执行之后，立刻被DBWR进程将更新后的数据写入磁盘，以便其他session查询到最新的数据和防止数据丢失。<br>但事实上并非如此，因为频繁的写入操作性能较低，等数据缓存区累积到一定量时成批写入性能会更高。但这样无法兼顾数据安全。<br><strong>所以Commit操作之后，并不一定会立刻被DBWR进程将更新后的数据写入磁盘。</strong><br>很多事情都很难两全其美，和分布式系统中的CAP理论一样。但这里oracle做到了兼顾，下面来说oracle是如何做到的？</p><p>因为oracle有日志缓存区和日志文件，在磁盘中记录了所有的操作，所以即便突然断电导致未提交的数据丢失，也可以通过日志文件重新执行之前的操作，从而恢复丢失的数据。<br>那么数据缓存区是否越大越好呢？<br>显然并不是，没有什么是极端的，需要从中取得平衡。数据缓存区越大，DBWR批量写入磁盘的效率越高，但断电恢复需要的时间就越长。反之也是一样</p><p>下面介绍CKPT，<strong>什么时候将数据缓存区的数据写入磁盘是由CKPT触发的</strong>。<br>如果更新操作的一直不提交，数据缓存区的数据会被写入磁盘中吗？<br>答案是会的，<strong>因为DBWR将数据缓存区数据写入磁盘，不是由Commit决定的，而是由CKPT决定的。</strong><br><strong>但当LGWR出现故障时，DBWR并不会听从CKPT的命令。会先等LGWR将日志缓存区的数据写入日志文件，才会完成数据缓存区写入磁盘的操作。</strong><br><strong>因为凡是有记录，否则会发送数据丢失的问题。</strong></p><h4 id="各主要进程总结"><a href="#各主要进程总结" class="headerlink" title="各主要进程总结"></a>各主要进程总结</h4><ol><li><strong>PMON (Process Monitor)</strong>:<br>PMON负责监控和清理数据库实例中的失败或不响应的用户进程。当检测到一个用户进程异常终止时，PMON会执行清理工作，包括回滚未提交的事务、释放资源以及从进程表中删除相应的条目。<br>如果遇到LGWR进程失败这样严重的问题，PMON可能会做出中止实例的激进操作，以防止数据混乱。<br>此外，PMON还负责执行某些数据库的初始化任务，如打开监听器连接。</li><li><strong>SMON (System Monitor)</strong>:<br>SMON关注的是系统级的操作，而非单个进程。主要负责实例恢复工作，在数据库实例启动时执行实例恢复，包括应用联机重做日志以恢复未提交的事务，并清理实例崩溃后可能遗留的临时段。SMON还负责合并空间碎片、回收不再使用的临时段和回滚段。</li><li><strong>LCKn (Lock Process)</strong>:<br>LCKn是锁进程，仅用于RAC数据库。其中’n’代表编号，表示可以有多个这样的进程（最多可能有10个）。这些进程管理数据库中的锁，确保并发访问的一致性和数据完整性。它们负责授予和撤销对数据库对象的锁，以及解决锁冲突，确保多个用户或进程能够安全地并发访问数据库资源。</li><li><strong>RECO (Recovery Process)</strong>:<br>RECO用于处理分布式事务中的失败情况。当一个分布式事务的一部分在远程数据库中失败时，RECO会根据两阶段提交协议的记录，自动尝试完成或回滚未决的分布式事务，确保事务的原子性和一致性。</li><li><strong>CKPT (Checkpoint Process)</strong>:<br>用于触发DBWR从数据缓存区中写出数据到磁盘。CKPT执行越频繁，DBWR写出越频繁，DBWR写出越频繁越不能显示批量特性，性能就越低，但是数据库异常恢复的时候会越迅速。</li><li><strong>DBWR (Database Writer)</strong>:<br>DBWR负责将数据库缓存区缓存（Buffer Cache）中的脏数据块（已修改但尚未写入磁盘的数据）写入到数据文件中。这有助于释放缓存区空间，提高缓存命中率，并确保数据的一致性。通常，DBWR会有多个实例运行（DBW0, DBW1等），以并行处理大量I&#x2F;O操作。</li><li><strong>LGWR (Log Writer)</strong>:<br>LGWR负责将重做日志缓存区中的内容定期或在特定触发条件下（如事务提交、重做日志缓存区空间不足、检查点事件等）写入到在线重做日志文件中。这保证了数据库的事务可恢复性，即使在系统故障后也能恢复到一致状态。</li><li><strong>ARCH (Archiver Process)</strong>:<br>在归档日志模式下，ARCH进程负责将已填满并归档标记的在线重做日志文件复制到归档存储位置，确保即使原始在线日志被覆盖，重做信息仍然可用，这对于数据库备份和恢复至关重要。在高负载或高可用性要求的系统中，可能有多个ARCH进程并行工作。</li></ol><blockquote><p>RAC（Real Application Clusters）是Oracle数据库的一项技术，它允许一个数据库分布在多个服务器上，这些服务器共享相同的数据库实例，并以集群的形式协同工作。RAC架构设计的主要目标是为了提高数据库的可用性、可伸缩性和性能。<br>在RAC环境下，数据库的数据文件、控制文件和重做日志文件等存储在共享存储设备上，所有参与集群的节点都可以访问这些共享资源。每个节点都运行着自己的Oracle实例，包含一个数据库实例进程集合，如LGWR、DBWR、CKPT等，以及前面提到的后台进程。这些实例通过高速互联（如InfiniBand网络）相互通信，协调对数据库的访问和数据修改。<br>RAC的实施和运维相对复杂，需要仔细规划网络、存储和系统资源，以及精细的配置和管理，以确保集群的稳定运行和最佳性能。</p></blockquote><p>LGWR的工作就是将日志缓存区的数据写入到磁盘的REDO日志文件中。完成对更新操作的记录，可用于数据库的异常恢复。<br>因为操作发生是有顺序的，比如建表、插入数据、删除、修改…<br>如果建表操作没有被记录，那么后续所有的操作都无法被执行。<br><strong>LGWR必须顺序的记录这些操作，顺序记录才有意义。因此，LGWR是单线程的。</strong></p><p>LGWR有5条规则，来适应高强度的日志记录工作。</p><ol><li>每隔三秒钟，LGWR运行一次。</li><li>任何COMMIT触发LGWR运行一次。</li><li>DBWR要把数据从数据缓存写到磁盘，触发LGWR运行一次。</li><li>日志缓存区满三分之一或记录满1MB,触发LGWR运行一次。</li><li>联机日志文件切换也将触发LGWR。</li></ol><h4 id="关于回滚-Rollback"><a href="#关于回滚-Rollback" class="headerlink" title="关于回滚 Rollback"></a>关于回滚 Rollback</h4><p>还是以 <code>update t set object_id=92 where object_id=29;</code> 为例。前面说过的PGA和共享池区部分省略</p><ol><li>想更新object_id&#x3D;29的记录首先就需要查到object_id&#x3D;29的记录，检查object_id&#x3D;29是否在数据缓存区里，不存在则从磁盘中读取到数据缓存区中，这一点和普通的查询语句类似。</li><li>但是这毕竞不是查询语句而是更新语句，于是要做一件和查询语句很不同的事，在回滚表空间的相应回滚段事务表上分配事务槽，从而在回滚表空间分配到空间。该动作需要记录日志写进日志缓存区。</li><li>在数据缓存区中创建object_id&#x3D;29的前镜像，前镜像数据也会写进磁盘的数据文件里（回滚表空间的数据文件)，从缓存区写进磁盘的规律前面已经说过了，由CKPT决定，由LGWR写入，当然也别忘记了这些动作都会记录日志，并将其写进日志缓存区，劳模LGWR还在忙着将日志缓存区的数据写入磁盘形成redo文件呢。</li><li>前面步骤做好了，才允许将object_id&#x3D;29修改为object_id&#x3D;92,这个显然也是要记录进日志缓存区的。</li><li>此时用户如果执行了提交，日志缓存区立即要记录这个提交信息，然后就把回滚段事务标记为非激活INACTIVE状态，表示允许重写。</li><li>如果是执行了回滚呢，Oracle需要从回滚段中将前镜像object_id&#x3D;29的数据读出米，修改数据缓存区，完成回滚。这个过程依然要产生日志，要写数据进日志缓存区。</li></ol><p>记录前镜像为什么也需要记录日志？<br>前镜像会记录在SGA的数据缓存区（Undohu缓存区）里，由CKPT触发LGWR数据缓存区写入磁盘。<br><strong>用于准备回滚的前镜像数据的生成其实和普通数据操作差不多，唯一的差别就在于一个是刷新到磁盘的普通文件里，一个是刷新到磁盘的回滚数据文件里。</strong></p><p>普通数据可能会出现事务已经commit，但数据还在数据缓存区中，没有被写入磁盘，数据丢失需要根据redo来进行重做恢复的场景。<br>回滚前镜像数据也是这样，需要记录回滚前镜像数据的相关操作，来应对用户需要回滚，但回滚前镜像数据既不在内存也不在磁盘的情况（比如突然断电）<br>此时回滚，则需要依据记录了前镜像数据的redo日志来重做一次还原前镜像数据的操作。</p><p>下面来看回滚段的相关参数。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; show parameters undo</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">temp_undo_enabled                    boolean     FALSE</span><br><span class="line">undo_management                      string      AUTO</span><br><span class="line">undo_retention                       integer     900</span><br><span class="line">undo_tablespace                      string      UNDOTBS1</span><br></pre></td></tr></table></figure><p>UNDO MANAGEMETN为AUTO表示是自动回滚段管理，回滚段空间不够时可以自动扩展<br>UNDO RETENTION为900的含义是，DML语句需要记录前镜像，当COMMIT后，表示回滚段保留的前镜像被打上了可以覆盖重新使用的标记，但是要在900秒后方可允许<br>UNDO TABLESPACE为UNDOTBS1就不用多解释了，表示回滚段表空间的名字为UNDOTBS1</p><p>Undo日志（回滚日志）和Redo日志（重做日志）共同确保了事务处理的ACID特性（原子性、一致性、隔离性、持久性），特别是在事务管理和数据库恢复过程中。下面详细解释两者的作用：</p><ul><li>Undo日志（回滚日志）<br><strong>事务回滚：</strong>Undo日志记录了事务对数据库所做的修改前的原始数据状态。当一个事务需要被回滚时（例如，事务执行失败或者用户发出了ROLLBACK命令），数据库系统会利用Undo日志来撤销事务中已经执行的所有修改，恢复数据库到事务开始前的一致状态。这一过程保证了事务的原子性，即事务中的所有操作要么全部成功，要么全部失败。<br><strong>多版本并发控制（MVCC）：</strong>在支持多版本并发控制的数据库（如Oracle的InnoDB存储引擎）中，Undo日志还用来提供历史版本的数据，以便在事务执行期间保持数据的一致视图。这样，即使其他事务已经修改了数据，当前事务仍能看到符合其开始时刻的数据状态，增强了并发控制的能力。</li><li>Redo日志（重做日志）<br><strong>事务恢复：</strong>Redo日志记录了事务对数据库所做的所有修改操作，包括修改后的数据值、修改类型以及数据所在的位置。在系统发生故障（如电源故障、系统崩溃）之后，数据库可以使用Redo日志来“重做”那些已经完成但还未持久化到磁盘的事务操作，确保数据的持久性。即使在崩溃发生前数据尚未完全写入数据文件，也能通过重做日志恢复到崩溃前的最新状态。<br><strong>保证数据不丢失：</strong>Redo日志在事务提交时被写入，并且通常会先于实际数据更改持久化到磁盘，以防止在提交过程中出现故障导致的数据丢失。</li></ul><p>DML语句不同于查询语句，会改变数据库的数据。<br>除此之外，还会产生用于将来恢复的redo和用于回退的undo。<br>另外还有一个细节就是，由于undo也需要保护，所以还会专门产生保护undo操作的redo。</p><h4 id="一致读的原理"><a href="#一致读的原理" class="headerlink" title="一致读的原理"></a>一致读的原理</h4><p>查询的结果由查询的那个时刻决定了，后续数据新的变化是不予理睬的。<br>如果不这样，Oracle每次查询的结果都可能会不一样，会导致错误的产生。<br>比如从a向b转钱，两者的余额总和无论何时都应该是一样的。但如果在转钱之前查询余额总和，查询的过程中，钱才转到b的账户中，此时查询的最终结果肯定是错误的。<br>因为oracle不可能回头去查变化后的数据，这样如果一直有变化产生，查询将永远不会结束。</p><p>先介绍两个概念：</p><ol><li>系统更改号 SCN,SCN的全称是：System Change Number,这是一个只会增加不会减少的递增数字，存在于Oracle的最小单位块里，当某块改变时SCN就会递增。</li><li>回滚段记录事务槽（）（前面我在描述回滚的时候提过，事务槽是用来分配回滚空间的)，如果你更新了某块，事务就被写进事务槽里。如果未提交或者回滚，该块就存在活动事务，数据库读到此块可以识别到这种情况的存在。</li></ol><p>当开始查询时，首先会获取查询时刻的SCN号。查询过程中会比较查询时刻的SCN号与当前数据块头部的ITL槽内的SCN号（如果有多个ITL槽，取最大的SCN号）<br>如果查询时刻的SCN号大于ITL槽内的SCN号，说明该块的数据在这段时间没有被更新，可以放心地正常全部读。<br>如果查询时刻的SCN号小于ITL槽内的SCN号，说明该块的数据在这段时间被更新了，需要根据ITL槽中记录的对应的undo块的地址找到undo块，将undo块中记录的修改前的数据取出。</p><p>不过并不是查询开始的SCN大于等于查询中所有块的SCN就一定可以直接获取数据。<br>因为当前镜像数据c从回滚段中找不回来时，这个查询将会以 ORA-01555: Snapshot too old 的错误终止。查询失败，也不会返回一个错误的查询结果。</p><blockquote><p>ORA-01555 错误，正式名称为”Snapshot Too Old”（快照过旧），是Oracle数据库中常见的错误之一。<br>这个错误通常发生在执行查询或事务处理期间，数据库无法为查询结果提供足够旧的一致性读取快照，导致查询失败。这意味着数据库无法确保查询结果反映的是查询开始那一刻的数据状态，违反了读一致性原则。</p><p><strong>触发条件</strong>：</p><ol><li><strong>Undo表空间大小不足</strong>：如果数据库配置的Undo表空间大小较小，不足以存放长时间运行查询期间产生的undo信息，旧的undo记录可能会被新事务产生的undo信息覆盖。</li><li><strong>长查询与高并发更新</strong>：在查询执行过程中，如果有大量其他事务并发地对报表查询所涉及的数据表进行更新或删除操作，这将迅速消耗undo空间，可能导致查询所需的undo记录被提前清理。</li><li><strong>Undo_RETENTION设置不当</strong>：即使Undo表空间足够大，但如果Undo_RETENTION参数设置得过低，数据库也可能过早地回收undo信息，即使undo空间仍有空闲。</li></ol><p><strong>解决方案</strong>：</p><ul><li>增加Undo表空间的大小。</li><li>调整Undo_RETENTION参数以延长undo数据的保留时间。</li><li>优化长查询，减少查询执行时间。</li><li>使用绑定变量，减少硬解析，从而减少undo的生成。</li><li>在合适的情况下，考虑使用较大的隔离级别，如SERIALIZABLE，尽管这可能会影响并发性能。</li></ul></blockquote><p>早期的SQL Server的数据库版本，是读产生锁，在读数据时表就被锁住，这样确实是不存在问题了，不过如果读表会让表锁住，那数据库的并发会非常的糟糕。<br>早期的其他数据库版本也有边读边锁的，比如已经读过的记录就允许被修改，而未读过的数据却是被锁住的，不允许修改，这虽然稍稍有些改进，只锁了表的部分而非全部，但是还是读产生锁，非常糟糕。<br>而Oracle的回滚段，却解决了读一致性的问题，又避免了锁，大大增强了数据库并发操作的能力。</p><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><p>查看 sga 内存区大小</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; show parameters sga</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">allow_group_access_to_sga            boolean     FALSE</span><br><span class="line">lock_sga                             boolean     FALSE</span><br><span class="line">pre_page_sga                         boolean     TRUE</span><br><span class="line">sga_max_size                         big integer 1536M</span><br><span class="line">sga_min_size                         big integer 0</span><br><span class="line">sga_target                           big integer 1536M</span><br></pre></td></tr></table></figure><p>查看 pga 内存区大小</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; show parameters pga</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">pga_aggregate_limit                  big integer 2G</span><br><span class="line">pga_aggregate_target                 big integer 512M</span><br></pre></td></tr></table></figure><p>查看 共享池 大小</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; show parameters shared_pool_size</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">shared_pool_size                     big integer 0</span><br></pre></td></tr></table></figure><p>查看 数据缓存区 大小</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; show parameters db_cache_size</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">db_cache_size                        big integer 0</span><br></pre></td></tr></table></figure><p>会发现，共享池和数据缓存区的大小都为0<br>因为这里Oracle设置为SGA自动管理，共享池和数据缓存区的大小分配由之前的SGA MAX SIZE和SGA TARGET决定，总的大小为1536M<br>它们分别被分配多少由Oracle来决定，无须我们人工干预，其中SGA TARGET不能大于SGA MAX SIZE。</p><p>二者有什么差别呢？举个例子<br>比如SGA TARGET:&#x3D;2G,而SGA MAX SIZE&#x3D;8G,表示数据库正常运行情况下操作系统只分配2G的内存区给Oracle使用，而这2G就是共享池和数据缓存区等内存组件分配的大小<br>可是运行中发现内存不够用，这时OS可以再分配内存给SGA,但是最大不可以超过8G。</p><p>一般情况下都建议使用SGA内存大小自动分配的原则，如果一定要手工分配也行，把SGA TARGET设置为O,再把SHARED POOL SIZE和DB CACHE SIZE设置为非O,就可以了。<br>在启用自动管理时，数据库管理员不需要手动设置各个SGA组件（如共享池、数据缓冲区、大型池、Java池等）的确切大小。<br>相反，管理员会设置一个总的SGA目标大小（如通过SGA_TARGET参数），或者在使用AMM时，设置一个总的内存目标大小（MEMORY_TARGET），包括SGA和PGA（Program Global Area，程序全局区）。<br>Oracle数据库根据当前的工作负载和需求动态调整各个组件的大小，以优化资源使用和性能。</p><p>可以使用 ipcs -m 的查看共享内存的命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bash-4.4$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00000000 0          oracle     600        5361664    102                     </span><br><span class="line">0x00000000 1          oracle     600        1593835520 51                      </span><br><span class="line">0x00000000 2          oracle     600        4530176    51                      </span><br><span class="line">0xf2c898a4 3          oracle     600        20480      51  </span><br></pre></td></tr></table></figure><blockquote><p><code>ipcs -m</code> 是一个在Linux系统中用于显示内存共享段信息的命令。<code>ipcs</code> 命令是一个用于报告进程间通信（IPC）设施状态的实用程序，包括消息队列、信号量集和共享内存段。当加上 <code>-m</code> 选项时，它专门针对共享内存进行操作，显示当前系统中所有共享内存段的详细信息。<br>共享内存是进程间通信的一种高效方式，允许多个进程直接访问同一块内存区域，从而快速交换数据。<code>ipcs -m</code> 输出的信息通常包括如下几列：</p><ul><li><strong>Key</strong>：共享内存段的键值，用于标识共享内存段。</li><li><strong>shmid</strong>：共享内存段的ID。</li><li><strong>Owner</strong>：创建共享内存段的用户ID。</li><li><strong>Perms</strong>：共享内存段的权限。</li><li><strong>Bytes</strong>：共享内存段的大小（字节数）。</li><li><strong>Nattch</strong>：当前连接到该共享内存段的进程数。</li><li><strong>Status</strong>：共享内存段的状态，比如是否被附加（attached）。</li><li><strong>ctime</strong>：共享内存段创建的时间。</li><li><strong>mtime</strong>：共享内存段最后一次修改的时间。</li></ul></blockquote><p>查看 日志缓存区 大小</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; show parameters log_buffer</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">log_buffer                           big integer 4192K</span><br></pre></td></tr></table></figure><p>一般日志缓冲区满三分之一便会触发LGWR，将缓冲区中的内容写入磁盘，以确保有足够的空间供新的重做记录使用。</p><p>那该如何修改这些设置呢？具体命令如下：<br>使用 <code>alter system set &lt;parameter_name&gt;=&lt;value&gt; scope=memory|spfile both [sid=&lt;sid_name&gt;]</code> 命令可以动态修改许多系统参数。<br>其中 scope 参数表示其作用范围和持久性，它有三个枚举值。</p><ul><li>memory:只改变当前实例运行，重新启动数据库后失效。</li><li>spfile:只改变spfile的设置，不改变当前实例运行，重新启动数据库后生效。</li><li>both（默认值）:同时改变实例及spfile,当前更改立即生效，重新启动数据库后仍然有效。</li></ul><p>可以通过 ALTER SYSTEM 或者导入导出来更改 spfile 的内容。<br>针对RAC环境，ALTER SYSTEM 还可以指定SD参数，对不同实例进行不同的设置。</p><ol><li>如果当前实例使用的是pfle而非spfile,则scope&#x3D;-spfile或scope–both会产生错误</li><li>如果实例以pfle启动，则scope的默认值为memory,若以spfile启动，则默认值为both</li><li>有些参数（静态参数）必须重启才能生效，如log buffer</li></ol><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>Oracle数据库是由实例和一组数据库文件组成的，实例则是由Oracle开辟的内存区和一组后台进程组成的。</p><p>下面登录Oracle数据库环境，来看一下这些后台进程。<br>这里登录的环境是Linux&#x2F;UNIX环境，因为Windows环境中Oracle是多线程形式的，不好查看。而UNIX环境是多进程形式的，更方便查看。</p><p>查看 实例名称</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; show parameters instance_name</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">instance_name                        string      FREE</span><br></pre></td></tr></table></figure><p>使用实例名称来过滤，比使用oracle更加精准。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">bash-4.4$ ps -ef|grep FREE  </span><br><span class="line">oracle        33       1  0 Jul16 ?        00:00:33 db_pmon_FREE</span><br><span class="line">oracle        37       1  0 Jul16 ?        00:00:06 db_clmn_FREE</span><br><span class="line">oracle        41       1  0 Jul16 ?        00:00:48 db_psp0_FREE</span><br><span class="line">oracle        45       1  0 Jul16 ?        00:00:52 db_vktm_FREE</span><br><span class="line">oracle        51       1  0 Jul16 ?        00:00:19 db_gen0_FREE</span><br><span class="line">oracle        55       1  0 Jul16 ?        00:00:10 db_mman_FREE</span><br><span class="line">oracle        61       1  0 Jul16 ?        00:00:09 db_gen2_FREE</span><br><span class="line">oracle        63       1  0 Jul16 ?        00:00:10 db_diag_FREE</span><br><span class="line">oracle        65       1  0 Jul16 ?        00:00:08 db_ofsd_FREE</span><br><span class="line">oracle        69       1  0 Jul16 ?        00:00:14 db_gwpd_FREE</span><br><span class="line">oracle        71       1  0 Jul16 ?        00:01:24 db_dbrm_FREE</span><br><span class="line">oracle        73       1  0 Jul16 ?        00:10:04 db_vkrm_FREE</span><br><span class="line">oracle        75       1  0 Jul16 ?        00:00:38 db_pman_FREE</span><br><span class="line">oracle        78       1  0 Jul16 ?        00:01:42 db_dia0_FREE</span><br><span class="line">oracle        81       1  0 Jul16 ?        00:00:28 db_dbw0_FREE</span><br><span class="line">oracle        83       1  0 Jul16 ?        00:00:28 db_lgwr_FREE</span><br><span class="line">oracle        85       1  0 Jul16 ?        00:00:54 db_ckpt_FREE</span><br><span class="line">oracle        87       1  0 Jul16 ?        00:00:05 db_smon_FREE</span><br><span class="line">oracle        90       1  0 Jul16 ?        00:00:19 db_smco_FREE</span><br><span class="line">oracle        96       1  0 Jul16 ?        00:00:03 db_reco_FREE</span><br><span class="line">oracle       102       1  0 Jul16 ?        00:00:11 db_lreg_FREE</span><br><span class="line">oracle       109       1  0 Jul16 ?        00:00:10 db_pxmn_FREE</span><br><span class="line">oracle       115       1  0 Jul16 ?        00:01:06 db_mmon_FREE</span><br><span class="line">oracle       117       1  0 Jul16 ?        00:01:00 db_mmnl_FREE</span><br><span class="line">oracle       121       1  0 Jul16 ?        00:01:55 db_bg00_FREE</span><br><span class="line">oracle       123       1  0 Jul16 ?        00:00:09 db_w000_FREE</span><br><span class="line">oracle       131       1  0 Jul16 ?        00:00:47 db_bg01_FREE</span><br><span class="line">oracle       137       1  0 Jul16 ?        00:00:53 db_bg02_FREE</span><br><span class="line">oracle       146       1  0 Jul16 ?        00:00:03 db_d000_FREE</span><br><span class="line">oracle       148       1  0 Jul16 ?        00:00:02 db_s000_FREE</span><br><span class="line">oracle       150       1  0 Jul16 ?        00:00:03 db_tmon_FREE</span><br><span class="line">oracle       152       1  0 Jul16 ?        00:00:08 db_rcbg_FREE</span><br><span class="line">oracle       159       1  0 Jul16 ?        00:00:03 db_tt00_FREE</span><br><span class="line">oracle       162       1  0 Jul16 ?        00:00:08 db_tt01_FREE</span><br><span class="line">oracle       166       1  0 Jul16 ?        00:00:08 db_p000_FREE</span><br><span class="line">oracle       254       1  0 Jul16 ?        00:00:03 db_aqpc_FREE</span><br><span class="line">oracle       381       1  0 Jul16 ?        00:19:13 db_cjq0_FREE</span><br><span class="line">oracle       423       1  0 Jul16 ?        00:00:04 db_qm02_FREE</span><br><span class="line">oracle       427       1  0 Jul16 ?        00:00:02 db_q002_FREE</span><br><span class="line">oracle       431       1  0 Jul16 ?        00:00:06 db_q004_FREE</span><br><span class="line">oracle       478       1  0 Jul16 ?        00:00:09 db_w001_FREE</span><br><span class="line">oracle      1007    1006  0 Jul16 ?        00:00:00 oracleFREE (DESCRIPTION=(LOCAL=YES)(ADDRESS=(PROTOCOL=beq)))</span><br><span class="line">oracle      4550       1  0 Jul16 ?        00:00:04 oracleFREE (LOCAL=NO)</span><br><span class="line">oracle     44919       1  0 Jul17 ?        00:00:00 oracleFREE (LOCAL=NO)</span><br><span class="line">oracle     45470       1  0 Jul17 ?        00:00:00 oracleFREE (LOCAL=NO)</span><br><span class="line">oracle     65331       1  0 Jul17 ?        00:00:00 oracleFREE (LOCAL=NO)</span><br><span class="line">oracle    120778       1  0 Jul18 ?        00:01:20 db_m005_FREE</span><br><span class="line">oracle    121022       1  0 Jul18 ?        00:01:20 db_m004_FREE</span><br><span class="line">oracle    123426       1  0 Jul18 ?        00:01:17 db_m003_FREE</span><br><span class="line">oracle    125755       1  0 Jul18 ?        00:01:18 db_m000_FREE</span><br><span class="line">oracle    167946       1  0 10:41 ?        00:00:00 oracleFREE (LOCAL=NO)</span><br><span class="line">oracle    171135       1  0 11:58 ?        00:00:12 db_m006_FREE</span><br><span class="line">oracle    178882  170338  0 15:05 pts/6    00:00:00 grep FREE</span><br></pre></td></tr></table></figure><p>这里可以看到有很多前面介绍的进程，比如lgwr。<br>LOCAL&#x3D;NO 表示非Oracle本身的进程，是通过其他用户通过监听连接进数据库进行访问的。</p><p>这里缺少了一个重要的进程，ARCH归档进程。<br>当日志循环写入过程中会出现下一个日志已经被写过的情况，再继续写将会覆盖其内容，需要将这些即将被覆盖的内容写出到磁盘里去形成归档文件。<br>这样日志记录不会丢失，将来数据库就可以从这些日志文件和归档文件中进行数据库的恢复处理。<br>不过这个归档并非总是必要的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; archive log list </span><br><span class="line">Database log mode              No Archive Mode</span><br><span class="line">Automatic archival             Disabled</span><br><span class="line">Archive destination            /opt/oracle/product/23ai/dbhomeFree/dbs/arch</span><br><span class="line">Oldest online log sequence     8</span><br><span class="line">Current log sequence           6</span><br></pre></td></tr></table></figure><p>可以看到 No Archive Mode 数据库归档是关闭的。<br>更改数据库归档模式需要重启数据库，将数据库置于mount状态后，输入<code>alter database archivelog</code>(如果是归档改为非归档，这里是<code>alter database noarchivelog</code>)<br>然后再开启数据库<code>alter database open</code>,才可以将数据库更改为非归档，具体步骤如下（这里就不一一执行了）：</p><ol><li>SQL&gt; shutdown immediate;  – 关闭数据库</li><li>startup mount; – 启动数据库实例，并将数据库装载（mount）到实例中，但不打开（open）数据库。</li><li>alter database archivelog; – 将数据库从非归档模式转换为归档模式</li><li>alter database open; – 打开数据库</li></ol><h5 id="启停"><a href="#启停" class="headerlink" title="启停"></a>启停</h5><p>参数文件及控制文件和数据库的启动与关闭是息息相关的，数据库的启动可分为三个阶段，分别是nomount、mount和open。<br>在启动的过程中可以直接输入startup启动，也可以分成startup nomount、startup mount和alter database open三步分别启动。</p><ol><li><p><strong>STARTUP NOMOUNT</strong>：</p><ul><li>此阶段初始化Oracle实例，但不装载数据库的任何数据文件或控制文件。主要用于配置参数、分配内存结构等初始化工作。</li><li>读取参数文件（PFILE&#x2F;SPFILE），分配SGA（系统全局区），启动后台进程。</li></ul></li><li><p><strong>STARTUP MOUNT</strong>：</p><ul><li>装载数据库但不打开。此时，控制文件被读取，数据库结构被识别，但数据文件保持关闭状态。</li><li>除了NOMOUNT阶段的工作，还会装载控制文件，验证数据文件和联机重做日志文件的存在和一致性。</li></ul></li><li><p><strong>ALTER DATABASE OPEN</strong>：</p><ul><li>打开数据库，使其对用户可用。数据文件被打开，检查点信息被处理，必要时进行恢复操作。</li><li>打开数据文件，应用重做日志以确保数据的一致性，启动必要的后台进程，解锁数据库供用户访问。</li></ul></li><li><p><strong>STARTUP RESTRICT</strong>（可选）：</p><ul><li>以受限模式打开数据库，仅允许特定用户（如DBA）连接，常用于维护操作。</li><li>类似OPEN，但限制了连接数据库的用户权限。</li></ul></li><li><p><strong>STARTUP FORCE</strong>（可选）：</p><ul><li>强制关闭数据库（如果已打开）并重新启动。适用于数据库不能正常关闭的情况。</li><li>相当于执行了<code>SHUTDOWN ABORT followed by STARTUP</code>。</li></ul></li></ol><p>总结起来，nomount阶段仅需一个参数文件即可成功，mount阶段要能够正常读取到控制文件才能成功。<br>而opn阶段需要保证所有的数据文件和日志文件等需要和控制文件里记录的名称和位置一致，能被锁定访问更新的同时还要保证没有损坏，否则数据库的ope阶段就不可能成功。</p><p>关闭是启动的逆过程<br>首先把数据库关闭，然后数据库和实例之间DISMOUNT，最后实例关闭。<br>这里三个阶段都在一个命令中完成，如下：</p><ol><li><p><strong>SHUTDOWN NORMAL</strong>：</p><ul><li>平缓关闭数据库，等待所有用户断开连接后才关闭，确保数据完整性和一致性。</li><li>阻止新连接，等待当前所有会话完成，执行检查点，关闭数据库和实例。</li></ul></li><li><p><strong>SHUTDOWN TRANSACTIONAL</strong>：</p><ul><li>类似于NORMAL，但在所有事务结束前不等待长时间运行的查询。</li><li>比NORMAL更快关闭，但保证所有事务完成。</li></ul></li><li><p><strong>SHUTDOWN IMMEDIATE</strong>：</p><ul><li>立即关闭，不等待用户会话完成，但允许当前事务完成。</li><li>终止所有非系统会话，允许当前事务快速提交或回滚后关闭。</li></ul></li><li><p><strong>SHUTDOWN ABORT</strong>：</p><ul><li>紧急关闭，不执行任何清理工作，可能导致未提交的事务丢失和需要实例恢复。</li><li>立即终止所有会话，不执行检查点或事务回滚，可能导致数据库需要恢复。</li></ul></li></ol><h5 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h5><p>没有参数文件，实例无法创建，数据库无法NOMOUNT成功<br>没有控制文件，数据库无法 MOUNT<br>没有数据文件，数据库无法打开使用（此外没有了数据文件，那数据也没地方保存了，数据库也失去意义了)<br>没有日志和归档文件，数据库就失去了保护伞，变得很不安全了。</p><p>参数文件位置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; show parameters spfile</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">spfile                               string      /opt/oracle/product/23ai/dbhom</span><br><span class="line">                                                 eFree/dbs/spfileFREE.ora</span><br></pre></td></tr></table></figure><p>控制文件位置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; show parameters control</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">control_file_record_keep_time        integer     7</span><br><span class="line">control_files                        string      /opt/oracle/oradata/FREE/contr</span><br><span class="line">                                                 ol01.ctl, /opt/oracle/oradata/</span><br><span class="line">                                                 FREE/control02.ctl</span><br><span class="line">control_management_pack_access       string      DIAGNOSTIC+TUNING</span><br><span class="line">diagnostics_control                  string      IGNORE</span><br></pre></td></tr></table></figure><p>数据文件位置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select file_name from DBA_DATA_FILES;</span><br><span class="line"></span><br><span class="line">FILE_NAME</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">/opt/oracle/oradata/FREE/users01.dbf</span><br><span class="line">/opt/oracle/oradata/FREE/undotbs01.dbf</span><br><span class="line">/opt/oracle/oradata/FREE/system01.dbf</span><br><span class="line">/opt/oracle/oradata/FREE/sysaux01.dbf</span><br></pre></td></tr></table></figure><p>日志文件位置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select group#,member from v$logfile;</span><br><span class="line"></span><br><span class="line">    GROUP# MEMBER</span><br><span class="line">---------- ----------------------------------------------------------------------</span><br><span class="line">         3 /opt/oracle/oradata/FREE/redo03.log</span><br><span class="line">         2 /opt/oracle/oradata/FREE/redo02.log</span><br><span class="line">         1 /opt/oracle/oradata/FREE/redo01.log</span><br></pre></td></tr></table></figure><p>归档文件位置（这里未开启归档模式，所以没有归档文件）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; show parameters recovery</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">_instance_recovery_bloom_filter_size integer     1048576</span><br><span class="line">db_recovery_auto_rekey               string      ON</span><br><span class="line">db_recovery_file_dest                string</span><br><span class="line">db_recovery_file_dest_size           big integer 0</span><br><span class="line">recovery_parallelism                 integer     0</span><br><span class="line">remote_recovery_file_dest            string</span><br><span class="line">transaction_recovery                 string      ENABLED</span><br></pre></td></tr></table></figure><p>告警日志文件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; show parameters dump</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">background_core_dump                 string      partial</span><br><span class="line">background_dump_dest                 string      /opt/oracle/product/23ai/dbhom</span><br><span class="line">                                                 eFree/rdbms/log</span><br><span class="line">core_dump_dest                       string      /opt/oracle/diag/rdbms/free/FR</span><br><span class="line">                                                 EE/cdump</span><br><span class="line">max_dump_file_size                   string      32M</span><br><span class="line">shadow_core_dump                     string      partial</span><br><span class="line">user_dump_dest                       string      /opt/oracle/product/23ai/dbhom</span><br><span class="line">                                                 eFree/rdbms/log</span><br></pre></td></tr></table></figure><h5 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h5><p>如果想在远程A机器上通过网络访问本地B机器上的数据库，B机器上的数据库必须开启监听。<br>远程的A机器只需安装数据库客户端，然后通过读取A机器上数据库客户端配置的TNSNAMES.ORA的配置文件，即可连接并访问B机器的数据库。<br>下面介绍监听状态的查看，监听的开启，以及监听的关闭。<br>以下<code>Isnrctl status</code>命令是查看监听的状态命令，其中 Listener Parameter File 和 Listener Log File 定位了监听文件listener.ora以及对应的日志。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bash-4.4$ lsnrctl status</span><br><span class="line"></span><br><span class="line">LSNRCTL for Linux: Version 23.0.0.0.0 - Production on 25-JUL-2024 20:16:51</span><br><span class="line"></span><br><span class="line">Copyright (c) 1991, 2024, Oracle.  All rights reserved.</span><br><span class="line"></span><br><span class="line">Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC_FOR_FREE)))</span><br><span class="line">STATUS of the LISTENER</span><br><span class="line">------------------------</span><br><span class="line">Alias                     LISTENER</span><br><span class="line">Version                   TNSLSNR for Linux: Version 23.0.0.0.0 - Production</span><br><span class="line">Start Date                16-JUL-2024 15:25:32</span><br><span class="line">Uptime                    9 days 4 hr. 51 min. 19 sec</span><br><span class="line">Trace Level               off</span><br><span class="line">Security                  ON: Local OS Authentication</span><br><span class="line">SNMP                      OFF</span><br><span class="line">Default Service           FREE</span><br><span class="line">Listener Parameter File   /opt/oracle/product/23ai/dbhomeFree/network/admin/listener.ora</span><br><span class="line">Listener Log File         /opt/oracle/diag/tnslsnr/oracle/listener/alert/log.xml</span><br><span class="line">Listening Endpoints Summary...</span><br><span class="line">  (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC_FOR_FREE)))</span><br><span class="line">  (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=0.0.0.0)(PORT=1521)))</span><br><span class="line">Services Summary...</span><br><span class="line">Service &quot;16df542da83f091ce0630500580a27e7&quot; has 1 instance(s).</span><br><span class="line">  Instance &quot;FREE&quot;, status READY, has 1 handler(s) for this service...</span><br><span class="line">Service &quot;FREE&quot; has 1 instance(s).</span><br><span class="line">  Instance &quot;FREE&quot;, status READY, has 1 handler(s) for this service...</span><br><span class="line">Service &quot;FREEXDB&quot; has 1 instance(s).</span><br><span class="line">  Instance &quot;FREE&quot;, status READY, has 1 handler(s) for this service...</span><br><span class="line">Service &quot;PLSExtProc&quot; has 1 instance(s).</span><br><span class="line">  Instance &quot;PLSExtProc&quot;, status UNKNOWN, has 1 handler(s) for this service...</span><br><span class="line">Service &quot;freepdb1&quot; has 1 instance(s).</span><br><span class="line">  Instance &quot;FREE&quot;, status READY, has 1 handler(s) for this service...</span><br><span class="line">The command completed successfully</span><br></pre></td></tr></table></figure><p>关闭监听 <code>lsnrctl stop</code><br>关闭监听 <code>lsnrctl start</code></p><h3 id="体会-sql-性能差异"><a href="#体会-sql-性能差异" class="headerlink" title="体会 sql 性能差异"></a>体会 sql 性能差异</h3><h4 id="未优化前，单车速度"><a href="#未优化前，单车速度" class="headerlink" title="未优化前，单车速度"></a>未优化前，单车速度</h4><p>使用以下存储过程，实现将1到10万插入到t表中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create or replace procedure proc1</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">    for i in 1..100000</span><br><span class="line">        loop</span><br><span class="line">            execute immediate</span><br><span class="line">                &#x27;insert into t values (&#x27;||i||&#x27;)&#x27;;</span><br><span class="line">            commit;</span><br><span class="line">        end loop;</span><br><span class="line">end;</span><br><span class="line">-- 这里要记得先预先执行一遍，将过程创建起来！</span><br></pre></td></tr></table></figure><p>初始化表结构、清空共享池、开启计时等。每次执行存储过程前重置，以便观察各个存储的性能。后续省略</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; drop table t purge;</span><br><span class="line"></span><br><span class="line">Table dropped.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.45</span><br><span class="line">SQL&gt; create table t(x int);</span><br><span class="line"></span><br><span class="line">Table created.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.15</span><br><span class="line">SQL&gt; alter system flush shared_pool;</span><br><span class="line"></span><br><span class="line">System altered.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:01.28</span><br><span class="line">SQL&gt; set timing on</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; exec proc1;</span><br><span class="line"></span><br><span class="line">PL/SQL procedure successfully completed.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:53.68</span><br><span class="line">SQL&gt; select count(*) from t;</span><br><span class="line"></span><br><span class="line">  COUNT(*)</span><br><span class="line">----------</span><br><span class="line">    100000</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.09</span><br></pre></td></tr></table></figure><p>耗时53秒68，每秒两千条不到。</p><p>共享池中缓存下来的SQL语句以及HASH出来的唯一值，都可以在v$sql中对应的 SQL_TEXT 和 SQL_ID 字段中查询到<br>而解析的次数和执行的次数分别可以从 PARSE_CALL 和 EXECUTIONS 字段中获取。<br>由于这个过程PROC1执行的是 insert into t 的系列插入，于是我们执行如下语句来查询PROC1在数据库共享池中执行的情况，具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select t.sql_text,t.sql_id,t.PARSE_CALLS,t.EXECUTIONS</span><br><span class="line">from v$sql t</span><br><span class="line">where sql_text like &#x27;%insert into t values%&#x27;;</span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E5%BC%80%E5%A7%8B%E5%92%8C%E7%89%A9%E7%90%86%E4%BD%93%E7%B3%BB/PROC1%E5%9C%A8%E5%85%B1%E4%BA%AB%E6%B1%A0%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E6%83%85%E5%86%B5.png"                        alt="PROC1在共享池中的执行情况.png"                 ></p><p>可以看到共享池中有大量相似的sql，他们的sql_id都不一样，每个语句都被解析了一次、执行了一次。<br>这些sql都是高度相似的，如果这些语句都能合并成一种写法，不是就可以只解析一次，然后执行十万次，节省了解析的时间。</p><h4 id="绑定变量，摩托速度"><a href="#绑定变量，摩托速度" class="headerlink" title="绑定变量，摩托速度"></a>绑定变量，摩托速度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create or replace procedure proc2</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">    for i in 1..100000</span><br><span class="line">        loop</span><br><span class="line">            execute immediate</span><br><span class="line">                &#x27;insert into t values (:x)&#x27; using i;</span><br><span class="line">            commit;</span><br><span class="line">        end loop;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; exec proc2;</span><br><span class="line"></span><br><span class="line">PL/SQL procedure successfully completed.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:03.50</span><br></pre></td></tr></table></figure><p>耗时3秒50，每秒八千多条。<br>看来sql的解析还是很耗时的。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E5%BC%80%E5%A7%8B%E5%92%8C%E7%89%A9%E7%90%86%E4%BD%93%E7%B3%BB/PROC2%E5%9C%A8%E5%85%B1%E4%BA%AB%E6%B1%A0%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E6%83%85%E5%86%B5.png"                        alt="PROC2在共享池中的执行情况.png"                 ></p><h4 id="静态改写，汽车速度"><a href="#静态改写，汽车速度" class="headerlink" title="静态改写，汽车速度"></a>静态改写，汽车速度</h4><p>execute immediate 是一种动态SQL的写法，常用于表名字段名是变量、入参的情况，由于表名都不知道，所以当然不能直接写SQL语句了。<br>所以要靠动态SQL语句根据传入的表名参数，来拼成一条SQL语句，由 execute immediate 调用执行。<br>但是这里显然不需要多此一举，因为insert into t values()完全可以满足需求，表名就是t，是确定的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create or replace procedure proc3</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">    for i in 1..100000</span><br><span class="line">        loop</span><br><span class="line">            insert into t values (i);</span><br><span class="line">            commit;</span><br><span class="line">        end loop;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; exec proc3;</span><br><span class="line"></span><br><span class="line">PL/SQL procedure successfully completed.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:03.19</span><br></pre></td></tr></table></figure><p>耗时3秒19，又快了一些。</p><p>一般来说，静态SQL会自动使用绑定变量<br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A%E7%AF%87-%E5%BC%80%E5%A7%8B%E5%92%8C%E7%89%A9%E7%90%86%E4%BD%93%E7%B3%BB/PROC3%E5%9C%A8%E5%85%B1%E4%BA%AB%E6%B1%A0%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E6%83%85%E5%86%B5.png"                        alt="PROC3在共享池中的执行情况.png"                 ></p><p>从执行情况可以看到proc3也实现了绑定变量，而且动态SQL的特点是执行过程中再解析，而静态SQL的特点是编译的过程就解析好了。<br>这点差别就是速度再度提升的原因。</p><h4 id="批量提交，动车速度"><a href="#批量提交，动车速度" class="headerlink" title="批量提交，动车速度"></a>批量提交，动车速度</h4><p>commit 放在里面意味着每插入1条，就要提交1次，那放在循环里就要提交10万次，而放在循环外就是全部插入完后提交1次。<br>commit 触发 LGWR 将 REDO BUFFER 写出到 REDO LOG 中，并且将回滚段的活动事务标记为不活动，同时让回滚段中记录对应前镜像记录的所在位置标记为可以重写。<br>切记 commit 可不是写数据的动作，写数据将数据从 DATA BUFFER 刷出磁盘是由 CKPT。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; exec proc4;</span><br><span class="line"></span><br><span class="line">PL/SQL procedure successfully completed.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:03.02</span><br></pre></td></tr></table></figure><h4 id="集合写法，飞机速度"><a href="#集合写法，飞机速度" class="headerlink" title="集合写法，飞机速度"></a>集合写法，飞机速度</h4><p><code>insert into t select rownum from dual connect by level&lt;=100000;</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; insert into t select rownum from dual connect by level&lt;=100000;</span><br><span class="line"></span><br><span class="line">100000 rows created.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.14</span><br></pre></td></tr></table></figure><p>耗时仅0.14秒<br>因为原先的过程变为了sql，一条条插入的语句变成了一个集合的概念，变成了一整批地写进 DATA BUFFER 区里。<br>好比你要运砖头到目的地，一种是一块砖头拿到目的地，再返回拿第二块，直到拿完全部。<br>而另一种是全部放在板车一起推至目的地，只是这里的目的地是 DATA BUFFER 区而已。</p><h4 id="直接路径，火箭速度"><a href="#直接路径，火箭速度" class="headerlink" title="直接路径，火箭速度"></a>直接路径，火箭速度</h4><p>时间已经很小了，这时可能会有误差，所以将数据量放大到200万。<del>没加太大是因为我这小服务器内存不够</del></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; insert into t select rownum from dual connect by level&lt;=2000000;</span><br><span class="line"></span><br><span class="line">2000000 rows created.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:01.74</span><br></pre></td></tr></table></figure><p>耗时1.74秒。</p><p>下面使用 create table 的直接路径方式来新建t表。<br><code>create table t as select rownum x from dual connect by level&lt;=2000000;</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt;  create table t as select rownum x from dual connect by level&lt;=2000000;</span><br><span class="line"></span><br><span class="line">Table created.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:01.73</span><br></pre></td></tr></table></figure><p>区别不是很大，可能因为数据量的关系。</p><h4 id="并行设置，飞船速度"><a href="#并行设置，飞船速度" class="headerlink" title="并行设置，飞船速度"></a>并行设置，飞船速度</h4><p>最后，如果遇到性能好的机器，还是可以大幅度提升性能的。<br>设置日志关闭 nologging 并且设置 parallel 4 表示用到机器的4个CPU。<del>这里还是受限于机器了</del></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; create table t nologging parallel 4 as select rownum x from dual connect by level&lt;=2000000;</span><br><span class="line"></span><br><span class="line">Table created.</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:01.74</span><br></pre></td></tr></table></figure><h2 id="Oracle-环境的搭建"><a href="#Oracle-环境的搭建" class="headerlink" title="Oracle 环境的搭建"></a>Oracle 环境的搭建</h2><p>中间有段时间没有连着写，是去搭建Oracle环境了。毕竟公司的测试环境没有dba权限，还是自己搭一个比较好。<br>这里为了方便，采用官方的docker镜像进行部署。</p><p>首先用 <code>docker pull container-registry.oracle.com/database/free:latest</code> 拉取镜像。<br>镜像比较大，需要等一段时间。确保磁盘有足够的空间，我这里拉取的镜像id是 <code>7510f8869b04</code><br>如果下载过慢，或者内存不足，可以参考下面修改docker的配置文件 <code>sudo vim /etc/docker/daemon.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data-root&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/new_dir/docker&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>data-root 是docker数据存储位置<br>registry-mirrors 是镜像加速地址，这里使用的是网易的镜像加速地址<br>保存后重启docker即可，<code>sudo systemctl start docker</code></p><p>镜像拉取完成后，就可以构建启动容器了。<br><code>docker run -d --name oracle -h oracle -p 1521:1521 -v /etc/localtime:/etc/localtime:ro container-registry.oracle.com/database/free:latest</code></p><ul><li>-d: 这是一个标志，表示以守护态（detached mode）运行容器，即在后台运行，不会把容器的输出直接打印到当前终端。</li><li>–name oracle: 为新创建的容器指定一个名字 oracle，便于后续引用和管理。</li><li>-h oracle: 设置容器的主机名（hostname）为 oracle。这对于某些依赖主机名的应用配置是有帮助的。</li><li>-p 1521:1521: 映射容器的端口 1521 到宿主机的端口 1521。这允许外部通过宿主机的 1521 端口访问容器中的 Oracle 数据库服务。</li><li>-v &#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime:ro: 使用卷挂载的方式，将宿主机的 &#x2F;etc&#x2F;localtime 文件或目录以只读（read-only）模式挂载到容器的 &#x2F;etc&#x2F;localtime。这样做是为了确保容器内的时间与宿主机保持一致，避免时区问题。</li></ul><p>使用 <code>docker logs -f oracle</code> 查看容器日志，当出现 <code>DATABASE IS READY TO USE!</code> 时，即启动成功。<br>后面就可以愉快地使用Oracle了。</p><p><code>docker exec -it oracle sqlplus sys@localhost:1521/FREE as sysdba</code> 进入容器内，并进行登录。</p><h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>在SQL查询中，HINT 是一种向数据库优化器提供提示的方式，用来指导SQL执行计划的选择。<br>HINT 不是SQL语言的标准组成部分，而是数据库特有的优化手段，它通常以注释的形式出现在SQL语句中，让数据库的查询优化器遵循某种特定的执行路径或采用特定的算法来处理查询。</p><p>在Oracle数据库中，HINT的写法通常是在表名或视图名后面紧跟一个特定的提示关键字或短语，这些提示被包围在 &#x2F;*+ … *&#x2F; 注释符号内。例如，如果你想提示优化器使用特定的索引，可以这样写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX(table_name index_name) */</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> some_condition;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>INDEX(table_name index_name)</code> 是一个HINT，告诉优化器使用名为 <code>index_name</code> 的索引来访问 <code>table_name</code>。</p><p>还有一些常见的HINT，如：</p><ul><li><code>FULL(table_name)</code> 强制全表扫描。</li><li><code>USE_NL(a b)</code> 强制使用嵌套循环连接(a表和b表)。</li><li><code>USE_HASH(a b)</code> 强制使用哈希连接(a表和b表)。</li><li><code>PARALLEL(table_name, degree)</code> 指定表并行查询的度数。</li><li><code>LEADING(table_name[, ...])</code> 指定连接顺序的起始表。</li></ul><p>需要注意的是，使用HINT应当谨慎，<strong>因为它们会绕过数据库自动优化机制，只有在明确知道优化器选择的执行计划不如预期高效时才应考虑使用。</strong><br>而且，随着数据库版本的更新或数据分布的变化，曾经有效的HINT可能不再是最优选择，因此定期审查和调整HINT是必要的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于想深入了解下数据库，包括索引、分区表以及sql优化相关的知识，加上工作使用的是 Oracle 数据库。所以选择这本书开始学习。&lt;br&gt;最</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://cooooing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据库" scheme="https://cooooing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="《收获，不止Oracle》" scheme="https://cooooing.github.io/tags/%E3%80%8A%E6%94%B6%E8%8E%B7%EF%BC%8C%E4%B8%8D%E6%AD%A2Oracle%E3%80%8B/"/>
    
    <category term="Oracle" scheme="https://cooooing.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>玉子爱情故事</title>
    <link href="https://cooooing.github.io/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%8E%89%E5%AD%90%E7%88%B1%E6%83%85%E6%95%85%E4%BA%8B/"/>
    <id>https://cooooing.github.io/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%8E%89%E5%AD%90%E7%88%B1%E6%83%85%E6%95%85%E4%BA%8B/</id>
    <published>2024-06-10T12:54:45.000Z</published>
    <updated>2024-06-10T12:54:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>久违，好久没有这么悠闲地看电影了。啊，假期真好啊。<del>要是长一些就更好了（做梦…）</del></p><p>很棒的日常，让人羡慕的恋爱故事。啊，越来越喜欢看日常动画了…<br>轻音还没看完，孤独摇滚倒是一次都看完了。还有男子高中生日常，很久很久前看的了。<br>后面接着看轻音和玉子市场吧。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E7%8E%89%E5%AD%90%E7%88%B1%E6%83%85%E6%95%85%E4%BA%8B/%E7%8E%89%E5%AD%90%E7%88%B1%E6%83%85%E6%95%85%E4%BA%8B1.png"                        alt="玉子爱情故事1.png"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E7%8E%89%E5%AD%90%E7%88%B1%E6%83%85%E6%95%85%E4%BA%8B/%E7%8E%89%E5%AD%90%E7%88%B1%E6%83%85%E6%95%85%E4%BA%8B2.png"                        alt="玉子爱情故事2.png"                 ></p><p>咖啡屋的人生导师总是会说些富有哲理的话。</p><blockquote><p>今日永远不同于昨日，所以今日才那么地美好。不过也会令人有些寂寞，这份寂寞的苦涩会日复一日地加深。咖啡也一样</p></blockquote><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E7%8E%89%E5%AD%90%E7%88%B1%E6%83%85%E6%95%85%E4%BA%8B/%E7%8E%89%E5%AD%90%E7%88%B1%E6%83%85%E6%95%85%E4%BA%8B3.png"                        alt="玉子爱情故事3.png"                 ></p><p>玉子真可爱啊。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E7%8E%89%E5%AD%90%E7%88%B1%E6%83%85%E6%95%85%E4%BA%8B/%E7%8E%89%E5%AD%90%E7%88%B1%E6%83%85%E6%95%85%E4%BA%8B4.png"                        alt="玉子爱情故事4.png"                 ></p><p>又来了哦，人生导师。</p><blockquote><p>青春总是焦急的，连一勺砂糖溶于杯中的时间都等不及。后悔带来的苦涩，是对过去的见证。终将逐一化为杯中的咖啡的味道。</p></blockquote><p>也是美好的结局。<del>犹豫就会败北</del><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E7%8E%89%E5%AD%90%E7%88%B1%E6%83%85%E6%95%85%E4%BA%8B/%E7%8E%89%E5%AD%90%E7%88%B1%E6%83%85%E6%95%85%E4%BA%8B5.png"                        alt="玉子爱情故事5.png"                 ></p><p>最后，放下咖啡屋人生导师的介绍吧，整个商店街都很不错氛围，像家人一样的邻居。<br>人生导师似乎也有些故事，如果后面TV动画有的话，真想单独开一篇。</p><p>八百比邦夫（やおび くにお）<br>怀旧唱片店兼咖啡屋“星与小丑”的老板。喜欢独个儿说话。是个冲制的咖啡会切合过来品尝的人。学生时代曾与玉子的父亲组建过乐队。</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E7%8E%89%E5%AD%90%E7%88%B1%E6%83%85%E6%95%85%E4%BA%8B/%E5%85%AB%E7%99%BE%E6%AF%94%E9%82%A6%E5%A4%AB.png"                        alt="八百比邦夫.png"                 ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;久违，好久没有这么悠闲地看电影了。啊，假期真好啊。&lt;del&gt;要是长一些就更好了（做梦…）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;很棒的日常，让人羡慕的恋爱故事。啊，越来越喜欢看日常动画了…&lt;br&gt;轻音还没看完，孤独摇滚倒是一次都看完了。还有男子高中生日常，很久很久前看的了。&lt;br&gt;后面</summary>
      
    
    
    
    <category term="记录生活" scheme="https://cooooing.github.io/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="电影" scheme="https://cooooing.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>Collector收集器的使用</title>
    <link href="https://cooooing.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Collector%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://cooooing.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Collector%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2024-05-27T09:05:59.000Z</published>
    <updated>2024-05-27T09:05:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前写过一些 stream 流的用法。从那之后，用 stream 流就用的很开心。<br>但是，有时候也会疑惑。stream 流最后的终止操作，经常会这么写：<code>list.stream().collect(Collectors.toList());</code><br>虽然知道是将流的数据收集到 list 集合中，但不知道为什们这么写。<br>而且，也有这种简化写法：<code>list.stream().toList()</code>。在 Java16 才加入了这个写法。<br>更让人想知道，Collectors 返回的 Collector 收集器到底怎么使用？</p><p>另外，toList() 与 Collectors.toList() 是有区别的。<br>查看源码，可以看到 toList() 返回的是<strong>不可变</strong>的 list。<br>而 Collectors.toList() 返回的是<strong>可变</strong>的 list。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> List&lt;T&gt; <span class="title function_">toList</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> (List&lt;T&gt;) Collections.unmodifiableList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="built_in">this</span>.toArray())));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">                               (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                               CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面，来说 Collector 的用法。</p><h2 id="collect、Collector、Collectors-区别与关联"><a href="#collect、Collector、Collectors-区别与关联" class="headerlink" title="collect、Collector、Collectors 区别与关联"></a>collect、Collector、Collectors 区别与关联</h2><ol><li>collect 是 Stream 流的一个<strong>终止方法</strong>，会使用传入的收集器（入参）对结果执行相关的操作，这个收集器必须是 Collector 接口的实现类。</li><li>Collector 是一个<strong>接口</strong>，定义了一些方法，作用是将 Stream 流中的数据收集到集合中。</li><li>Collectors 是一个<strong>工具类</strong>，提供了很多的静态工厂方法，提供了很多常用的 Collector 接口的具体实现类，方便使用。</li></ol><h2 id="Collector-接口"><a href="#Collector-接口" class="headerlink" title="Collector 接口"></a>Collector 接口</h2><p>Collector 在 javadoc 中的描述是这样的：</p><blockquote><p>A mutable reduction operation that accumulates input elements into a mutable result container, optionally transforming the accumulated result into a final representation after all input elements have been processed. Reduction operations can be performed either sequentially or in parallel.</p></blockquote><p>Collector是一种可变的汇聚操作，它将输入元素累积到一个可变的结果容器中。在所有的元素处理完成后，Collector 将累积的结果转换成一个最终的表示（这是一个可选的操作）。Collector支持串行和并行两种方式执行。</p><p>先来简单看下 Collector 接口的源码（省略两个静态 of 方法，用于构造 Collector 实现类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collector</span>&lt;T, A, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Supplier&lt;A&gt; <span class="title function_">supplier</span><span class="params">()</span>;</span><br><span class="line">    BiConsumer&lt;A, T&gt; <span class="title function_">accumulator</span><span class="params">()</span>;</span><br><span class="line">    BinaryOperator&lt;A&gt; <span class="title function_">combiner</span><span class="params">()</span>;</span><br><span class="line">    Function&lt;A, R&gt; <span class="title function_">finisher</span><span class="params">()</span>;</span><br><span class="line">    Set&lt;Characteristics&gt; <span class="title function_">characteristics</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Characteristics</span> &#123;</span><br><span class="line">        CONCURRENT,</span><br><span class="line">        UNORDERED,</span><br><span class="line">        IDENTITY_FINISH</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Collector 接口定义了 3 个泛型、5 个接口方法、2个静态方法、3 个枚举值。</p><h3 id="泛型含义"><a href="#泛型含义" class="headerlink" title="泛型含义"></a>泛型含义</h3><ul><li>T：输入元素的类型</li><li>A：累积结果的容器类型</li><li>R：最终生成的结果类型</li></ul><h3 id="接口方法含义"><a href="#接口方法含义" class="headerlink" title="接口方法含义"></a>接口方法含义</h3><ol><li>supplier 方法：用来创建一个新的可变的集合。换句话说 Supplier 用来创建一个初始的集合。</li><li>accumulator 方法：定义了累加器，用来将原始元素添加到集合中。</li><li>combiner 方法：用于对并行操作生成的各个子集合结果进行合并。<strong>只有并行流会被调用</strong>。</li><li>finisher 方法：对遍历结束后的流做最后处理。<strong>可以省略，省略就是 <code>i -&gt; (R) i;</code>，恒等操作</strong>。</li><li>characteristics：返回一个不可变的 Characteristics 集合。它定义了收集器的行为，关于流是否可以并行归约，以及可以使用哪些优化的提示。</li></ol><p>前四个方法都是函数式接口，可以用 lambda 表达式简化表示。<br>所以下面示例时使用 lambda，不单独创建实现类。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>两个重载的静态方法 of 都用于构造 Collector 实现类。<br>区别在于是否省略 finisher 方法。<br>最后一个参数是 characteristics 枚举，为可变长度参数列表，可传多个。</p><h3 id="枚举值含义"><a href="#枚举值含义" class="headerlink" title="枚举值含义"></a>枚举值含义</h3><ol><li>UNORDERED：声明此收集器的汇总归约结果与 Stream 流元素遍历顺序无关，不受元素处理顺序影响。但是如果容器本身是有序的，那么这个收集器会保证元素顺序不变。</li><li>CONCURRENT：声明此收集器可以多个线程并行处理，允许并行流中进行处理。即 <strong>supplier 方法只会被调用一次，只创建一个结果容器，并且 combiner 方法不会被执行，这个容器必须是线程安全的</strong>。</li><li>IDENTITY_FINISH：声明此收集器的 finisher 方法是一个恒等操作，可以跳过。<strong>默认值</strong>。</li></ol><blockquote><p>需要注意的是<br>即使 collector 被标记为 UNORDERED 如果数据源或操作本身是有序的，那么系统的执行策略通常仍会保持这些元素的出现顺序。<br>由于在处理有序流时多个线程并发更新同一个共享的累加器容器，会导致元素的更新顺序变得不确定。所以系统通常会忽略有序源的 CONCURRENT 标记。除非同时还指定了 UNORDERED。</p></blockquote><h2 id="自定义-Collector-实现类"><a href="#自定义-Collector-实现类" class="headerlink" title="自定义 Collector 实现类"></a>自定义 Collector 实现类</h2><p>有一个数组 a,b,c,d,e,f,g<br>下面通过自定义的 collector 实现，返回一个 本身为 key，ascii 码为值的 map 集合。<br>同时，通过打印信息区分串行流与并行流的执行区别。</p><p>串行流（单线程顺序执行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; res = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span>)</span><br><span class="line">            .collect(Collector.of(</span><br><span class="line">                    () -&gt; &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; supplier...&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">                    &#125;,</span><br><span class="line">                    (left, right) -&gt; &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; accumulator: &quot;</span> + right);</span><br><span class="line">                        left.put(right, (<span class="type">int</span>) right.getBytes()[<span class="number">0</span>]);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    (left, right) -&gt; &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; combiner: &quot;</span> + left + <span class="string">&quot;+&quot;</span> + right);</span><br><span class="line">                        left.putAll(right);</span><br><span class="line">                        <span class="keyword">return</span> left;</span><br><span class="line">                    &#125;</span><br><span class="line">            ));</span><br><span class="line">    res.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;:&quot;</span> + v.toString()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>串行流输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main supplier...</span><br><span class="line">main accumulator: a</span><br><span class="line">main accumulator: b</span><br><span class="line">main accumulator: c</span><br><span class="line">main accumulator: d</span><br><span class="line">main accumulator: e</span><br><span class="line">main accumulator: f</span><br><span class="line">main accumulator: g</span><br><span class="line">a:97</span><br><span class="line">b:98</span><br><span class="line">c:99</span><br><span class="line">d:100</span><br><span class="line">e:101</span><br><span class="line">f:102</span><br><span class="line">g:103</span><br></pre></td></tr></table></figure><p>可以看到串行流中 supplier 方法只执行一次，并且 combiner 方法没有执行。</p><p>并行流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; res = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span>).parallel()</span><br><span class="line">            .collect(Collector.of(</span><br><span class="line">                    () -&gt; &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; supplier...&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">                    &#125;,</span><br><span class="line">                    (left, right) -&gt; &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; accumulator: &quot;</span> + right);</span><br><span class="line">                        left.put(right, (<span class="type">int</span>) right.getBytes()[<span class="number">0</span>]);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    (left, right) -&gt; &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; combiner: &quot;</span> + left + <span class="string">&quot;+&quot;</span> + right);</span><br><span class="line">                        left.putAll(right);</span><br><span class="line">                        <span class="keyword">return</span> left;</span><br><span class="line">                    &#125;</span><br><span class="line">            ));</span><br><span class="line">    res.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;:&quot;</span> + v.toString()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并行流输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">main supplier...</span><br><span class="line">ForkJoinPool.commonPool-worker-1 supplier...</span><br><span class="line">ForkJoinPool.commonPool-worker-2 supplier...</span><br><span class="line">ForkJoinPool.commonPool-worker-4 supplier...</span><br><span class="line">ForkJoinPool.commonPool-worker-5 supplier...</span><br><span class="line">ForkJoinPool.commonPool-worker-3 supplier...</span><br><span class="line">ForkJoinPool.commonPool-worker-6 supplier...</span><br><span class="line">ForkJoinPool.commonPool-worker-4 accumulator: d</span><br><span class="line">ForkJoinPool.commonPool-worker-1 accumulator: b</span><br><span class="line">main accumulator: e</span><br><span class="line">ForkJoinPool.commonPool-worker-6 accumulator: c</span><br><span class="line">ForkJoinPool.commonPool-worker-2 accumulator: a</span><br><span class="line">ForkJoinPool.commonPool-worker-3 accumulator: g</span><br><span class="line">ForkJoinPool.commonPool-worker-5 accumulator: f</span><br><span class="line">ForkJoinPool.commonPool-worker-6 combiner: &#123;b=98&#125;+&#123;c=99&#125;</span><br><span class="line">ForkJoinPool.commonPool-worker-6 combiner: &#123;a=97&#125;+&#123;b=98, c=99&#125;</span><br><span class="line">ForkJoinPool.commonPool-worker-5 combiner: &#123;f=102&#125;+&#123;g=103&#125;</span><br><span class="line">main combiner: &#123;d=100&#125;+&#123;e=101&#125;</span><br><span class="line">main combiner: &#123;d=100, e=101&#125;+&#123;f=102, g=103&#125;</span><br><span class="line">main combiner: &#123;a=97, b=98, c=99&#125;+&#123;d=100, e=101, f=102, g=103&#125;</span><br><span class="line">a:97</span><br><span class="line">b:98</span><br><span class="line">c:99</span><br><span class="line">d:100</span><br><span class="line">e:101</span><br><span class="line">f:102</span><br><span class="line">g:103</span><br></pre></td></tr></table></figure><p>可以看出并行流的执行逻辑。</p><ol><li>spliterator 分割迭代器 会将数据分割成多个片段，分割过程通常采用递归的方式动态进行，以平衡子任务的工作负载，提高资源利用率。</li><li>Fork&#x2F;Join 框架将这些数据片段分配到多个线程和处理器核心上进行并行处理。</li><li>处理完成后，结果会被汇总合并。合并过程通常也是递归进行的。</li></ol><h2 id="Collectors-常用收集器"><a href="#Collectors-常用收集器" class="headerlink" title="Collectors 常用收集器"></a>Collectors 常用收集器</h2><p>Collectors 提供了一系列的静态方法，一般情况下足够正常使用。<del>不然我也不会用这么久 stream 才来详细了解 Collector 了。</del></p><p>方法比较多，很多我也没用过。这里就不一一列举用法了。<br>用的时候查文档吧。<del>不然我和写文档有什么区别</del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前写过一些 stream 流的用法。从那之后，用 stream 流就用的很开心。&lt;br&gt;但是，有时候也会疑惑。stream 流最后的终止操</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://cooooing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://cooooing.github.io/tags/java/"/>
    
    <category term="stream" scheme="https://cooooing.github.io/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>结束了，答辩</title>
    <link href="https://cooooing.github.io/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%BB%93%E6%9D%9F%E4%BA%86%EF%BC%8C%E7%AD%94%E8%BE%A9/"/>
    <id>https://cooooing.github.io/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%BB%93%E6%9D%9F%E4%BA%86%EF%BC%8C%E7%AD%94%E8%BE%A9/</id>
    <published>2024-05-12T15:53:49.000Z</published>
    <updated>2024-05-12T15:53:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="答辩"><a href="#答辩" class="headerlink" title="答辩"></a>答辩</h2><p>5月9号下午坐高铁回学校，不知不觉从去年九月底实习到现在已经上了半年多的班了。<br>大四这一年，加上这次，也就去两次学校。<br>可能在去年七月份去南通如皋实训的时候，我的大学生活就已经结束了吧。</p><p>10号去拍毕业照，见到了已经调到东湖其他学院的章院长，拍了几张照片。<br>还有和朋友们一起拍的照片，包括最后12号晚上，和舍友一起拍的，应该也是最后在一起聚了。</p><p>晚上简单做了做答辩用的ppt，想着老师也不会特别为难。当然也不一定，我们的野兽王子就比较惨了。</p><p>11号早上八点，开始答辩了。我是我们组第二个，有点难顶。<br>不过也就那样，毕竟自己做的东西，问啥都没太大问题。<br>但是！他问ERP的全称？什么鬼问题，我说企业资源计划，他让我说英文的全称，还真给我这个英语学渣问住了。<br>事后查了一下，Enterprise Resource Planning。<br>估计也是没得问了，事后整理的三个问题，老狗没给我录下来，只能问老师要了一下。<br>如图，十分的难绷，甚至都是陈述句，没有一个问句：</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E7%BB%93%E6%9D%9F%E4%BA%86%EF%BC%8C%E7%AD%94%E8%BE%A9/3%E4%B8%AA%E9%97%AE%E9%A2%98.png"                        alt="3个问题"                 ></p><p>只能说，说的都是我论文的问题，和一些没做的东西。我该如何回答呢，那只能唯唯诺诺只答不辨了。</p><p>但是！我们的野兽王子不一样。<br>他的论文，指导老师给打了九十几，评阅老师只给了七十出头。分差超二十没有评优资格，于是是一场指导老师和评阅老师的纷争。<br>那个评阅老师也是十分的倔强，找院里把论文打回重新打分之后，还是给了七十几。啧啧啧<br>他答辩的时候，评阅老师提问的声音都高了很多。<br>不过最后，他的答辩分数拿了95，也是老师之间的博弈了。</p><p>我就有点麻了。只有75，不过问题不大，合格就行。</p><h2 id="评语"><a href="#评语" class="headerlink" title="评语"></a>评语</h2><p>以下是我的毕设的评语和得分：</p><p><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E7%BB%93%E6%9D%9F%E4%BA%86%EF%BC%8C%E7%AD%94%E8%BE%A9/%E6%8C%87%E5%AF%BC%E8%80%81%E5%B8%88%E8%AF%84%E9%98%85.png"                        alt="指导老师评阅.png"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E7%BB%93%E6%9D%9F%E4%BA%86%EF%BC%8C%E7%AD%94%E8%BE%A9/%E8%AF%84%E9%98%85%E8%80%81%E5%B8%88%E8%AF%84%E9%98%85.png"                        alt="评阅老师评阅.png"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E7%BB%93%E6%9D%9F%E4%BA%86%EF%BC%8C%E7%AD%94%E8%BE%A9/%E7%AD%94%E8%BE%A9%E7%BB%84%E8%AF%84%E9%98%85.png"                        alt="答辩组评阅.png"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cooooing.github.io/images/%E7%BB%93%E6%9D%9F%E4%BA%86%EF%BC%8C%E7%AD%94%E8%BE%A9/%E7%BB%BC%E5%90%88%E6%88%90%E7%BB%A9.png"                        alt="综合成绩.png"                 ></p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>结束了，我的舍友还是那个样子，虽然也有变化，但不大。<br>大家的路好像都不一样，也许已经到了离别的时候。有些伤感，不知道说些什么。<br>六月份还会再见一次，那时，就是真正离别的时候了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;答辩&quot;&gt;&lt;a href=&quot;#答辩&quot; class=&quot;headerlink&quot; title=&quot;答辩&quot;&gt;&lt;/a&gt;答辩&lt;/h2&gt;&lt;p&gt;5月9号下午坐高铁回学校，不知不觉从去年九月底实习到现在已经上了半年多的班了。&lt;br&gt;大四这一年，加上这次，也就去两次学校。&lt;br&gt;可能在去</summary>
      
    
    
    
    <category term="记录生活" scheme="https://cooooing.github.io/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="毕业" scheme="https://cooooing.github.io/tags/%E6%AF%95%E4%B8%9A/"/>
    
  </entry>
  
</feed>
